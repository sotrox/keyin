{"version":3,"file":"static/webpack/static/development/pages/composition.js.8c49ab817769f47f2297.hot-update.js","sources":["webpack:///./pages/composition.tsx"],"sourcesContent":["import { useReducer } from 'react';\n\nimport {\n    TonalInflector,\n    TonalCombiningForms,\n    TonalDesinenceInflection,\n    TonalLemmatizationAnalyzer,\n    Client\n} from 'taipa';\n\nclass Segment {\n    literal: string = '';\n\n    constructor(str: string) {\n        this.literal = str;\n    }\n\n    isBaseForm(str: string) {\n        if (str === this.literal) return true;\n        return false;\n    }\n\n    isProceedingForm(str: string) {\n        const infl = new TonalInflector();\n        const lx = infl.inflect(this.literal, new TonalCombiningForms(), new TonalDesinenceInflection());\n        if (lx.getProceedingForms().filter(x => x.literal === str).length > 0) return true;\n        return false;\n    }\n\n    includes(str: string) {\n        if (this.isBaseForm(str) || this.isProceedingForm(str)) return true;\n        return false;\n    }\n}\n\nconst pah = new Segment('pah');\nconst jiz = new Segment('jiz');\nconst sek = new Segment('sek');\n\nconst opt1 = ['type'];\nconst opt2 = ['daizgiy', 'kana'];\nconst opt3 = ['blue', 'green', 'red'];\n\nconst segments = [\n    {\n        segment: pah,\n        options: opt1\n    },\n    {\n        segment: jiz,\n        options: opt2\n    },\n    {\n        segment: sek,\n        options: opt3\n    }\n];\n\nconst cli = new Client();\n\nfunction getSeqs(alphabet: string, str: string) {\n    if (alphabet == opt2[1]) {\n        const ta = cli.processKana(str);\n        return ta.blockSequences.filter(x => x.length > 0);\n    } else if (alphabet == opt2[0]) {\n        const ta = cli.processTonal(str);\n        return ta.word.syllables.flatMap(x => x.literal);\n    }\n    return [];\n}\n\nlet seqs: string[] = [];\nlet alphabet = '';\nlet fcolor = {};\n\nfunction CompositionPage() {\n    const [input, setInput] = useReducer((state: any, newState: any) => ({ ...state, ...newState }), {\n        scanned: '',\n        selected: '',\n        typed: ''\n    });\n\n    const handleChange = function(e: React.ChangeEvent<HTMLInputElement>) {\n        const name = e.target.name;\n        const value = e.target.value;\n        setInput({ [name]: value });\n    };\n\n    let segNo: number = -1;\n    let combiningSegNo: number = -1;\n    let optNo = -1;\n\n    const tl = new TonalLemmatizationAnalyzer();\n    const mphs = tl.morphAnalyze(input.scanned);\n    const len = mphs.length;\n\n    if (mphs) {\n        for (let i = 0; i < mphs.length; i++) {\n            if (mphs[i] && segments[i]) {\n                if (\n                    (i < segments.length - 1 && segments[i].segment.isProceedingForm(mphs[i].syllable.literal)) ||\n                    (i == segments.length - 1 && segments[i].segment.isBaseForm(mphs[i].syllable.literal))\n                ) {\n                    combiningSegNo = i;\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n\n    for (let i = 0; i < segments.length; i++) {\n        if (mphs && mphs[i] && segments[i]) {\n            if (segments[i].segment.includes(mphs[i].syllable.literal)) {\n                segNo = i;\n            }\n        }\n    }\n\n    const ti = new TonalInflector();\n    const lx1 = ti.inflect(segments[0].segment.literal, new TonalCombiningForms(), new TonalDesinenceInflection());\n    const lx2 = ti.inflect(segments[1].segment.literal, new TonalCombiningForms(), new TonalDesinenceInflection());\n    const candidates = [\n        lx1.word.literal,\n        lx1.getProceedingForms()[1].literal + lx2.word.literal,\n        lx1.getProceedingForms()[1].literal + lx2.getProceedingForms()[1] + segments[2].segment.literal\n    ];\n\n    let options: string[] = [];\n\n    if (segNo >= 0) {\n        if (combiningSegNo < segNo) {\n            options = segments[combiningSegNo + 1].options;\n            optNo = combiningSegNo + 1;\n        } else {\n            options = segments[segNo].options;\n            optNo = segNo;\n        }\n    }\n\n    if (opt2.filter(x => x.includes(input.selected)).length > 0) {\n        alphabet = input.selected;\n        seqs = getSeqs(alphabet, input.typed);\n    } else {\n        seqs = getSeqs(alphabet, input.typed);\n    }\n\n    if (opt3.filter(x => x.includes(input.selected)).length > 0) {\n        const str: string = input.selected;\n        fcolor = { color: str };\n    }\n\n    return (\n        <div>\n            <input type=\"text\" list=\"words\" value={input.scanned} name=\"scanned\" onChange={handleChange} />\n            <datalist id=\"words\">\n                {candidates.map(item => (\n                    <option key={item} value={item} />\n                ))}\n            </datalist>\n            <br />\n            <div>\n                {options.map((opt, i) => (\n                    <div key={i}>\n                        <input\n                            type=\"radio\"\n                            checked={input.selected === opt}\n                            name=\"selected\"\n                            onChange={handleChange}\n                            value={opt}\n                        />\n                        {opt}\n                    </div>\n                ))}\n            </div>\n            <div style={fcolor}>\n                {optNo > 0 ? <input type=\"text\" value={input.typed} name=\"typed\" onChange={handleChange} /> : null}\n                {optNo > 0 ? seqs.map(x => <li> {x} </li>) : null}\n            </div>\n        </div>\n    );\n}\n\nexport default CompositionPage;\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAEA;AACA;AAOA;;;AAGA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;;;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;;;AAEA;AACA;AACA;AACA;;;;;;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAFA;AAKA;AACA;AAFA;AAKA;AACA;AAFA;AAMA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAHA;AADA;AAAA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAaA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;;;;A","sourceRoot":""}