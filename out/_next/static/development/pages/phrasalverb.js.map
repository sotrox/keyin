{"version":3,"file":"static/development/pages/phrasalverb.js","sources":["webpack:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js","webpack:///delegated ./node_modules/react/index.js from dll-reference dll_ef0ff7c60362f24a921f","webpack:///./node_modules/taipa/lib/analyzer.js","webpack:///./node_modules/taipa/lib/character.js","webpack:///./node_modules/taipa/lib/client.js","webpack:///./node_modules/taipa/lib/document.js","webpack:///./node_modules/taipa/lib/dparser/analyzer.js","webpack:///./node_modules/taipa/lib/dparser/assimilator.js","webpack:///./node_modules/taipa/lib/dparser/configuration.js","webpack:///./node_modules/taipa/lib/dparser/creator.js","webpack:///./node_modules/taipa/lib/dparser/dictionary.js","webpack:///./node_modules/taipa/lib/dparser/guide.js","webpack:///./node_modules/taipa/lib/dparser/inflector.js","webpack:///./node_modules/taipa/lib/dparser/inserter.js","webpack:///./node_modules/taipa/lib/dparser/keywords.js","webpack:///./node_modules/taipa/lib/dparser/lexeme.js","webpack:///./node_modules/taipa/lib/dparser/morpheme.js","webpack:///./node_modules/taipa/lib/dparser/parser.js","webpack:///./node_modules/taipa/lib/dparser/phraseme.js","webpack:///./node_modules/taipa/lib/dparser/relation.js","webpack:///./node_modules/taipa/lib/dparser/rules.js","webpack:///./node_modules/taipa/lib/dparser/symbols.js","webpack:///./node_modules/taipa/lib/dparser/tagger.js","webpack:///./node_modules/taipa/lib/grapheme.js","webpack:///./node_modules/taipa/lib/index.js","webpack:///./node_modules/taipa/lib/kana/analyzer.js","webpack:///./node_modules/taipa/lib/kana/init.js","webpack:///./node_modules/taipa/lib/kana/kana.js","webpack:///./node_modules/taipa/lib/kana/morpheme.js","webpack:///./node_modules/taipa/lib/kana/soundgen.js","webpack:///./node_modules/taipa/lib/lexeme.js","webpack:///./node_modules/taipa/lib/morpheme.js","webpack:///./node_modules/taipa/lib/phraseme.js","webpack:///./node_modules/taipa/lib/token.js","webpack:///./node_modules/taipa/lib/tonal/analyzer.js","webpack:///./node_modules/taipa/lib/tonal/collections.js","webpack:///./node_modules/taipa/lib/tonal/init.js","webpack:///./node_modules/taipa/lib/tonal/lemmatizer.js","webpack:///./node_modules/taipa/lib/tonal/lexeme.js","webpack:///./node_modules/taipa/lib/tonal/lexicalroots2.js","webpack:///./node_modules/taipa/lib/tonal/matcher.js","webpack:///./node_modules/taipa/lib/tonal/morpheme.js","webpack:///./node_modules/taipa/lib/tonal/phraseme.js","webpack:///./node_modules/taipa/lib/tonal/prediction.js","webpack:///./node_modules/taipa/lib/tonal/soundgen.js","webpack:///./node_modules/taipa/lib/tonal/version2.js","webpack:///./pages/phrasalverb.tsx","webpack:///external \"dll_ef0ff7c60362f24a921f\""],"sourcesContent":["\n    (window.__NEXT_P=window.__NEXT_P||[]).push([\"/phrasalverb\", function() {\n      var mod = require(\"/Users/jslv/Projects/keyin/pages/phrasalverb.tsx\")\n      if(module.hot) {\n        module.hot.accept(\"/Users/jslv/Projects/keyin/pages/phrasalverb.tsx\", function() {\n          if(!next.router.components[\"/phrasalverb\"]) return\n          var updatedPage = require(\"/Users/jslv/Projects/keyin/pages/phrasalverb.tsx\")\n          next.router.update(\"/phrasalverb\", updatedPage)\n        })\n      }\n      return mod\n    }]);\n  ","module.exports = (__webpack_require__(/*! dll-reference dll_ef0ff7c60362f24a921f */ \"dll-reference dll_ef0ff7c60362f24a921f\"))(\"./node_modules/react/index.js\");","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Analyzer {\n}\nexports.Analyzer = Analyzer;\n//# sourceMappingURL=analyzer.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Character {\n    constructor(s) {\n        this.character = s;\n    }\n}\nexports.Character = Character;\nclass Characters {\n    constructor() {\n        this.carr = [\n            'a',\n            'b',\n            'c',\n            'd',\n            'e',\n            'f',\n            'g',\n            'h',\n            'i',\n            'j',\n            'k',\n            'l',\n            'm',\n            'n',\n            'o',\n            'p',\n            'q',\n            'r',\n            's',\n            't',\n            'u',\n            'v',\n            'w',\n            'x',\n            'y',\n            'z',\n        ];\n        this.o = new Map();\n        for (let e of this.carr) {\n            this.assign(e);\n        }\n    }\n    assign(e) {\n        this.o.set(e, new Character(e));\n    }\n    get(key) {\n        let value = this.o.get(key);\n        if (value) {\n            return value;\n        }\n        return new Character('');\n    }\n    get size() {\n        return this.o.size;\n    }\n}\nexports.characters = new Characters();\n//# sourceMappingURL=character.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst init_1 = require(\"./tonal/init\");\nconst analyzer_1 = require(\"./tonal/analyzer\");\nconst init_2 = require(\"./kana/init\");\nconst analyzer_2 = require(\"./kana/analyzer\");\nconst parser_1 = require(\"./dparser/parser\");\nconst tagger_1 = require(\"./dparser/tagger\");\nconst document_1 = require(\"./document\");\nconst token_1 = require(\"./token\");\nconst token_2 = require(\"./token\");\nconst pipe = (...fns) => (x) => fns.reduce((v, f) => f(v), x);\nclass Client {\n    processKana(str) {\n        init_2.checkLetterSizeKana();\n        // kana\n        let ta = new token_1.TokenAnalysis();\n        if (str) {\n            const ka = new analyzer_2.KanaLemmatizationAnalyzer();\n            const morphemes = ka.morphAnalyze(str);\n            ta.blockSequences = init_2.getKanaBlocks(morphemes);\n            for (let m of morphemes) {\n                ta.soundSequences.push(m.sounds);\n            }\n        }\n        return ta;\n    }\n    processTonal(str) {\n        init_1.checkLetterSizeTonal();\n        // tonal lurzmafjiz\n        let ta = new token_1.TokenAnalysis();\n        if (str) {\n            const tla = new analyzer_1.TonalLemmatizationAnalyzer();\n            const morphemes = tla.morphAnalyze(str);\n            const lexeme = tla.lexAnalyze(morphemes);\n            ta.word = lexeme.word;\n            ta.lemmas = lexeme.getLemmas();\n            ta.inflectionalEnding = lexeme.getInflectionalEnding();\n            for (let m of morphemes) {\n                ta.soundSequences.push(m.sounds);\n                // TODO: first free tone to fourth. first checked tone to eighth\n                ta.uncombiningSequences.push(m.getForms().map(it => it.literal));\n            }\n        }\n        return ta;\n    }\n    process(str) {\n        let doc = new document_1.Document();\n        if (str) {\n            // tokenization\n            const tokens = str.match(/\\w+/g);\n            if (tokens) {\n                tokens.filter(x => x != undefined).map(x => doc.tokens.push(new token_1.Token(x)));\n            }\n            // tagging\n            const tggr = new tagger_1.RuleBasedTagger();\n            // lemmatization\n            const lmtzr = new token_2.TokenLemmatizer();\n            // dependency parsing\n            const dpsr = new parser_1.DependencyParser();\n            doc = pipe(tggr.tag, lmtzr.getTonalLemmas, dpsr.parse)(doc);\n        }\n        return doc;\n    }\n}\nexports.Client = Client;\n//# sourceMappingURL=client.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Document {\n    constructor() {\n        this.relations = new Array(); // dependency\n        this.speeches = new Array();\n        this.tokens = new Array();\n    }\n}\nexports.Document = Document;\n//# sourceMappingURL=document.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst grapheme_1 = require(\"../grapheme\");\nconst analyzer_1 = require(\"../analyzer\");\nconst morpheme_1 = require(\"./morpheme\");\nconst version2_1 = require(\"../tonal/version2\");\nconst lexeme_1 = require(\"./lexeme\");\n//------------------------------------------------------------------------------\nclass TonalInflectionAnalyzer extends analyzer_1.Analyzer {\n    graphAnalyze(str) {\n        // graphemic analysis\n        const gm = new grapheme_1.GraphemeMaker(version2_1.lowerLettersTonal);\n        return gm.makeGraphemes(str);\n    }\n    morphAnalyze(x, metaplasm) {\n        // morphological analysis\n        let gs = [];\n        if (typeof x == 'object') {\n            gs = x;\n        }\n        else if (typeof x == 'string') {\n            gs = this.graphAnalyze(x);\n        }\n        const mm = new morpheme_1.TonalCombiningMorphemeMaker(metaplasm);\n        return mm.makeMorphemes(gs);\n    }\n    lexAnalyze(x, metaplasm) {\n        // lexical analysis\n        let ms = [];\n        if (typeof x == 'object') {\n            ms = x;\n        }\n        else if (typeof x == 'string') {\n            ms = this.morphAnalyze(x, new morpheme_1.TonalCombiningForms());\n        }\n        const lm = new lexeme_1.TonalInflectionLexemeMaker(metaplasm);\n        return lm.makeLexemes(ms);\n    }\n}\nexports.TonalInflectionAnalyzer = TonalInflectionAnalyzer;\n//# sourceMappingURL=analyzer.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst morpheme_1 = require(\"./morpheme\");\nconst grapheme_1 = require(\"../grapheme\");\nconst version2_1 = require(\"../tonal/version2\");\nconst lexeme_1 = require(\"../lexeme\");\nconst lexeme_2 = require(\"./lexeme\");\nconst phraseme_1 = require(\"./phraseme\");\nclass TonalAssimilator {\n    constructor() {\n        this.tschmm = new morpheme_1.TonalSoundChangingMorphemeMaker();\n        this.gm = new grapheme_1.GraphemeMaker(version2_1.lowerLettersTonal);\n    }\n    morphAnalyze(str) {\n        const gs = this.gm.makeGraphemes(str);\n        const mrphs = this.tschmm.makeMorphemes(gs);\n        return mrphs;\n    }\n    getLexeme(word) {\n        const mrphs = this.morphAnalyze(word);\n        const lx = new lexeme_2.TonalAssimilationLexeme(mrphs, new lexeme_1.TonalZeroInflection());\n        return lx;\n    }\n    assimilateAgressive(word) {\n        const mrphs = this.morphAnalyze(word);\n        const lx = new lexeme_2.TonalAssimilationLexeme(mrphs, new lexeme_2.AgressiveInternal());\n        return lx;\n    }\n    assimilateRegressive(word) {\n        const mrphs = this.morphAnalyze(word);\n        const lx = new lexeme_2.TonalAssimilationLexeme(mrphs, new lexeme_2.RegressiveInternal());\n        return lx;\n    }\n}\nexports.TonalAssimilator = TonalAssimilator;\nclass TonalPhrasalAssimilator {\n    constructor() {\n        this.assimi = new TonalAssimilator();\n        this.phmk = new phraseme_1.TonalAssimilationPhrasemeMaker();\n    }\n    assimilateAgressive(preceding, following) {\n        const lxPreceding = this.assimi.getLexeme(preceding);\n        const lxFollowing = this.assimi.getLexeme(following);\n        return this.phmk.makePhraseme(lxPreceding, lxFollowing, new phraseme_1.AgressiveExternal());\n    }\n    assimilateRegressive(preceding, following) {\n        const lxPreceding = this.assimi.getLexeme(preceding);\n        const lxFollowing = this.assimi.getLexeme(following);\n        return this.phmk.makePhraseme(lxPreceding, lxFollowing, new phraseme_1.RegressiveExternal());\n    }\n}\nexports.TonalPhrasalAssimilator = TonalPhrasalAssimilator;\n//# sourceMappingURL=assimilator.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Transition {\n}\nexports.Transition = Transition;\nclass Shift extends Transition {\n    do(c) {\n        let s = c.queue.shift();\n        if (s != undefined) {\n            c.stack.push(s);\n        }\n        return c;\n    }\n}\nexports.Shift = Shift;\nclass RightArc extends Transition {\n    do(c) {\n        c.stack.pop();\n        return c;\n    }\n}\nexports.RightArc = RightArc;\nclass LeftArc extends Transition {\n    do(c) {\n        const top = c.stack.pop();\n        c.stack.pop();\n        if (top)\n            c.stack.push(top);\n        return c;\n    }\n}\nexports.LeftArc = LeftArc;\nclass Configuration {\n    constructor() {\n        this.queue = new Array();\n        this.stack = new Array();\n        this.relations = new Array();\n    }\n    getGraph() {\n        return this.relations;\n    }\n    isTerminalConfiguration() {\n        if (this.queue.length > 0) {\n            return false;\n        }\n        if (this.stack.length == 1 && this.queue.length == 0) {\n            return true;\n        }\n        return false;\n    }\n}\nexports.Configuration = Configuration;\n//# sourceMappingURL=configuration.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst analyzer_1 = require(\"./analyzer\");\nconst phraseme_1 = require(\"../tonal/phraseme\");\nconst lexeme_1 = require(\"../lexeme\");\nconst phraseme_2 = require(\"./phraseme\");\nconst morpheme_1 = require(\"../morpheme\");\nconst lexeme_2 = require(\"./lexeme\");\nclass TonalCreator {\n    constructor() {\n        this.tia = new analyzer_1.TonalInflectionAnalyzer();\n        this.phm = new phraseme_2.TonalInflectionPhrasemeMaker();\n    }\n    createWord(str) {\n        return this.tia.lexAnalyze(str, new lexeme_1.TonalZeroInflection()).word;\n    }\n    createPhrase(str) {\n        const strs = str.match(/\\w+/g);\n        const lxs = strs ? strs.map(it => this.tia.lexAnalyze(it, new lexeme_1.TonalZeroInflection())) : [];\n        return new phraseme_1.TonalPhrase(lxs.map(it => it.word));\n    }\n    createLexeme(str, metaplasm) {\n        const ms = metaplasm\n            ? this.tia.morphAnalyze(str, metaplasm)\n            : this.tia.morphAnalyze(str, new morpheme_1.TonalZeroCombining());\n        const lx = this.tia.lexAnalyze(ms, new lexeme_2.TonalDesinenceInflection());\n        // if metaplasm is undefined, there will be no inflected forms\n        return lx;\n    }\n    createCompoundPhraseme(preceding, following, metaplasm) {\n        const lexemePreceding = metaplasm\n            ? this.tia.lexAnalyze(this.tia.morphAnalyze(preceding, metaplasm), new lexeme_2.TonalDesinenceInflection())\n            : this.tia.lexAnalyze(preceding, new lexeme_2.TonalDesinenceInflection());\n        const lexemeFollowing = this.createLexeme(following);\n        return this.phm.makeCompoundPhraseme(lexemePreceding, lexemeFollowing);\n    }\n}\nexports.TonalCreator = TonalCreator;\n//# sourceMappingURL=creator.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// prettier-ignore\nexports.dictOfVerbs = [\n    'koannw',\n    'pah',\n];\n// prettier-ignore\nexports.dictOfPhrasalVerbs = [\n    ['koannw', 'diurh'],\n    ['longw', 'diurh'],\n];\n// prettier-ignore\nexports.dictOfSeperateVVCompounds = {\n    siam: ['qoew'],\n};\n//# sourceMappingURL=dictionary.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst configuration_1 = require(\"./configuration\");\nconst symbols_1 = require(\"./symbols\");\nconst token_1 = require(\"../token\");\nclass Guide {\n    constructor() {\n        this.transitions = new Array();\n        this.s1 = new token_1.Token('');\n        this.s2 = new token_1.Token('');\n        this.b1 = new token_1.Token('');\n        this.s1B1Map = new Map()\n            .set(symbols_1.Tagset.VB + symbols_1.Tagset.PPV, new configuration_1.Shift())\n            .set(symbols_1.Tagset.NPR + symbols_1.Tagset.VB, new configuration_1.Shift())\n            .set(symbols_1.Tagset.NPR + symbols_1.Tagset.NPR, new configuration_1.Shift())\n            .set(symbols_1.Tagset.APPR + symbols_1.Tagset.NPR, new configuration_1.Shift())\n            .set(symbols_1.Tagset.VB + symbols_1.Tagset.NPR, new configuration_1.Shift())\n            .set(symbols_1.Tagset.VB + symbols_1.Tagset.AUXN, new configuration_1.Shift())\n            .set(symbols_1.Tagset.AUX + symbols_1.Tagset.VB, new configuration_1.Shift())\n            .set(symbols_1.Tagset.PADV + symbols_1.Tagset.VB, new configuration_1.Shift())\n            .set(symbols_1.Tagset.NPR + symbols_1.Tagset.PADV, new configuration_1.Shift())\n            .set(symbols_1.Tagset.VB + symbols_1.Tagset.APPR, new configuration_1.Shift())\n            .set(symbols_1.Tagset.VB + symbols_1.Tagset.PADV, new configuration_1.Shift())\n            .set(symbols_1.Tagset.NPR + symbols_1.Tagset.AUX, new configuration_1.Shift())\n            .set(symbols_1.Tagset.PPV + symbols_1.Tagset.AUXN, new configuration_1.RightArc())\n            .set(symbols_1.Tagset.PPV + symbols_1.Tagset.NPR, new configuration_1.RightArc());\n        this.s2S1Map = new Map()\n            .set(symbols_1.Tagset.VB + symbols_1.Tagset.PPV, new configuration_1.RightArc())\n            .set(symbols_1.Tagset.VB + symbols_1.Tagset.AUXN, new configuration_1.RightArc())\n            .set(symbols_1.Tagset.AUX + symbols_1.Tagset.VB, new configuration_1.LeftArc())\n            .set(symbols_1.Tagset.PADV + symbols_1.Tagset.VB, new configuration_1.LeftArc())\n            .set(symbols_1.Tagset.APPR + symbols_1.Tagset.NPR, new configuration_1.LeftArc())\n            .set(symbols_1.Tagset.VB + symbols_1.Tagset.VB, new configuration_1.RightArc())\n            .set(symbols_1.Tagset.VB + symbols_1.Tagset.NPR, new configuration_1.RightArc())\n            .set(symbols_1.Tagset.NPR + symbols_1.Tagset.VB, new configuration_1.LeftArc());\n    }\n    isQueueEmpty(c) {\n        if (c.queue.length === 0)\n            return true;\n        return false;\n    }\n    isStackEmpty(c) {\n        if (c.stack.length === 2)\n            return true;\n        return false;\n    }\n    getNextTransition(c) {\n        this.s1 = new token_1.Token('');\n        if (c.stack.length > 0)\n            this.s1 = c.stack[c.stack.length - 1];\n        this.s2 = new token_1.Token('');\n        if (c.stack.length > 1)\n            this.s2 = c.stack[c.stack.length - 2];\n        this.b1 = new token_1.Token('');\n        if (c.queue.length > 0)\n            this.b1 = c.queue[0];\n        if (this.s1.tag != '' && this.b1.tag != '') {\n            if (this.s1B1Map.has(this.s1.tag + this.b1.tag)) {\n                const tran = this.s1B1Map.get(this.s1.tag + this.b1.tag);\n                if (tran) {\n                    this.transitions.push(tran);\n                }\n            }\n        }\n        else if (this.isQueueEmpty(c)) {\n            if (this.s2S1Map.has(this.s2.tag + this.s1.tag)) {\n                const tran = this.s2S1Map.get(this.s2.tag + this.s1.tag);\n                if (tran) {\n                    this.transitions.push(tran);\n                }\n            }\n            else if (this.isStackEmpty(c)) {\n                this.transitions.push(new configuration_1.RightArc());\n            }\n        }\n        if (this.transitions.length == 0)\n            return undefined;\n        return this.transitions.shift();\n    }\n}\nexports.Guide = Guide;\n//# sourceMappingURL=guide.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst analyzer_1 = require(\"./analyzer\");\nconst morpheme_1 = require(\"./morpheme\");\nconst lexeme_1 = require(\"./lexeme\");\nconst phraseme_1 = require(\"./phraseme\");\nconst creator_1 = require(\"./creator\");\nclass TonalInflector {\n    constructor() {\n        this.tia = new analyzer_1.TonalInflectionAnalyzer();\n    }\n    inflectDesinence(word) {\n        const ms = this.tia.morphAnalyze(word, new morpheme_1.TonalCombiningForms());\n        const lx = this.tia.lexAnalyze(ms, new lexeme_1.TonalDesinenceInflection());\n        return lx;\n    }\n    inflectTransfix(word) {\n        const ms = this.tia.morphAnalyze(word, new morpheme_1.ThirdCombiningForm());\n        const lx = this.tia.lexAnalyze(ms, new lexeme_1.TransfixInflection());\n        return lx;\n    }\n    inflectEncliticE(word) {\n        const ms = this.tia.morphAnalyze(word, new morpheme_1.EncliticECombining());\n        const lx = this.tia.lexAnalyze(ms, new lexeme_1.TonalDesinenceInflection());\n        return lx;\n    }\n    inflectPhrasalVerbParticle(word) {\n        const ms = this.tia.morphAnalyze(word, new morpheme_1.PhrasalVerbParticleCombining());\n        const lx = this.tia.lexAnalyze(ms, new lexeme_1.TonalDesinenceInflection());\n        return lx;\n    }\n    inflectConjunctiveLe(word) {\n        const ms = this.tia.morphAnalyze(word, new morpheme_1.ConjunctiveLeCombining());\n        const lx = this.tia.lexAnalyze(ms, new lexeme_1.TonalDesinenceInflection());\n        return lx;\n    }\n    inflectPossesiveEx(word) {\n        const ms = this.tia.morphAnalyze(word, new morpheme_1.PossesiveExCombining());\n        const lx = this.tia.lexAnalyze(ms, new lexeme_1.TonalDesinenceInflection());\n        return lx;\n    }\n    inflectTo(word, tone) {\n        const ms = this.tia.morphAnalyze(word, new morpheme_1.NthCombining(tone));\n        const lx = this.tia.lexAnalyze(ms, new lexeme_1.TonalDesinenceInflection());\n        return lx;\n    }\n}\nexports.TonalInflector = TonalInflector;\nclass TonalPhrasalInflector {\n    constructor() {\n        this.infl = new TonalInflector();\n        this.phm = new phraseme_1.TonalInflectionPhrasemeMaker();\n        this.crt = new creator_1.TonalCreator();\n    }\n    inflectToProceeding(verb, particle, particleTwo) {\n        // need to inflect to first tone. tonal f is appended to particle.\n        const lexemeVerb = this.infl.inflectDesinence(verb);\n        const lexemeParticle = this.infl.inflectPhrasalVerbParticle(particle);\n        const lexemeParticleTwo = particleTwo ? this.infl.inflectPhrasalVerbParticle(particleTwo) : undefined;\n        if (lexemeParticleTwo) {\n            return this.phm.makePhrasalVerbTwoPhraseme(lexemeVerb, lexemeParticle, lexemeParticleTwo);\n        }\n        else {\n            return this.phm.makePhrasalVerbPhraseme(lexemeVerb, lexemeParticle);\n        }\n    }\n    inflectEToAdnominal(adjectivalNoun, e) {\n        const lexemeAdjective = this.crt.createLexeme(adjectivalNoun);\n        const lexemeE = this.infl.inflectEncliticE(e);\n        return this.phm.makeAdjectivePhraseme(lexemeAdjective, lexemeE);\n    }\n    inflectToConjunctive(verb, le) {\n        const lexemeVerb = this.infl.inflectDesinence(verb);\n        const lexemeLe = this.infl.inflectConjunctiveLe(le);\n        return this.phm.makeConjunctivePhraseme(lexemeVerb, lexemeLe);\n    }\n    inflectPossesive(noun, ex) {\n        const lexemeNoun = this.crt.createLexeme(noun);\n        const lexemeEx = this.infl.inflectPossesiveEx(ex);\n        return this.phm.makePossesivePhraseme(lexemeNoun, lexemeEx);\n    }\n    inflectToParticiple(verb, particle, tone) {\n        // inflect to first tone or seventh\n        const lexemeVerb = this.infl.inflectTo(verb, tone);\n        const lexemeParticle = this.infl.inflectTo(particle, tone);\n        return this.phm.makeParticiplePhraseme(lexemeVerb, lexemeParticle);\n    }\n    inflectSerial(...words) {\n        const lexemes = words.map(it => this.infl.inflectDesinence(it));\n        return this.phm.makeSerialPhraseme(lexemes);\n    }\n}\nexports.TonalPhrasalInflector = TonalPhrasalInflector;\n//# sourceMappingURL=inflector.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst grapheme_1 = require(\"../grapheme\");\nconst version2_1 = require(\"../tonal/version2\");\nconst morpheme_1 = require(\"./morpheme\");\nconst lexeme_1 = require(\"./lexeme\");\nclass TonalInserter {\n    constructor() {\n        this.tschmm = new morpheme_1.TonalSoundChangingMorphemeMaker();\n        this.gm = new grapheme_1.GraphemeMaker(version2_1.lowerLettersTonal);\n    }\n    morphAnalyze(str) {\n        const gs = this.gm.makeGraphemes(str);\n        const mrphs = this.tschmm.makeMorphemes(gs);\n        return mrphs;\n    }\n    insert(str) {\n        const mrphs = this.morphAnalyze(str);\n        const lx = new lexeme_1.TonalAssimilationLexeme(mrphs, new lexeme_1.Epenthesis());\n        return lx;\n    }\n}\nexports.TonalInserter = TonalInserter;\n//# sourceMappingURL=inserter.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst symbols_1 = require(\"./symbols\");\nclass ConstructionElement {\n    constructor() {\n        this.surface = '';\n        this.pos = '';\n        this.tag = '';\n    }\n}\nexports.ConstructionElement = ConstructionElement;\nclass PersonalPronounSurface extends ConstructionElement {\n    constructor(str) {\n        super();\n        this.surface = str;\n        this.pos = symbols_1.POSTags.pronoun;\n    }\n}\nexports.PersonalPronounSurface = PersonalPronounSurface;\nclass VerbSurface extends ConstructionElement {\n    constructor(str) {\n        super();\n        this.surface = str;\n        this.pos = symbols_1.POSTags.verb;\n    }\n}\nexports.VerbSurface = VerbSurface;\nclass EncliticSurface extends ConstructionElement {\n    constructor(str) {\n        super();\n        this.pos = symbols_1.POSTags.auxiliary;\n        this.surface = str;\n    }\n}\nexports.EncliticSurface = EncliticSurface;\nclass PronounSurface extends ConstructionElement {\n    constructor(str) {\n        super();\n        this.pos = symbols_1.POSTags.pronoun;\n        this.surface = str;\n    }\n}\nexports.PronounSurface = PronounSurface;\nclass NounSurface extends ConstructionElement {\n    constructor() {\n        super();\n        this.pos = symbols_1.POSTags.noun;\n    }\n}\nclass ParticleSurface extends ConstructionElement {\n    constructor(str) {\n        super();\n        this.pos = symbols_1.POSTags.particle;\n        this.surface = str;\n    }\n}\nexports.ParticleSurface = ParticleSurface;\nclass PrepositionSurface extends ConstructionElement {\n    constructor(str) {\n        super();\n        this.pos = symbols_1.POSTags.adposition;\n        this.surface = str;\n    }\n}\nexports.PrepositionSurface = PrepositionSurface;\nclass CaseMarker {\n}\nclass AuxiliarySurface extends ConstructionElement {\n    constructor(str) {\n        super();\n        this.pos = symbols_1.POSTags.auxiliary;\n        this.surface = str;\n    }\n}\nexports.AuxiliarySurface = AuxiliarySurface;\nconst objectFactory = function (name, str) {\n    const set = new Set()\n        .add(PronounSurface)\n        .add(ParticleSurface)\n        .add(AuxiliarySurface)\n        .add(PersonalPronounSurface);\n    const createInstance = function (c, str) {\n        return new c(str);\n    };\n    if (set.has(name)) {\n        return createInstance(name, str);\n    }\n};\nclass KeyWords {\n    constructor() {\n        this.keyElems = new Array();\n        this.populateKeyElems();\n    }\n    getSurface(str) {\n        for (let i in this.keyElems)\n            if (this.keyElems[i].surface === str)\n                return this.keyElems[i];\n    }\n    populateKeyElems() {\n        this.keyElems = [\n            objectFactory(PronounSurface, 'che'),\n            objectFactory(PersonalPronounSurface, 'goa'),\n            objectFactory(AuxiliarySurface, 'qaz'),\n            objectFactory(ParticleSurface, 'long'),\n            objectFactory(ParticleSurface, 'bew')\n        ];\n    }\n}\nexports.KeyWords = KeyWords;\n//# sourceMappingURL=keywords.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst lexeme_1 = require(\"../lexeme\");\nconst morpheme_1 = require(\"./morpheme\");\nconst lexeme_2 = require(\"../tonal/lexeme\");\nconst version2_1 = require(\"../tonal/version2\");\nconst morpheme_2 = require(\"../tonal/morpheme\");\nconst grapheme_1 = require(\"../grapheme\");\n//------------------------------------------------------------------------------\nclass TonalDesinenceInflection extends lexeme_1.TonalInflectionMetaplasm {\n    apply(ms) {\n        if (ms.length > 0 && ms[ms.length - 1]) {\n            const last = ms[ms.length - 1];\n            const syls = last.getForms();\n            let rets = [];\n            if (syls) {\n                for (let i in syls) {\n                    let wd = new lexeme_2.TonalWord(ms.map(x => new morpheme_2.TonalSyllable(x.syllable.letters)));\n                    wd.popSyllable();\n                    wd.pushSyllable(syls[i]);\n                    rets.push(wd);\n                }\n            }\n            return rets;\n        }\n        return [];\n    }\n}\nexports.TonalDesinenceInflection = TonalDesinenceInflection;\n//------------------------------------------------------------------------------\nclass TransfixInflection extends lexeme_1.TonalInflectionMetaplasm {\n    apply(ms) {\n        const rets = [];\n        if (ms.length > 0) {\n            const tw = new lexeme_2.TonalWord(ms.map(x => new morpheme_2.TonalSyllable(x.syllable.letters)));\n            for (let i = 0; i < ms.length; i++) {\n                const form = ms[i].getForms()[0];\n                if (form)\n                    tw.replaceSyllable(i, form);\n            }\n            rets.push(tw);\n        }\n        return rets;\n    }\n}\nexports.TransfixInflection = TransfixInflection;\n//------------------------------------------------------------------------------\nclass RegressiveInternal extends lexeme_1.TonalAssimilationMetaplasm {\n    apply(ms) {\n        let tw = new lexeme_2.TonalWord(ms.map(x => new morpheme_2.TonalSyllable(x.syllable.letters)));\n        if (ms.length > 1) {\n            for (let i = 1; i < ms.length; i++) {\n                if (ms[i].sounds[0].name === version2_1.TonalSoundTags.initial &&\n                    (ms[i - 1].syllable.lastSecondLetter.literal === version2_1.TonalLetterTags.t ||\n                        ms[i - 1].syllable.lastSecondLetter.literal === version2_1.TonalLetterTags.tt)) {\n                    tw.replaceSyllable(i - 1, ms[i - 1].changeSoundWith(ms[i].sounds[0], morpheme_1.AssimiDirection.regressive)[0]);\n                }\n                else {\n                    const syls = ms[i - 1].changeSoundWith(ms[i].sounds[0], morpheme_1.AssimiDirection.regressive);\n                    if (syls.length)\n                        tw.replaceSyllable(i - 1, syls[0]);\n                }\n            }\n        }\n        return [tw];\n    }\n}\nexports.RegressiveInternal = RegressiveInternal;\n//------------------------------------------------------------------------------\nclass AgressiveInternal extends lexeme_1.TonalAssimilationMetaplasm {\n    apply(ms) {\n        if (ms.length > 1 && ms[ms.length - 2]) {\n            const snds = ms[ms.length - 2].sounds;\n            let wrd = new lexeme_2.TonalWord(ms.map(x => new morpheme_2.TonalSyllable(x.syllable.letters)));\n            if (snds.filter(x => x.name === version2_1.TonalSoundTags.nasalization).length == 1) {\n                // nasalization of vowels\n                wrd.replaceSyllable(wrd.syllables.length - 1, ms[ms.length - 1].changeSoundWith(new version2_1.NasalizationSound().sounds[0], morpheme_1.AssimiDirection.agressive)[0]);\n                return [wrd];\n            }\n            // duplifix. pass the preceding initial to get forms\n            wrd.replaceSyllable(wrd.syllables.length - 1, ms[ms.length - 1].changeSoundWith(snds[0], morpheme_1.AssimiDirection.agressive)[0]);\n            return [wrd];\n        }\n        return [];\n    }\n}\nexports.AgressiveInternal = AgressiveInternal;\n//------------------------------------------------------------------------------\nclass Epenthesis extends lexeme_1.TonalAssimilationMetaplasm {\n    // adding of nasal consonants. insertion\n    apply(ms) {\n        if (ms.length > 1 && ms[ms.length - 2]) {\n            const snds = ms[ms.length - 2].sounds;\n            let wrd = new lexeme_2.TonalWord(ms.map(x => new morpheme_2.TonalSyllable(x.syllable.letters)));\n            if (snds[snds.length - 2].name == version2_1.TonalSoundTags.nasalFinal &&\n                ms[ms.length - 1].syllable.letters[0].literal === version2_1.TonalLetterTags.a) {\n                // m, n, ng followed by -ay. pass the preceding nasal to get forms\n                wrd.replaceSyllable(wrd.syllables.length - 1, ms[ms.length - 1].changeSoundWith(snds[snds.length - 2], morpheme_1.AssimiDirection.agressive)[0]);\n                return [wrd];\n            }\n        }\n        return [];\n    }\n}\nexports.Epenthesis = Epenthesis;\n//------------------------------------------------------------------------------\nclass TonalInflectionLexeme extends lexeme_1.Lexeme {\n    // TODO: should a member variable affixes be added and passed to metaplasm. check out member sounds in morpheme\n    constructor(morphemes, metaplasm) {\n        super();\n        this.forms = new Array();\n        if (morphemes.length == 0)\n            this.word = new lexeme_2.TonalWord([]);\n        else\n            this.word = new lexeme_2.TonalWord(morphemes.map(x => x.syllable));\n        if (morphemes.length > 0) {\n            if (morphemes[morphemes.length - 1]) {\n                // tonal ending needs to be assigned to sandhi lexeme\n                this.tonalSymbleEnding = this.assignTonalEnding(morphemes[morphemes.length - 1].allomorph);\n            }\n            else {\n                this.tonalSymbleEnding = new lexeme_2.TonalSymbolEnding();\n            }\n        }\n        else {\n            this.tonalSymbleEnding = new lexeme_2.TonalSymbolEnding();\n        }\n        if (morphemes.length > 0)\n            this.forms = this.assignWordForms(morphemes, metaplasm);\n    }\n    assignTonalEnding(allomorph) {\n        let tse = new lexeme_2.TonalSymbolEnding();\n        if (allomorph instanceof version2_1.FreeAllomorph) {\n            // replace the tonal ending\n            let fte = new lexeme_2.FreeTonalEnding();\n            fte.allomorph = allomorph;\n            tse = fte;\n        }\n        else if (allomorph instanceof version2_1.CheckedAllomorph) {\n            // append the tonal of the tonal ending\n            let cte = new lexeme_2.CheckedTonalEnding();\n            cte.allomorph = allomorph;\n            tse = cte;\n        }\n        return tse;\n    }\n    getInflectionalEnding() {\n        if (this.tonalSymbleEnding)\n            return this.tonalSymbleEnding.allomorph.tonal.toString();\n        return '';\n    }\n    assignWordForms(ms, ti) {\n        return ti.apply(ms);\n    }\n    getForms() {\n        return this.forms;\n    }\n}\nexports.TonalInflectionLexeme = TonalInflectionLexeme;\n//------------------------------------------------------------------------------\nclass TonalAssimilationLexeme extends lexeme_1.Lexeme {\n    constructor(morphemes, metaplasm) {\n        super();\n        this.morphemes = morphemes;\n        this.forms = new Array();\n        if (morphemes.length == 0)\n            this.word = new lexeme_2.TonalWord([]);\n        else\n            this.word = new lexeme_2.TonalWord(morphemes.map(x => x.syllable));\n        if (morphemes.length > 0)\n            this.forms = metaplasm.apply(morphemes);\n    }\n    getForms() {\n        // for internal samdhi\n        return this.forms;\n    }\n    getMorphemes() {\n        // when external sandhi is required, member variable morphemes has to be exposed\n        return this.morphemes;\n    }\n    assimilateWith(til, dir) {\n        const ms = til.getMorphemes();\n        let wrd = new lexeme_2.TonalWord(this.morphemes.map(x => new morpheme_2.TonalSyllable(x.syllable.letters)));\n        if (ms.length > 0) {\n            const adjacentSnds = ms[ms.length - 1].sounds;\n            if (dir === morpheme_1.AssimiDirection.agressive) {\n                let s = new grapheme_1.Sound();\n                if (adjacentSnds[adjacentSnds.length - 1].name === version2_1.TonalSoundTags.freeTonal &&\n                    adjacentSnds[adjacentSnds.length - 2].name === version2_1.TonalSoundTags.nasalFinal) {\n                    s = adjacentSnds[adjacentSnds.length - 2];\n                }\n                else if (adjacentSnds[adjacentSnds.length - 1].name === version2_1.TonalSoundTags.nasalFinal) {\n                    s = adjacentSnds[adjacentSnds.length - 1];\n                }\n                const syls = this.morphemes[0].changeSoundWith(s, morpheme_1.AssimiDirection.agressive);\n                wrd.replaceSyllable(0, syls[0]);\n                return [wrd];\n            }\n            else if (dir === morpheme_1.AssimiDirection.regressive && adjacentSnds[0].name === version2_1.TonalSoundTags.initial) {\n                const s = adjacentSnds[0];\n                const syls = this.morphemes[this.morphemes.length - 1].changeSoundWith(s, morpheme_1.AssimiDirection.regressive);\n                wrd.popSyllable();\n                wrd.pushSyllable(syls[0]);\n                return [wrd];\n            }\n        }\n        return [];\n    }\n}\nexports.TonalAssimilationLexeme = TonalAssimilationLexeme;\n//------------------------------------------------------------------------------\nclass TonalInflectionLexemeMaker extends lexeme_1.LexemeMaker {\n    constructor(tim) {\n        super();\n        this.tim = tim;\n    }\n    makeLexemes(ms) {\n        return this.make(ms);\n    }\n    make(ms) {\n        let isInflStemWithX = false; // inflectional stem with x in the middle\n        if (ms) {\n            isInflStemWithX = this.checkFifth(ms);\n            if (isInflStemWithX)\n                return new TonalInflectionLexeme([], this.tim);\n        }\n        return new TonalInflectionLexeme(ms, this.tim);\n    }\n    checkFifth(ms) {\n        for (let i = 0; i < ms.length; i++) {\n            if (ms[i] && ms[i].syllable.lastLetter.literal === version2_1.TonalLetterTags.x) {\n                if (i < ms.length - 1 &&\n                    ms[ms.length - 1].syllable.lastLetter.literal !== version2_1.TonalLetterTags.y &&\n                    ms[ms.length - 1].syllable.lastSecondLetter.literal !== version2_1.TonalLetterTags.a) {\n                    if (ms[ms.length - 1].syllable.lastLetter.literal === version2_1.TonalLetterTags.a) {\n                        break;\n                    }\n                    else {\n                        // tonal x can't not appear in them middle of an inflectional stem\n                        // if it is not preceding an ay or a\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}\nexports.TonalInflectionLexemeMaker = TonalInflectionLexemeMaker;\n//# sourceMappingURL=lexeme.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst morpheme_1 = require(\"../morpheme\");\nconst morpheme_2 = require(\"../tonal/morpheme\");\nconst version2_1 = require(\"../tonal/version2\");\nconst grapheme_1 = require(\"../grapheme\");\nconst collections_1 = require(\"../tonal/collections\");\nvar AssimiDirection;\n(function (AssimiDirection) {\n    AssimiDirection[AssimiDirection[\"agressive\"] = 0] = \"agressive\";\n    AssimiDirection[AssimiDirection[\"regressive\"] = 1] = \"regressive\";\n})(AssimiDirection = exports.AssimiDirection || (exports.AssimiDirection = {}));\n//------------------------------------------------------------------------------\nclass TonalCombiningForms extends morpheme_1.TonalCombiningMetaplasm {\n    apply(sounds, allomorph) {\n        if (allomorph) {\n            let s = new morpheme_2.TonalSyllable(sounds.map(x => new grapheme_1.AlphabeticLetter(x.characters)));\n            if (allomorph instanceof version2_1.FreeAllomorph) {\n                if (allomorph instanceof version2_1.ZeroAllomorph) {\n                    const tos = collections_1.combiningRules.get(version2_1.TonalLetterTags.zero);\n                    if (tos) {\n                        s.pushLetter(new grapheme_1.AlphabeticLetter(version2_1.lowerLettersTonal.get(tos[0]).characters));\n                    }\n                    return [s];\n                }\n                else if (allomorph instanceof version2_1.AllomorphY) {\n                    s.popLetter();\n                    return [s];\n                }\n                else {\n                    s.popLetter();\n                    const tos = collections_1.combiningRules.get(allomorph.tonal.toString());\n                    const rets = [];\n                    if (tos) {\n                        for (let k = 0; k < tos.length; k++) {\n                            s.pushLetter(new grapheme_1.AlphabeticLetter(version2_1.lowerLettersTonal.get(tos[k]).characters));\n                            rets.push(new morpheme_2.TonalSyllable(s.letters));\n                            s.popLetter();\n                        }\n                    }\n                    return rets;\n                }\n            }\n            else if (allomorph instanceof version2_1.CheckedAllomorph) {\n                // nothing to pop here\n                if (allomorph.tonal.toString().length > 0)\n                    return [];\n                const tos = collections_1.combiningRules.get(allomorph.final.toString());\n                const rets = [];\n                if (tos) {\n                    for (let k = 0; k < tos.length; k++) {\n                        s.pushLetter(new grapheme_1.AlphabeticLetter(version2_1.lowerLettersTonal.get(tos[k]).characters));\n                        rets.push(new morpheme_2.TonalSyllable(s.letters));\n                        s.popLetter();\n                    }\n                }\n                return rets;\n            }\n        }\n        return [];\n    }\n}\nexports.TonalCombiningForms = TonalCombiningForms;\n//------------------------------------------------------------------------------\nclass ThirdCombiningForm extends morpheme_1.TonalCombiningMetaplasm {\n    apply(sounds, allomorph) {\n        if (allomorph) {\n            let s = new morpheme_2.TonalSyllable(sounds.map(x => new grapheme_1.AlphabeticLetter(x.characters)));\n            const ps = version2_1.tonalPositionalSounds.get(version2_1.TonalLetterTags.w);\n            let snd = new grapheme_1.Sound();\n            if (allomorph instanceof version2_1.FreeAllomorph) {\n                if (ps)\n                    snd = ps(version2_1.TonalSoundTags.freeTonal);\n                if (allomorph instanceof version2_1.ZeroAllomorph) {\n                    s.pushLetter(new grapheme_1.AlphabeticLetter(snd.characters));\n                }\n                else {\n                    s.popLetter();\n                    s.pushLetter(new grapheme_1.AlphabeticLetter(snd.characters));\n                }\n            }\n            else if (allomorph instanceof version2_1.CheckedAllomorph) {\n                if (ps)\n                    snd = ps(version2_1.TonalSoundTags.checkedTonal);\n                if (allomorph.tonal.toString()) {\n                    s.popLetter();\n                    s.pushLetter(new grapheme_1.AlphabeticLetter(snd.characters));\n                }\n                else {\n                    s.pushLetter(new grapheme_1.AlphabeticLetter(snd.characters));\n                }\n            }\n            return [s];\n        }\n        return [];\n    }\n}\nexports.ThirdCombiningForm = ThirdCombiningForm;\n//------------------------------------------------------------------------------\nclass FourthToFirstCombining extends morpheme_1.TonalCombiningMetaplasm {\n    apply(sounds, allomorph) {\n        if (allomorph && allomorph instanceof version2_1.AllomorphH) {\n            let s = new morpheme_2.TonalSyllable(sounds.map(x => new grapheme_1.AlphabeticLetter(x.characters)));\n            s.pushLetter(new grapheme_1.AlphabeticLetter(version2_1.lowerLettersTonal.get(version2_1.TonalLetterTags.f).characters));\n            return [new morpheme_2.TonalSyllable(s.letters)];\n        }\n        return [];\n    }\n}\nexports.FourthToFirstCombining = FourthToFirstCombining;\n//------------------------------------------------------------------------------\nclass EighthToFirstCombining extends morpheme_1.TonalCombiningMetaplasm {\n    apply(sounds, allomorph) {\n        if (allomorph && allomorph instanceof version2_1.CheckedAllomorph) {\n            let s = new morpheme_2.TonalSyllable(sounds.map(x => new grapheme_1.AlphabeticLetter(x.characters)));\n            const tnl = collections_1.eighthToFirst.get(allomorph.toString());\n            if (tnl) {\n                s.popLetter();\n                s.pushLetter(new grapheme_1.AlphabeticLetter(version2_1.lowerLettersTonal.get(tnl).characters));\n                s.pushLetter(new grapheme_1.AlphabeticLetter(version2_1.lowerLettersTonal.get(version2_1.TonalLetterTags.f).characters));\n            }\n            return [new morpheme_2.TonalSyllable(s.letters)];\n        }\n        return [];\n    }\n}\nexports.EighthToFirstCombining = EighthToFirstCombining;\n//------------------------------------------------------------------------------\nclass EncliticECombining extends morpheme_1.TonalCombiningMetaplasm {\n    apply(sounds, allomorph) {\n        // 1->7, 7->7, 3->3\n        if (allomorph) {\n            let s = new morpheme_2.TonalSyllable(sounds.map(x => new grapheme_1.AlphabeticLetter(x.characters)));\n            if (allomorph instanceof version2_1.FreeAllomorph) {\n                if (allomorph instanceof version2_1.ZeroAllomorph) {\n                    const tos = collections_1.combiningRules.get(version2_1.TonalLetterTags.zero);\n                    if (tos) {\n                        // it should loop only once\n                        s.pushLetter(new grapheme_1.AlphabeticLetter(version2_1.lowerLettersTonal.get(tos[0]).characters));\n                    }\n                    return [s];\n                }\n            }\n        }\n        return [];\n    }\n}\nexports.EncliticECombining = EncliticECombining;\n//------------------------------------------------------------------------------\nclass PhrasalVerbParticleCombining extends morpheme_1.TonalCombiningMetaplasm {\n    diurh(syllable) {\n        let rets = [];\n        let s = new morpheme_2.TonalSyllable(syllable.letters);\n        s.popLetter();\n        s.pushLetter(version2_1.lowerLettersTonal.get(version2_1.TonalLetterTags.hh));\n        s.pushLetter(version2_1.lowerLettersTonal.get(version2_1.TonalLetterTags.w));\n        rets.push(new morpheme_2.TonalSyllable(s.letters));\n        return rets;\n    }\n    apply(sounds, allomorph) {\n        if (allomorph) {\n            let s = new morpheme_2.TonalSyllable(sounds.map(x => new grapheme_1.AlphabeticLetter(x.characters)));\n            if (allomorph instanceof version2_1.CheckedAllomorph) {\n                if (s.literal === 'diurh')\n                    return [];\n                // f only\n                const ret = [];\n                // ~hf\n                s.pushLetter(new grapheme_1.AlphabeticLetter(version2_1.lowerLettersTonal.get(version2_1.TonalLetterTags.f).characters));\n                ret.push(new morpheme_2.TonalSyllable(s.letters));\n                // free form of the syllable could be handle outside of this routine by popping f and h\n                return ret;\n            }\n        }\n        return [];\n    }\n}\nexports.PhrasalVerbParticleCombining = PhrasalVerbParticleCombining;\n//------------------------------------------------------------------------------\nclass ConjunctiveLeCombining extends morpheme_1.TonalCombiningMetaplasm {\n    apply(sounds, allomorph) {\n        if (allomorph) {\n            let s = new morpheme_2.TonalSyllable(sounds.map(x => new grapheme_1.AlphabeticLetter(x.characters)));\n            if (allomorph instanceof version2_1.FreeAllomorph) {\n                if (allomorph.tonal.toString() === version2_1.TonalLetterTags.z ||\n                    allomorph.tonal.toString() === version2_1.TonalLetterTags.w) {\n                    s.popLetter();\n                    return [new morpheme_2.TonalSyllable(s.letters)];\n                }\n            }\n        }\n        return [];\n    }\n}\nexports.ConjunctiveLeCombining = ConjunctiveLeCombining;\n//------------------------------------------------------------------------------\nclass PossesiveExCombining extends morpheme_1.TonalCombiningMetaplasm {\n    apply(sounds, allomorph) {\n        if (allomorph) {\n            let s = new morpheme_2.TonalSyllable(sounds.map(x => new grapheme_1.AlphabeticLetter(x.characters)));\n            s.popLetter();\n            s.pushLetter(new grapheme_1.AlphabeticLetter(version2_1.lowerLettersTonal.get(version2_1.TonalLetterTags.w).characters));\n            return [new morpheme_2.TonalSyllable(s.letters)];\n        }\n        return [];\n    }\n}\nexports.PossesiveExCombining = PossesiveExCombining;\n//------------------------------------------------------------------------------\nclass NthCombining extends morpheme_1.TonalCombiningMetaplasm {\n    constructor(tone) {\n        super();\n        this.tone = tone;\n    }\n    apply(sounds, allomorph) {\n        // from -h to 1 or 7\n        if (allomorph) {\n            let s = new morpheme_2.TonalSyllable(sounds.map(x => new grapheme_1.AlphabeticLetter(x.characters)));\n            if (s.lastLetter.literal === version2_1.TonalLetterTags.h) {\n                s.popLetter();\n            }\n            if (this.tone === version2_1.TonalLetterTags.z) {\n                s.pushLetter(new grapheme_1.AlphabeticLetter(version2_1.lowerLettersTonal.get(version2_1.TonalLetterTags.z).characters));\n            }\n            return [new morpheme_2.TonalSyllable(s.letters)];\n        }\n        return [];\n    }\n}\nexports.NthCombining = NthCombining;\n//------------------------------------------------------------------------------\nclass TonalCombiningMorpheme extends morpheme_1.Morpheme {\n    constructor(syllable, sounds, metaplasm) {\n        super();\n        this.syllable = syllable;\n        this.metaplasm = metaplasm;\n        // assign allomorph for each syllable\n        this.allomorph = this.assignAllomorph(this.syllable);\n        this.sounds = sounds;\n        this.forms = this.metaplasm.apply(this.sounds, this.allomorph);\n    }\n    getForms() {\n        return this.forms;\n    }\n    assignAllomorph(syllable) {\n        if (version2_1.uncombinedCheckedAllomorphs.has(syllable.lastLetter.literal)) {\n            const am = version2_1.uncombinedCheckedAllomorphs.get(syllable.lastLetter.literal);\n            if (am)\n                return am;\n            return new version2_1.Allomorph();\n        }\n        if (new version2_1.CheckedTonalSounds().includes(syllable.lastLetter.literal) &&\n            version2_1.uncombinedCheckedAllomorphs.has(syllable.lastSecondLetter.literal)) {\n            // in case of final followed by tonal\n            const ams = version2_1.combinedCheckedAllomorphs.get(syllable.lastSecondLetter.literal);\n            if (ams && ams.length > 1) {\n                const it = ams.filter(x => x.tonal.toString() === syllable.lastLetter.literal);\n                return it[0];\n            }\n            // return alms[0];\n            return new version2_1.Allomorph();\n        }\n        if (version2_1.combinedFreeAllomorphs.has(syllable.lastLetter.literal)) {\n            const am = version2_1.combinedFreeAllomorphs.get(syllable.lastLetter.literal);\n            if (am)\n                return am;\n            return new version2_1.Allomorph(); // return empty allomorph\n        }\n        return new version2_1.ZeroAllomorph();\n    }\n}\nexports.TonalCombiningMorpheme = TonalCombiningMorpheme;\nclass TonalSoundChangingMorpheme extends morpheme_1.Morpheme {\n    constructor(syllable, sounds) {\n        super();\n        this.syllable = syllable;\n        this.sounds = sounds;\n    }\n    changeSoundWith(sound, dir) {\n        if (sound) {\n            if (sound.name === version2_1.TonalSoundTags.nasalFinal && dir === AssimiDirection.agressive) {\n                // agressive assimilation of nasals, both internal and external sandhi\n                const snds = this.sounds;\n                snds.splice(0, 0, sound);\n                return [new morpheme_2.TonalSyllable(snds.map(x => new grapheme_1.AlphabeticLetter(x.characters)))];\n            }\n            else if (sound.name === version2_1.TonalSoundTags.initial && dir === AssimiDirection.agressive) {\n                const snds = this.sounds;\n                if (snds[0].toString() === sound.toString()) {\n                    let duplifix = new grapheme_1.Sound();\n                    const ps = version2_1.tonalPositionalSounds.get(version2_1.TonalLetterTags.l);\n                    if (ps)\n                        duplifix = ps(version2_1.TonalSoundTags.initial);\n                    snds.splice(0, 1, duplifix);\n                }\n                return [new morpheme_2.TonalSyllable(snds.map(x => new grapheme_1.AlphabeticLetter(x.characters)))];\n            }\n            else if (sound.name === version2_1.TonalSoundTags.nasalization && dir === AssimiDirection.agressive) {\n                const snds = this.sounds;\n                if (snds[snds.length - 1].name === version2_1.TonalSoundTags.freeTonal) {\n                    snds.splice(snds.length - 1, 0, sound);\n                }\n                else if (snds[snds.length - 1].name === version2_1.TonalSoundTags.medial) {\n                    snds.push(sound);\n                }\n                return [new morpheme_2.TonalSyllable(snds.map(x => new grapheme_1.AlphabeticLetter(x.characters)))];\n            }\n            // internal sandhi. regressive assimilation\n            return this.regAssimilate(this.sounds, sound);\n        }\n        return [];\n    }\n    regAssimilate(sounds, soundFollowingSyllable) {\n        if (sounds[sounds.length - 2].name != version2_1.TonalSoundTags.stopFinal &&\n            sounds[sounds.length - 2].name != version2_1.TonalSoundTags.nasalFinal) {\n            return [];\n        }\n        if ((sounds[sounds.length - 2].toString() === version2_1.TonalLetterTags.tt &&\n            collections_1.initialsForEuphonicTt.includes(soundFollowingSyllable.toString())) ||\n            (sounds[sounds.length - 2].toString() === version2_1.TonalLetterTags.t &&\n                collections_1.initialsForEuphonicT.includes(soundFollowingSyllable.toString()))) {\n            // absolute assimilation\n            let s = new morpheme_2.TonalSyllable(sounds.map(x => new grapheme_1.AlphabeticLetter(x.characters)));\n            let snd = new grapheme_1.Sound();\n            const af = collections_1.euphonicTtT.get(sounds[sounds.length - 2].toString() + soundFollowingSyllable.toString());\n            if (af) {\n                const ps = version2_1.tonalPositionalSounds.get(af);\n                if (ps)\n                    snd = ps(version2_1.TonalSoundTags.stopFinal);\n                s.replaceLetter(s.letters.length - 2, new grapheme_1.AlphabeticLetter(snd.characters));\n                if (collections_1.nasalInitialSounds.includes(soundFollowingSyllable.toString())) {\n                    s.insertLetter(s.letters.length - 2, new grapheme_1.AlphabeticLetter(soundFollowingSyllable.characters));\n                }\n                return [s];\n            }\n        }\n        else if (soundFollowingSyllable.toString() === version2_1.TonalLetterTags.b &&\n            sounds[sounds.length - 2].toString() === version2_1.TonalLetterTags.n) {\n            // replace final n with final m\n            let s = new morpheme_2.TonalSyllable(sounds.map(x => new grapheme_1.AlphabeticLetter(x.characters)));\n            let snd = new grapheme_1.Sound();\n            const ps = version2_1.tonalPositionalSounds.get(version2_1.TonalLetterTags.m);\n            if (ps)\n                snd = ps(version2_1.TonalSoundTags.nasalFinal);\n            s.replaceLetter(s.letters.length - 2, new grapheme_1.AlphabeticLetter(snd.characters));\n            return [s];\n        }\n        else {\n            const tss = this.conditionalVoicedFinal(sounds, soundFollowingSyllable);\n            if (tss)\n                return tss;\n        }\n        return [];\n    }\n    conditionalVoicedFinal(sounds, soundFollowingSyllable) {\n        if (soundFollowingSyllable.name === version2_1.TonalSoundTags.initial &&\n            collections_1.nasalInitialSounds.includes(soundFollowingSyllable.toString())) {\n            return this.voicedFinal(sounds);\n        }\n        if (soundFollowingSyllable.name === version2_1.TonalSoundTags.medial &&\n            new version2_1.MedialSounds().includes(soundFollowingSyllable.toString())) {\n            return this.voicedFinal(sounds);\n        }\n        if (soundFollowingSyllable.name === version2_1.TonalSoundTags.initial &&\n            collections_1.initialBghl.includes(soundFollowingSyllable.toString())) {\n            return this.voicedFinal(sounds);\n        }\n    }\n    voicedFinal(sounds) {\n        const fnl = collections_1.voicelessVoicedFinals.get(sounds[sounds.length - 2].toString());\n        if (fnl) {\n            let s = new morpheme_2.TonalSyllable(sounds.map(x => new grapheme_1.AlphabeticLetter(x.characters)));\n            let snd = new grapheme_1.Sound();\n            const ps = version2_1.tonalPositionalSounds.get(fnl);\n            if (ps)\n                snd = ps(version2_1.TonalSoundTags.stopFinal);\n            s.replaceLetter(s.letters.length - 2, new grapheme_1.AlphabeticLetter(snd.characters));\n            return [s];\n        }\n    }\n}\nexports.TonalSoundChangingMorpheme = TonalSoundChangingMorpheme;\nclass TonalCombiningMorphemeMaker extends morpheme_1.MorphemeMaker {\n    constructor(tsm) {\n        super();\n        this.metaplasm = tsm;\n    }\n    createMorphemes() {\n        return new Array();\n    }\n    createMorpheme(msp) {\n        const tcm = new TonalCombiningMorpheme(new morpheme_2.TonalSyllable(msp.letters), msp.pattern, this.metaplasm);\n        return tcm;\n    }\n    postprocess(patterns) {\n        let morphemes = this.createMorphemes();\n        for (let i in patterns) {\n            morphemes.push(this.createMorpheme(patterns[i]));\n        }\n        return morphemes;\n    }\n    makeMorphemes(gs) {\n        const ltrs = gs.map(it => it.letter);\n        const ptrns = this.make(ltrs, morpheme_2.syllabifyTonal);\n        const ms = this.postprocess(ptrns);\n        return ms;\n    }\n}\nexports.TonalCombiningMorphemeMaker = TonalCombiningMorphemeMaker;\nclass TonalSoundChangingMorphemeMaker extends morpheme_1.MorphemeMaker {\n    constructor() {\n        super();\n    }\n    createMorphemes() {\n        return new Array();\n    }\n    createMorpheme(match) {\n        const tcm = new TonalSoundChangingMorpheme(new morpheme_2.TonalSyllable(match.letters), match.pattern);\n        return tcm;\n    }\n    postprocess(matches) {\n        let morphemes = this.createMorphemes();\n        for (let i in matches) {\n            morphemes.push(this.createMorpheme(matches[i]));\n        }\n        return morphemes;\n    }\n    makeMorphemes(gs) {\n        const ltrs = gs.map(it => it.letter);\n        const ptrns = this.make(ltrs, morpheme_2.syllabifyTonal);\n        const ms = this.postprocess(ptrns);\n        return ms;\n    }\n}\nexports.TonalSoundChangingMorphemeMaker = TonalSoundChangingMorphemeMaker;\n//# sourceMappingURL=morpheme.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst configuration_1 = require(\"./configuration\");\nconst guide_1 = require(\"./guide\");\nconst token_1 = require(\"../token\");\nconst symbols_1 = require(\"./symbols\");\nconst relation_1 = require(\"./relation\");\n//import { FeatureLabel, Feature } from './feature';\nclass DependencyParser {\n    constructor() {\n        this.c = this.getInitialConfiguration();\n        this.triggered = false;\n        this.s1 = new token_1.Token('');\n        this.s2 = new token_1.Token('');\n        this.b1 = new token_1.Token('');\n        this.s1B1RightRelations = new Map()\n            .set(symbols_1.Tagset.PPV + symbols_1.Tagset.AUXN, symbols_1.DependencyLabels.compoundPrt)\n            .set(symbols_1.Tagset.PPV + symbols_1.Tagset.NPR, symbols_1.DependencyLabels.compoundPrt);\n        this.s1B1LeftRelations = new Map();\n        this.s2S1RightRelations = new Map()\n            .set(symbols_1.Tagset.VB + symbols_1.Tagset.PPV, symbols_1.DependencyLabels.compoundPrt)\n            .set(symbols_1.Tagset.VB + symbols_1.Tagset.AUXN, symbols_1.DependencyLabels.aux)\n            .set(symbols_1.Tagset.VB + symbols_1.Tagset.VB, symbols_1.DependencyLabels.compound)\n            .set(symbols_1.Tagset.VB + symbols_1.Tagset.NPR, symbols_1.DependencyLabels.obj);\n        this.s2S1LeftRelations = new Map()\n            .set(symbols_1.Tagset.AUX + symbols_1.Tagset.VB, symbols_1.DependencyLabels.aux)\n            .set(symbols_1.Tagset.PADV + symbols_1.Tagset.VB, symbols_1.DependencyLabels.advmod)\n            .set(symbols_1.Tagset.APPR + symbols_1.Tagset.NPR, symbols_1.DependencyLabels.case);\n        this.s2S1LeftFeatures = new Map().set(symbols_1.Tagset.NPR + symbols_1.Tagset.VB, [\n            symbols_1.DependencyLabels.nsubj,\n            symbols_1.DependencyLabels.dislocated\n        ]);\n        this.parse = (doc) => {\n            for (let t of doc.tokens) {\n                this.c.queue.push(t);\n            }\n            let guide = new guide_1.Guide();\n            let rt = new token_1.Token('ROOT');\n            this.c.stack.push(rt);\n            if (this.c.stack.length == 1 && this.c.queue.length > 0) {\n                // initial configuration\n                // shift the first lexeme from queue to stack\n                guide.transitions.push(new configuration_1.Shift());\n            }\n            while (!this.c.isTerminalConfiguration()) {\n                let t = guide.getNextTransition(this.c);\n                if (t == null || t == undefined)\n                    break;\n                this.setS1S2B1();\n                if (this.s1.tag != '' && this.b1.tag != '') {\n                    this.setS1B1Relation(t);\n                }\n                else if (this.isQueueEmpty()) {\n                    this.setS2S1Relation(t);\n                }\n                this.c = this.apply(t, this.c);\n            }\n            doc.relations = this.c.relations;\n            return doc;\n        };\n    }\n    getInitialConfiguration() {\n        return new configuration_1.Configuration();\n    }\n    apply(t, c) {\n        return t.do(c);\n    }\n    isQueueEmpty() {\n        if (this.c.queue.length === 0)\n            return true;\n        return false;\n    }\n    isStackEmpty() {\n        if (this.c.stack.length === 2)\n            return true;\n        return false;\n    }\n    rightRelation(label) {\n        this.s1.dep = label;\n        this.s1.head = this.s2;\n        return new relation_1.Relation(label, this.s2, this.s1);\n    }\n    leftRelation(label) {\n        this.s2.dep = label;\n        this.s2.head = this.s1;\n        return new relation_1.Relation(label, this.s1, this.s2);\n    }\n    setS1S2B1() {\n        this.s1 = new token_1.Token('');\n        if (this.c.stack.length > 0)\n            this.s1 = this.c.stack[this.c.stack.length - 1];\n        this.s2 = new token_1.Token('');\n        if (this.c.stack.length > 1)\n            this.s2 = this.c.stack[this.c.stack.length - 2];\n        this.b1 = new token_1.Token('');\n        if (this.c.queue.length > 0)\n            this.b1 = this.c.queue[0];\n    }\n    setS1B1Relation(t) {\n        if (t instanceof configuration_1.RightArc) {\n            if (this.s1B1RightRelations.has(this.s1.tag + this.b1.tag)) {\n                const rel = this.s1B1RightRelations.get(this.s1.tag + this.b1.tag);\n                if (rel) {\n                    this.c.relations.push(this.rightRelation(rel));\n                }\n            }\n        }\n        else if (t instanceof configuration_1.LeftArc) {\n            if (this.s1B1LeftRelations.has(this.s1.tag + this.b1.tag)) {\n                const rel = this.s1B1LeftRelations.get(this.s1.tag + this.b1.tag);\n                if (rel) {\n                    this.c.relations.push(this.leftRelation(rel));\n                }\n            }\n        }\n    }\n    setS2S1Relation(t) {\n        if (t instanceof configuration_1.RightArc) {\n            if (this.s2S1RightRelations.has(this.s2.tag + this.s1.tag)) {\n                const rel = this.s2S1RightRelations.get(this.s2.tag + this.s1.tag);\n                if (rel) {\n                    this.c.relations.push(this.rightRelation(rel));\n                }\n            }\n            else if (this.isStackEmpty()) {\n                this.c.relations.push(this.rightRelation(symbols_1.DependencyLabels.root));\n            }\n        }\n        else if (t instanceof configuration_1.LeftArc) {\n            if (this.s2S1LeftRelations.has(this.s2.tag + this.s1.tag)) {\n                const rel = this.s2S1LeftRelations.get(this.s2.tag + this.s1.tag);\n                if (rel) {\n                    this.c.relations.push(this.leftRelation(rel));\n                }\n            }\n            else if (this.s2S1LeftFeatures.has(this.s2.tag + this.s1.tag)) {\n                const labels = this.s2S1LeftFeatures.get(this.s2.tag + this.s1.tag);\n                if (labels) {\n                    if (this.triggered == false) {\n                        this.c.relations.push(this.leftRelation(labels[0]));\n                        this.triggered = true;\n                    }\n                    else {\n                        this.c.relations.push(this.leftRelation(labels[1]));\n                    }\n                }\n            }\n        }\n    }\n}\nexports.DependencyParser = DependencyParser;\n//# sourceMappingURL=parser.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst phraseme_1 = require(\"../phraseme\");\nconst morpheme_1 = require(\"./morpheme\");\nconst phraseme_2 = require(\"../tonal/phraseme\");\nclass ConjugateToProceeding extends phraseme_1.TonalPhrasalInflectionMetaplasm {\n    apply(lexemeVerb, lexemeParticle) {\n        if (lexemeVerb.word.literal === '' || lexemeParticle.word.literal === '')\n            return [];\n        if (lexemeParticle.getForms().length > 0) {\n            const forms = lexemeParticle.getForms();\n            const ret = [];\n            forms.map(it => ret.push(new phraseme_2.TonalPhrase([lexemeVerb.getForms()[0], it])));\n            return ret;\n        }\n        else if (lexemeVerb.getForms().length > 0) {\n            // equivalent to compound in terms of phrasal verb\n            return [new phraseme_2.TonalPhrase([lexemeVerb.getForms()[0], lexemeParticle.word])];\n        }\n        else {\n            return [new phraseme_2.TonalPhrase([])];\n        }\n    }\n}\nclass ConjugateTwoToProceeding extends phraseme_1.TonalPhrasalInflectionMetaplasm {\n    applyTwoParticles(lexemeVerb, lexemeParticle, lexemeParticleTwo) {\n        if (lexemeVerb.word.literal === '' ||\n            lexemeParticle.word.literal === '' ||\n            lexemeParticleTwo.word.literal === '')\n            return [];\n        if (lexemeParticle.getForms().length > 0 || lexemeParticleTwo.getForms.length > 0) {\n            return [\n                new phraseme_2.TonalPhrase([\n                    lexemeVerb.getForms()[0],\n                    lexemeParticle.getForms()[0],\n                    lexemeParticleTwo.getForms()[0]\n                ])\n            ];\n        }\n        return [new phraseme_2.TonalPhrase([])];\n    }\n}\nclass ConjugateToParticiple extends phraseme_1.TonalPhrasalInflectionMetaplasm {\n    apply(lexemeVerb, lexemeParticle) {\n        if (lexemeVerb.word.literal === '' || lexemeParticle.word.literal === '')\n            return [];\n        if (lexemeParticle.getForms().length > 0) {\n            const forms = lexemeParticle.getForms();\n            const ret = [];\n            if (lexemeVerb.getForms().length > 0) {\n                forms.map(it => ret.push(new phraseme_2.TonalPhrase([lexemeVerb.getForms()[0], it])));\n            }\n            else {\n                forms.map(it => ret.push(new phraseme_2.TonalPhrase([lexemeVerb.word, it])));\n            }\n            return ret;\n        }\n        return [new phraseme_2.TonalPhrase([])];\n    }\n}\nclass Adnominal extends phraseme_1.TonalPhrasalInflectionMetaplasm {\n    apply(lexemeNoun, lexemeParticle) {\n        if (lexemeNoun.word.literal === '' || lexemeParticle.word.literal === '')\n            return [];\n        if (lexemeParticle.getForms().length > 0) {\n            return [new phraseme_2.TonalPhrase([lexemeNoun.word, lexemeParticle.getForms()[0]])];\n        }\n        else {\n            return [new phraseme_2.TonalPhrase([])];\n        }\n    }\n}\nexports.Adnominal = Adnominal;\nclass Conjunctive extends phraseme_1.TonalPhrasalInflectionMetaplasm {\n    apply(lexemeVerb, lexemeLe) {\n        if (lexemeVerb.word.literal === '' || lexemeLe.word.literal === '')\n            return [];\n        if (lexemeLe.getForms().length > 0) {\n            return [new phraseme_2.TonalPhrase([lexemeVerb.getForms()[0], lexemeLe.getForms()[0]])];\n        }\n        else if (lexemeVerb.getForms().length > 0) {\n            return [new phraseme_2.TonalPhrase([lexemeVerb.getForms()[0], lexemeLe.word])];\n        }\n        else {\n            return [new phraseme_2.TonalPhrase([])];\n        }\n    }\n}\nexports.Conjunctive = Conjunctive;\nclass AgressiveExternal extends phraseme_1.TonalPhrasalAssimilationMetaplasm {\n    apply(lexemePreceding, lexemeFollowing) {\n        const wrds = lexemeFollowing.assimilateWith(lexemePreceding, morpheme_1.AssimiDirection.agressive);\n        if (wrds.length > 0)\n            return [new phraseme_2.TonalPhrase([lexemePreceding.word].concat(wrds))];\n        return [];\n    }\n}\nexports.AgressiveExternal = AgressiveExternal;\nclass RegressiveExternal extends phraseme_1.TonalPhrasalAssimilationMetaplasm {\n    apply(lexemePreceding, lexemeFollowing) {\n        const wrds = lexemePreceding.assimilateWith(lexemeFollowing, morpheme_1.AssimiDirection.regressive);\n        if (wrds.length > 0)\n            return [new phraseme_2.TonalPhrase([lexemePreceding.word].concat(wrds))];\n        return [];\n    }\n}\nexports.RegressiveExternal = RegressiveExternal;\nclass PhrasalVerbPhraseme extends phraseme_1.Phraseme {\n    constructor(lexemeVerb, lexemeParticle, metaplasm) {\n        super();\n        this.forms = new Array();\n        this.phrase = new phraseme_2.TonalPhrase([lexemeVerb.word, lexemeParticle.word]);\n        this.forms = metaplasm.apply(lexemeVerb, lexemeParticle);\n    }\n    getForms() {\n        return this.forms;\n    }\n}\nexports.PhrasalVerbPhraseme = PhrasalVerbPhraseme;\nclass PhrasalVerbTwoPhraseme extends phraseme_1.Phraseme {\n    constructor(lexemeVerb, lexemeParticle, lexemeParticleTwo, metaplasm) {\n        super();\n        this.forms = new Array();\n        this.phrase = new phraseme_2.TonalPhrase([lexemeVerb.word, lexemeParticle.word, lexemeParticleTwo.word]);\n        this.forms = metaplasm.applyTwoParticles(lexemeVerb, lexemeParticle, lexemeParticleTwo);\n    }\n    getForms() {\n        return this.forms;\n    }\n}\nexports.PhrasalVerbTwoPhraseme = PhrasalVerbTwoPhraseme;\nclass TonalCompoundPhraseme extends phraseme_1.Phraseme {\n    constructor(lexemePreceding, lexemeFollowing) {\n        super();\n        this.phrase = new phraseme_2.TonalPhrase([lexemePreceding.getForms()[0], lexemeFollowing.word]);\n    }\n}\nexports.TonalCompoundPhraseme = TonalCompoundPhraseme;\nclass TonalMainParticlePhraseme extends phraseme_1.Phraseme {\n    constructor(lexemeAdjectivalNoun, lexemeE, metaplasm) {\n        super();\n        this.forms = new Array();\n        this.phrase = new phraseme_2.TonalPhrase([lexemeAdjectivalNoun.word, lexemeE.word]);\n        this.forms = metaplasm.apply(lexemeAdjectivalNoun, lexemeE);\n    }\n    getForms() {\n        return this.forms;\n    }\n}\nexports.TonalMainParticlePhraseme = TonalMainParticlePhraseme;\nclass SerialPhraseme extends phraseme_1.Phraseme {\n    constructor(lexemes) {\n        super();\n        this.forms = new Array();\n        // the base form is equivalent to a compound when there are only 2 words\n        const words = [];\n        for (let i = 0; i < lexemes.length - 1; i++) {\n            if (lexemes[i].getForms().length > 0 && lexemes[i].getForms()[0]) {\n                words.push(lexemes[i].getForms()[0]);\n            }\n        }\n        if (lexemes[lexemes.length - 1] && lexemes[lexemes.length - 1].word.literal.length > 0) {\n            words.push(lexemes[lexemes.length - 1].word);\n        }\n        this.phrase = new phraseme_2.TonalPhrase(words);\n        const forms = lexemes.filter(it => it.getForms().length > 0 && it.getForms()[0]).map(it => it.getForms()[0]);\n        if (forms.length > 0)\n            this.forms = [new phraseme_2.TonalPhrase(forms)];\n        else\n            this.forms = [];\n    }\n    getForms() {\n        return this.forms;\n    }\n}\nexports.SerialPhraseme = SerialPhraseme;\nclass TonalAssimilationPhraseme extends phraseme_1.Phraseme {\n    constructor(lexemePreceding, lexemeFollowing, metaplasm) {\n        super();\n        this.forms = new Array();\n        this.phrase = new phraseme_2.TonalPhrase([lexemePreceding.word, lexemeFollowing.word]);\n        this.forms = metaplasm.apply(lexemePreceding, lexemeFollowing);\n    }\n    getForms() {\n        return this.forms;\n    }\n}\nexports.TonalAssimilationPhraseme = TonalAssimilationPhraseme;\nclass TonalInflectionPhrasemeMaker {\n    makePhrasalVerbPhraseme(lexemeVerb, lexemeParticle) {\n        return new PhrasalVerbPhraseme(lexemeVerb, lexemeParticle, new ConjugateToProceeding());\n    }\n    makePhrasalVerbTwoPhraseme(lexemeVerb, lexemeParticle, lexemeParticleTwo) {\n        return new PhrasalVerbTwoPhraseme(lexemeVerb, lexemeParticle, lexemeParticleTwo, new ConjugateTwoToProceeding());\n    }\n    makeCompoundPhraseme(lexemePreceding, lexemeFollowing) {\n        return new TonalCompoundPhraseme(lexemePreceding, lexemeFollowing);\n    }\n    makeAdjectivePhraseme(lexemeAdjectivalNoun, lexemeE) {\n        return new TonalMainParticlePhraseme(lexemeAdjectivalNoun, lexemeE, new Adnominal());\n    }\n    makeConjunctivePhraseme(lexemeVerb, lexemeLe) {\n        return new TonalMainParticlePhraseme(lexemeVerb, lexemeLe, new Conjunctive());\n    }\n    makePossesivePhraseme(lexemeNoun, lexemeEx) {\n        return new TonalMainParticlePhraseme(lexemeNoun, lexemeEx, new Adnominal());\n    }\n    makeParticiplePhraseme(lexemeVerb, lexemeParticle) {\n        return new PhrasalVerbPhraseme(lexemeVerb, lexemeParticle, new ConjugateToParticiple());\n    }\n    makeSerialPhraseme(lexemes) {\n        return new SerialPhraseme(lexemes);\n    }\n}\nexports.TonalInflectionPhrasemeMaker = TonalInflectionPhrasemeMaker;\nclass TonalAssimilationPhrasemeMaker {\n    makePhraseme(lexemePreceding, lexemeFollowing, metaplasm) {\n        return new TonalAssimilationPhraseme(lexemePreceding, lexemeFollowing, metaplasm);\n    }\n}\nexports.TonalAssimilationPhrasemeMaker = TonalAssimilationPhrasemeMaker;\n//# sourceMappingURL=phraseme.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Relation {\n    constructor(dep, head, dependent) {\n        this.dependency = dep;\n        this.head = head;\n        this.dependent = dependent;\n    }\n}\nexports.Relation = Relation;\n//# sourceMappingURL=relation.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst keywords_1 = require(\"./keywords\");\nconst symbols_1 = require(\"./symbols\");\nconst inflector_1 = require(\"./inflector\");\nconst dictionary_1 = require(\"./dictionary\");\nclass ConstructionOfSpeech {\n    constructor() {\n        this.pos = '';\n        this.elements = new Array();\n    }\n}\nexports.ConstructionOfSpeech = ConstructionOfSpeech;\nclass ConstructionOfPhrase extends ConstructionOfSpeech {\n    constructor(arr) {\n        super();\n        for (let key in arr) {\n            this.elements.push(arr[key]);\n        }\n    }\n}\nexports.ConstructionOfPhrase = ConstructionOfPhrase;\nclass NounPhrase extends ConstructionOfPhrase {\n}\nclass VerbPhrase extends ConstructionOfPhrase {\n}\nclass PhrasalVerb extends VerbPhrase {\n    constructor(arr) {\n        super(arr);\n        this.pos = symbols_1.POSTags.verb;\n    }\n}\nexports.PhrasalVerb = PhrasalVerb;\nclass VerbPhraseSurface extends ConstructionOfSpeech {\n    constructor() {\n        super();\n        this.pos = symbols_1.POSTags.verb;\n    }\n}\nclass PhrasalVerbWithEnclitic extends VerbPhraseSurface {\n    constructor(verb, particle, enclitic) {\n        super();\n        verb.tag = symbols_1.Tagset.VB;\n        this.elements.push(verb);\n        particle.tag = symbols_1.Tagset.PPV;\n        this.elements.push(particle);\n        enclitic.tag = symbols_1.Tagset.AUXN;\n        this.elements.push(enclitic);\n    }\n}\nexports.PhrasalVerbWithEnclitic = PhrasalVerbWithEnclitic;\nclass VerbWithEnclitic extends VerbPhraseSurface {\n    constructor(verb, enclitic) {\n        super();\n        verb.tag = symbols_1.Tagset.VB;\n        this.elements.push(verb);\n        enclitic.tag = symbols_1.Tagset.AUXN;\n        this.elements.push(enclitic);\n    }\n}\nexports.VerbWithEnclitic = VerbWithEnclitic;\nclass SetOfPhrasalVerbs {\n    constructor() {\n        this.phrms = new Array();\n        this.phvs = new Array();\n        this.populatePhrasemes();\n        this.populatePhrasalVerbs();\n    }\n    populatePhrasalVerbs() {\n        for (let i in this.phrms) {\n            this.phvs.push(new PhrasalVerb([\n                new keywords_1.VerbSurface(this.phrms[i].phrase.words[0].literal),\n                new keywords_1.ParticleSurface(this.phrms[i].phrase.words[1].literal)\n            ]));\n            this.phvs.push(new PhrasalVerb([\n                new keywords_1.VerbSurface(this.phrms[i].getForms()[0].words[0].literal),\n                new keywords_1.ParticleSurface(this.phrms[i].getForms()[0].words[1].literal)\n            ]));\n        }\n    }\n    populatePhrasemes() {\n        const pva = new inflector_1.TonalPhrasalInflector();\n        for (let i in dictionary_1.dictOfPhrasalVerbs) {\n            this.phrms.push(pva.inflectToProceeding(dictionary_1.dictOfPhrasalVerbs[i][0], dictionary_1.dictOfPhrasalVerbs[i][1]));\n        }\n    }\n}\nexports.SetOfPhrasalVerbs = SetOfPhrasalVerbs;\nclass PhrasalTransitive extends VerbPhraseSurface {\n    constructor(verb, preposition, pronoun) {\n        super();\n        verb.tag = symbols_1.Tagset.VB;\n        this.elements.push(verb);\n        preposition.tag = symbols_1.Tagset.PADV;\n        this.elements.push(preposition);\n        pronoun.tag = symbols_1.Tagset.NPR;\n        this.elements.push(pronoun);\n    }\n}\nclass SmallClause extends VerbPhraseSurface {\n    constructor(verb1, pronoun, verb2) {\n        super();\n        verb1.tag = symbols_1.Tagset.VB;\n        this.elements.push(verb1);\n        pronoun.tag = symbols_1.Tagset.NPR;\n        this.elements.push(pronoun);\n        verb2.tag = symbols_1.Tagset.VB;\n        this.elements.push(verb2);\n    }\n}\nclass SetOfSmallClauses {\n    constructor() {\n        this.constructions = [];\n        // obj. xcomp.\n        const sc = new SmallClause(new keywords_1.VerbSurface('oannw'), new keywords_1.PersonalPronounSurface('goa'), new keywords_1.VerbSurface('churw'));\n        this.constructions.push(sc);\n    }\n}\nexports.SetOfSmallClauses = SetOfSmallClauses;\nclass Rules {\n    constructor() {\n        this.phrases = new Array();\n        this.keyWords = new keywords_1.KeyWords();\n        this.populatePatterns();\n        this.populatePhrasalVerbs();\n    }\n    lookupDictionary(str) {\n        let phr;\n        if (dictionary_1.dictOfVerbs.includes(str)) {\n            let vs = new keywords_1.VerbSurface(str);\n            if (vs.pos === symbols_1.POSTags.verb)\n                vs.tag = symbols_1.Tagset.VB;\n            phr = [new ConstructionOfSpeech()];\n            phr[0].elements.push(vs);\n            phr[0].pos = symbols_1.POSTags.verb;\n            return phr;\n        }\n        return undefined;\n    }\n    lookupRules(sequence) {\n        let elems = [];\n        for (let pat of this.phrases) {\n            for (let j = 0; j < pat.length; j++) {\n                //console.log(pat[j].elements)\n                for (let e of pat[j].elements) {\n                    elems.push(e);\n                }\n            }\n            for (let i = 0; i < elems.length; i++) {\n                if (i === 1 && i + 1 === elems.length) {\n                    if (elems[0].surface === sequence[0] && elems[1].surface === sequence[1]) {\n                        return pat;\n                    }\n                }\n            }\n            elems = [];\n        }\n    }\n    matchKeyWords(str) {\n        return this.keyWords.getSurface(str);\n    }\n    seperateMatches(str) {\n        const ptcls = dictionary_1.dictOfSeperateVVCompounds[str];\n        if (ptcls) {\n            return ptcls[0];\n        }\n    }\n    matches(sequence) {\n        const phrD = this.lookupDictionary(sequence[0]);\n        const phrR = this.lookupRules(sequence);\n        if (phrR)\n            return phrR;\n        else if (phrD)\n            return phrD;\n        return undefined;\n    }\n    populatePhrasalVerbs() {\n        const s = new SetOfPhrasalVerbs();\n        for (let i = 0; i < s.phvs.length; i++) {\n            this.phrases.push([s.phvs[i]]);\n        }\n    }\n    populatePatterns() {\n        this.phrases.push([new SetOfSmallClauses().constructions[0]]);\n    }\n}\nexports.Rules = Rules;\n//# sourceMappingURL=rules.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar POSTags;\n(function (POSTags) {\n    /*\n      Universal POS tags\n      https://universaldependencies.org/u/pos/\n    */\n    POSTags[\"adjective\"] = \"ADJ\";\n    POSTags[\"adposition\"] = \"ADP\";\n    POSTags[\"adverb\"] = \"ADV\";\n    POSTags[\"auxiliary\"] = \"AUX\";\n    POSTags[\"conjunction\"] = \"CONJ\";\n    POSTags[\"coordinatingConjunction\"] = \"CCONJ\";\n    POSTags[\"determiner\"] = \"DET\";\n    POSTags[\"interjection\"] = \"INTJ\";\n    POSTags[\"noun\"] = \"NOUN\";\n    POSTags[\"number\"] = \"NUM\";\n    POSTags[\"particle\"] = \"PART\";\n    POSTags[\"pronoun\"] = \"PRON\";\n    POSTags[\"properNoun\"] = \"PROPN\";\n    POSTags[\"punctuation\"] = \"PUNCT\";\n    POSTags[\"subordinatingConjunction\"] = \"SCONJ\";\n    POSTags[\"symbol\"] = \"SYM\";\n    POSTags[\"verb\"] = \"VERB\";\n    POSTags[\"other\"] = \"X\";\n})(POSTags = exports.POSTags || (exports.POSTags = {}));\nvar DependencyLabels;\n(function (DependencyLabels) {\n    /*\n      Universal Dependencies\n      https://universaldependencies.org/u/dep/all.html\n    */\n    DependencyLabels[\"acl\"] = \"acl\";\n    DependencyLabels[\"advcl\"] = \"advcl\";\n    DependencyLabels[\"amod\"] = \"amod\";\n    DependencyLabels[\"advmod\"] = \"advmod\";\n    DependencyLabels[\"aux\"] = \"aux\";\n    DependencyLabels[\"auxCaus\"] = \"aux:caus\";\n    DependencyLabels[\"case\"] = \"case\";\n    DependencyLabels[\"ccomp\"] = \"ccomp\";\n    DependencyLabels[\"compound\"] = \"compound\";\n    DependencyLabels[\"compoundPrt\"] = \"compound:prt\";\n    DependencyLabels[\"cop\"] = \"cop\";\n    DependencyLabels[\"csubj\"] = \"csubj\";\n    DependencyLabels[\"det\"] = \"det\";\n    DependencyLabels[\"dislocated\"] = \"dislocated\";\n    DependencyLabels[\"fix\"] = \"fix\";\n    DependencyLabels[\"flat\"] = \"flat\";\n    DependencyLabels[\"obj\"] = \"obj\";\n    DependencyLabels[\"iobj\"] = \"iobj\";\n    DependencyLabels[\"iobjAgent\"] = \"iobj:agent\";\n    DependencyLabels[\"mark\"] = \"mark\";\n    DependencyLabels[\"nmod\"] = \"nmod\";\n    DependencyLabels[\"nobj\"] = \"nobj\";\n    DependencyLabels[\"nsubj\"] = \"nsubj\";\n    DependencyLabels[\"nsubjCaus\"] = \"nsubj:caus\";\n    DependencyLabels[\"obl\"] = \"obl\";\n    DependencyLabels[\"prt\"] = \"prt\";\n    DependencyLabels[\"root\"] = \"root\";\n    DependencyLabels[\"xcomp\"] = \"xcomp\";\n})(DependencyLabels = exports.DependencyLabels || (exports.DependencyLabels = {}));\nvar Tagset;\n(function (Tagset) {\n    Tagset[\"AUX\"] = \"AUX\";\n    Tagset[\"AUXN\"] = \"AUXN\";\n    Tagset[\"ADJ\"] = \"ADJ\";\n    Tagset[\"ADNOM\"] = \"ADNOM\";\n    Tagset[\"ADV\"] = \"ADV\";\n    Tagset[\"APPR\"] = \"APPR\";\n    Tagset[\"CL\"] = \"CL\";\n    Tagset[\"CONJ\"] = \"CONJ\";\n    Tagset[\"FIL\"] = \"FIL\";\n    Tagset[\"INTJ\"] = \"INTJ\";\n    Tagset[\"NN\"] = \"NN\";\n    Tagset[\"NNP\"] = \"NNP\";\n    Tagset[\"NPR\"] = \"NPR\";\n    Tagset[\"NUM\"] = \"NUM\";\n    Tagset[\"NV\"] = \"NV\";\n    Tagset[\"NADJ\"] = \"NADJ\";\n    Tagset[\"NADV\"] = \"NADV\";\n    Tagset[\"PAR\"] = \"PAR\";\n    Tagset[\"PCS\"] = \"PCS\";\n    Tagset[\"PCO\"] = \"PCO\";\n    Tagset[\"PCJ\"] = \"PCJ\";\n    Tagset[\"PEND\"] = \"PEND\";\n    Tagset[\"PADV\"] = \"PADV\";\n    Tagset[\"PPV\"] = \"PPV\";\n    Tagset[\"PSUB\"] = \"PSUB\";\n    Tagset[\"PNC\"] = \"PNC\";\n    Tagset[\"PX\"] = \"PX\";\n    Tagset[\"SX\"] = \"SX\";\n    Tagset[\"SYM\"] = \"SYM\";\n    Tagset[\"VB\"] = \"VB\"; // verb base form\n})(Tagset = exports.Tagset || (exports.Tagset = {}));\nvar PronType;\n(function (PronType) {\n    /*\n      pronominal types\n      https://universaldependencies.org/u/feat/PronType.html\n    */\n    PronType[\"DEM\"] = \"Dem\";\n    PronType[\"PRS\"] = \"Prs\";\n    PronType[\"REL\"] = \"Rel\";\n})(PronType = exports.PronType || (exports.PronType = {}));\n//# sourceMappingURL=symbols.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst rules_1 = require(\"./rules\");\nconst symbols_1 = require(\"./symbols\");\nconst keywords_1 = require(\"./keywords\");\nclass RuleBasedTagger {\n    constructor() {\n        this.speeches = new Array();\n        this.rules = new rules_1.Rules();\n        this.tag = (doc) => {\n            this.match(doc.tokens);\n            let ces = new Array();\n            for (let i in this.speeches) {\n                doc.speeches.push(this.speeches[i]);\n                for (let j in this.speeches[i].elements) {\n                    ces.push(this.speeches[i].elements[j]);\n                }\n            }\n            for (let i = 0; i < ces.length; i++) {\n                if (doc.tokens[i].text === ces[i].surface) {\n                    doc.tokens[i].pos = ces[i].pos;\n                    doc.tokens[i].tag = ces[i].tag;\n                }\n            }\n            return doc;\n        };\n    }\n    generate(sequence, phrases) {\n        let cps = new Array();\n        if (phrases.length > 0) {\n            for (let ph of phrases) {\n                cps.push(ph);\n                //console.log(pat.elements)\n                if (ph instanceof rules_1.PhrasalVerb) {\n                    const pvwe = new rules_1.PhrasalVerbWithEnclitic(new keywords_1.VerbSurface(ph.elements[0].surface), new keywords_1.ParticleSurface(ph.elements[1].surface), new keywords_1.EncliticSurface('aw'));\n                    cps.push(pvwe);\n                }\n                else if (ph.pos === symbols_1.POSTags.verb) {\n                    const vwe = new rules_1.VerbWithEnclitic(new keywords_1.VerbSurface(sequence[0]), new keywords_1.EncliticSurface('aw'));\n                    cps.push(vwe);\n                }\n            }\n        }\n        else {\n            //console.log(sequence)\n            const vwe = new rules_1.VerbWithEnclitic(new keywords_1.VerbSurface(sequence[0]), new keywords_1.EncliticSurface('aw'));\n            cps.push(vwe);\n        }\n        //console.log(cps)\n        return cps;\n    }\n    tagKeyWord(kw) {\n        if (kw.pos === symbols_1.POSTags.pronoun) {\n            kw.tag = symbols_1.Tagset.NPR;\n        }\n        else if (kw.pos === symbols_1.POSTags.auxiliary)\n            kw.tag = symbols_1.Tagset.AUX;\n        else if (kw.pos === symbols_1.POSTags.particle)\n            kw.tag = symbols_1.Tagset.PADV;\n    }\n    matchSeperates(sequence, particle) {\n        let phrase = new rules_1.ConstructionOfSpeech();\n        let vs = new keywords_1.VerbSurface(sequence[0]);\n        vs.tag = symbols_1.Tagset.VB;\n        phrase.elements.push(vs);\n        phrase.pos = symbols_1.POSTags.verb;\n        if (sequence.length > 1) {\n            for (let i = 1; i < sequence.length; i++) {\n                // skip the first array element\n                let kw = this.rules.matchKeyWords(sequence[i]);\n                if (kw) {\n                    this.tagKeyWord(kw);\n                    phrase.elements.push(kw);\n                }\n                if (sequence[i] === particle) {\n                    let ps = new keywords_1.VerbSurface(sequence[i]);\n                    ps.tag = symbols_1.Tagset.VB;\n                    phrase.elements.push(ps);\n                    return phrase;\n                }\n            }\n        }\n    }\n    tagPhrases(phrases) {\n        if (phrases.length > 0) {\n            for (let ph of phrases) {\n                if (ph.pos === symbols_1.POSTags.verb && ph.elements[ph.elements.length - 1].pos === symbols_1.POSTags.particle) {\n                    ph.elements[0].tag = symbols_1.Tagset.VB;\n                    ph.elements[ph.elements.length - 1].tag = symbols_1.Tagset.PPV;\n                }\n                else if (ph.pos === symbols_1.POSTags.verb && ph.elements[ph.elements.length - 1].pos === symbols_1.POSTags.auxiliary) {\n                    //console.log('something else hit')\n                }\n                else if (ph.pos === symbols_1.POSTags.verb && ph.elements[ph.elements.length - 1].pos === symbols_1.POSTags.adposition) {\n                    ph.elements[0].tag = symbols_1.Tagset.VB;\n                    ph.elements[ph.elements.length - 1].tag = symbols_1.Tagset.APPR;\n                }\n            }\n        }\n        return phrases;\n    }\n    phrase(strs, beginOfPhrase) {\n        let sequence = [];\n        let phrss;\n        for (let i = beginOfPhrase; i < strs.length; i++) {\n            sequence.push(strs[i]);\n        }\n        phrss = this.rules.matches(sequence);\n        const ptcl = this.rules.seperateMatches(sequence[0]);\n        if (ptcl) {\n            const sep = this.matchSeperates(sequence, ptcl);\n            if (sep) {\n                phrss = [];\n                phrss = [sep];\n            }\n        }\n        if (!phrss) {\n            //console.log(sequence)\n            let kw = this.rules.matchKeyWords(sequence[0]);\n            if (kw) {\n                //console.log(kw)\n                this.tagKeyWord(kw);\n                phrss = [new rules_1.ConstructionOfSpeech()];\n                phrss[0].elements.push(kw);\n            }\n        }\n        //if(pats) console.log(pats[0].elements)\n        if (phrss)\n            phrss = this.tagPhrases(phrss);\n        let listCP = new Array();\n        if (phrss)\n            listCP = this.generate(sequence, phrss);\n        else\n            listCP = this.generate(sequence, []);\n        //console.log(listCP);\n        let matchedLen = 0;\n        let mp = new rules_1.ConstructionOfSpeech();\n        for (let m in listCP) {\n            const min = Math.min(strs.length - beginOfPhrase, listCP[m].elements.length);\n            if (listCP[m].elements.length == min) {\n                for (let n = 0; n < min; n++) {\n                    if (listCP[m].elements[n] != undefined) {\n                        if (strs[beginOfPhrase + n] === listCP[m].elements[n].surface) {\n                            if (n + 1 == min && min > matchedLen) {\n                                matchedLen = min;\n                                for (let q = 0; q < matchedLen; q++) {\n                                    mp.elements[q] = listCP[m].elements[q];\n                                    if (listCP[m].elements[q].surface === '') {\n                                        mp.elements[q].surface = strs[beginOfPhrase + q];\n                                    }\n                                }\n                                mp.pos = listCP[m].pos;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return mp;\n    }\n    tagSpeeches() {\n        for (let s of this.speeches) {\n            if (s.elements.length == 1 && s.elements[0].pos == symbols_1.POSTags.pronoun)\n                s.pos = symbols_1.POSTags.pronoun;\n            //console.log(s)\n            //console.log(s.elements)\n        }\n    }\n    match(tokens) {\n        let strs = [];\n        for (let i in tokens)\n            strs.push(tokens[i].text);\n        let beginOfPhrase = 0;\n        let matched = new rules_1.ConstructionOfSpeech();\n        for (let i = 0; i < strs.length; i++) {\n            if (i - beginOfPhrase == 0) {\n                matched = this.phrase(strs, beginOfPhrase);\n                //console.log(matched)\n                if (matched.elements.length) {\n                    beginOfPhrase += matched.elements.length;\n                    this.speeches.push(matched);\n                    this.tagSpeeches();\n                }\n            }\n        }\n    }\n}\nexports.RuleBasedTagger = RuleBasedTagger;\n//# sourceMappingURL=tagger.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst character_1 = require(\"./character\");\n//------------------------------------------------------------------------------\nclass Grapheme {\n}\nclass AlphabeticGrapheme extends Grapheme {\n    constructor(letter) {\n        super();\n        this.letter = letter;\n    }\n}\nexports.AlphabeticGrapheme = AlphabeticGrapheme;\n//------------------------------------------------------------------------------\nclass Letter {\n    constructor() {\n        this.literal = '';\n    }\n}\nexports.Letter = Letter;\nclass AlphabeticLetter extends Letter {\n    constructor(characters) {\n        super();\n        this.characters = new Array();\n        if (characters && characters.length > 0) {\n            const len = characters.length;\n            for (let i = 0; i < len; i++) {\n                this.pushCharacter(characters[i]);\n            }\n        }\n    }\n    pushCharacter(c) {\n        this.characters.push(c);\n        this.literal += c.character;\n    }\n}\nexports.AlphabeticLetter = AlphabeticLetter;\nclass MatchedSequence {\n    constructor() {\n        this.characters = new Array();\n    }\n    get matchedLength() {\n        return this.characters.length;\n    }\n    toString() {\n        let str = '';\n        for (let i in this.characters) {\n            str += this.characters[i].character;\n        }\n        return str;\n    }\n}\nexports.MatchedSequence = MatchedSequence;\nclass Letters {\n    constructor(larr) {\n        this.o = new Map();\n        this.arr = larr;\n        for (let i = 0; i < this.arr.length; i++) {\n            this.assign(this.arr[i]);\n        }\n    }\n    assign(e) {\n        let carr = [];\n        for (let i = 0; i < e.length; i++) {\n            let c = character_1.characters.get(e[i]);\n            if (c) {\n                carr.push(c);\n            }\n        }\n        this.o.set(e, new AlphabeticLetter(carr));\n    }\n    get(key) {\n        let value = this.o.get(key);\n        if (value) {\n            return value;\n        }\n        return new AlphabeticLetter([]);\n    }\n    get size() {\n        return this.o.size;\n    }\n    get values() {\n        return this.o.values();\n    }\n}\nexports.Letters = Letters;\n//------------------------------------------------------------------------------\nclass GraphemeMaker {\n    constructor(lowerLetters) {\n        this.list = new Array();\n        this.list = Array.from(lowerLetters.values);\n    }\n    makeGraphemes(str) {\n        const characters = new Array();\n        if (str) {\n            for (let i = 0; i < str.length; i++) {\n                if (str.charAt(i) != '\\0') {\n                    characters.push(new character_1.Character(str.charAt(i)));\n                }\n            }\n        }\n        let graphemes = this.make(characters);\n        return graphemes;\n    }\n    getMatchedSequence(characters, beginOfLetter, candidates) {\n        let ms = new MatchedSequence();\n        let matchedLen = 0;\n        //console.log(characters)\n        if (characters[beginOfLetter].character === 'n') {\n            if (characters.length - beginOfLetter >= 'nng'.length) {\n                if (characters[beginOfLetter].character === 'n' &&\n                    characters[beginOfLetter + 1].character === 'n' &&\n                    characters[beginOfLetter + 2].character === 'g') {\n                    // at the beginning of a letter, we should always prefer 'n' to 'nn'\n                    // 'nn' is not able to begin a syllable\n                    // 'ng' has higher associativity than 'nn' when in 'nng'\n                    // special case for 'nng'\n                    // copy the matched letter\n                    ms.characters[0] = new character_1.Character('n');\n                    return ms;\n                }\n            }\n        }\n        for (let j in candidates) {\n            let min = Math.min(characters.length - beginOfLetter, candidates[j].literal.length);\n            if (candidates[j].literal.length == min) {\n                for (let k = 0; k < min; k++) {\n                    if (characters[beginOfLetter + k].character === candidates[j].literal[k]) {\n                        if (k + 1 == min && min > matchedLen) {\n                            // to make sure it is longer than previous patterns\n                            // last letter matched for the pattern\n                            matchedLen = min;\n                            // copy the matched letters\n                            for (let q = 0; q < matchedLen; q++) {\n                                ms.characters[q] = characters[beginOfLetter + q];\n                            }\n                        }\n                    }\n                    else {\n                        break;\n                    }\n                }\n            }\n        }\n        return ms;\n    }\n    make(characters) {\n        let graphemes = new Array();\n        //console.log(\"metadata letter array length %d. \", letters.length);\n        let beginOfLetter = 0;\n        let letters = new Array();\n        for (let i = 0; i < characters.length; i++) {\n            //console.log(\"examining character: %s. length of characters: %d\", characters[i].symbol, characters.length);\n            //console.log(\"metadata letter array looping.\");\n            if (i - beginOfLetter == 0) {\n                //console.log(\"matchedLen: %d\", ms.matchedLength);\n                let candidates = this.list.filter(l => l.characters[0].character === characters[i].character);\n                let ms = this.getMatchedSequence(characters, beginOfLetter, candidates);\n                if (ms.matchedLength > 0) {\n                    for (let key in candidates) {\n                        //console.log(candidates[key].literal + ' - ' + ms.toString())\n                        if (candidates[key].literal === new AlphabeticLetter(ms.characters).literal) {\n                            letters.push(candidates[key]);\n                        }\n                    }\n                }\n            }\n            if (letters.length == 0) {\n                for (let j in characters) {\n                    //console.log(characters[j].character)\n                }\n                // 'length of letters is zero'\n            }\n            else if (letters.length == 1) {\n                //console.log(\"just one matched. i:%d. ls[0].characters.length:%d. ls[0]:\", i, ls[0].characters.length, ls[0])\n                //console.log(\"just one matched. i:%d. ls[0].characters.length:%d\", i, ls[0].characters.length);\n                if (i + 1 - beginOfLetter == letters[0].characters.length) {\n                    // when index i plus one equals the length of the matched syllable\n                    let l = letters.shift();\n                    if (l) {\n                        beginOfLetter += l.characters.length;\n                        // pack letters into sounds\n                        let gr = new AlphabeticGrapheme(l);\n                        graphemes.push(gr);\n                    }\n                }\n            }\n        }\n        //console.log(\"metadata letter array length %d\", letters.length);\n        return graphemes;\n    }\n}\nexports.GraphemeMaker = GraphemeMaker;\n//------------------------------------------------------------------------------\nclass Sound {\n    constructor() {\n        this.name = '';\n        // an array of character objects. can be used to make a word object.\n        this.characters = new Array();\n    }\n    // we still need a method for combinning characters from each character objects.\n    // this is different from an array of character objects. it is a string.\n    toString() {\n        let l = '';\n        // there is no characters for 1st tone\n        if (this.characters != null) {\n            // when it is not 1st tone\n            for (let k in this.characters) {\n                l += this.characters[k].character;\n            }\n        }\n        return l;\n    }\n    makeCharacters(str) {\n        let arr = new Array();\n        for (let i = 0; i < str.length; i++) {\n            arr.push(new character_1.Character(str[i]));\n        }\n        return arr;\n    }\n}\nexports.Sound = Sound;\nclass SetOfSounds {\n    constructor() {\n        this.sounds = new Array();\n    }\n    includes(str) {\n        for (let i in this.sounds) {\n            if (str && this.sounds[i] && str === this.sounds[i].toString())\n                return true;\n        }\n        return false;\n    }\n}\nexports.SetOfSounds = SetOfSounds;\n//------------------------------------------------------------------------------\nexports.pipe = (...fns) => (x) => fns.reduce((v, f) => f(v), x);\nclass SoundGeneration {\n    constructor() {\n        this.letters = [];\n        this.sounds = new Array();\n        this.matching = true;\n        this.predictive = false;\n        this.predictions = new Array();\n        this.predictEuphonicFinal = false;\n    }\n}\nexports.SoundGeneration = SoundGeneration;\n//# sourceMappingURL=grapheme.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// client\nvar client_1 = require(\"./client\");\nexports.Client = client_1.Client;\n// API\nvar analyzer_1 = require(\"./tonal/analyzer\");\nexports.TonalLemmatizationAnalyzer = analyzer_1.TonalLemmatizationAnalyzer;\nvar analyzer_2 = require(\"./dparser/analyzer\");\nexports.TonalInflectionAnalyzer = analyzer_2.TonalInflectionAnalyzer;\nvar analyzer_3 = require(\"./kana/analyzer\");\nexports.KanaLemmatizationAnalyzer = analyzer_3.KanaLemmatizationAnalyzer;\nvar grapheme_1 = require(\"./grapheme\");\nexports.GraphemeMaker = grapheme_1.GraphemeMaker;\nvar lexicalroots2_1 = require(\"./tonal/lexicalroots2\");\nexports.lexicalRoots = lexicalroots2_1.lexicalRoots;\nvar version2_1 = require(\"./tonal/version2\");\nexports.lowerLettersTonal = version2_1.lowerLettersTonal;\nexports.TonalLetterTags = version2_1.TonalLetterTags;\nvar lemmatizer_1 = require(\"./tonal/lemmatizer\");\nexports.TonalLemmatizer = lemmatizer_1.TonalLemmatizer;\nvar assimilator_1 = require(\"./dparser/assimilator\");\nexports.TonalAssimilator = assimilator_1.TonalAssimilator;\nvar creator_1 = require(\"./dparser/creator\");\nexports.TonalCreator = creator_1.TonalCreator;\nvar inflector_1 = require(\"./dparser/inflector\");\nexports.TonalPhrasalInflector = inflector_1.TonalPhrasalInflector;\nexports.TonalInflector = inflector_1.TonalInflector;\nvar inserter_1 = require(\"./dparser/inserter\");\nexports.TonalInserter = inserter_1.TonalInserter;\nvar token_1 = require(\"./token\");\nexports.TokenAnalysis = token_1.TokenAnalysis;\nvar grapheme_2 = require(\"./grapheme\");\nexports.AlphabeticGrapheme = grapheme_2.AlphabeticGrapheme;\nvar morpheme_1 = require(\"./dparser/morpheme\");\nexports.TonalCombiningMorpheme = morpheme_1.TonalCombiningMorpheme;\nvar morpheme_2 = require(\"./tonal/morpheme\");\nexports.TonalUncombiningMorpheme = morpheme_2.TonalUncombiningMorpheme;\nvar lexeme_1 = require(\"./dparser/lexeme\");\nexports.TonalInflectionLexeme = lexeme_1.TonalInflectionLexeme;\nexports.TonalAssimilationLexeme = lexeme_1.TonalAssimilationLexeme;\nvar lexeme_2 = require(\"./tonal/lexeme\");\nexports.TonalLemmatizationLexeme = lexeme_2.TonalLemmatizationLexeme;\nvar phraseme_1 = require(\"./dparser/phraseme\");\nexports.PhrasalVerbPhraseme = phraseme_1.PhrasalVerbPhraseme;\nexports.PhrasalVerbTwoPhraseme = phraseme_1.PhrasalVerbTwoPhraseme;\nexports.TonalMainParticlePhraseme = phraseme_1.TonalMainParticlePhraseme;\nexports.TonalCompoundPhraseme = phraseme_1.TonalCompoundPhraseme;\nexports.SerialPhraseme = phraseme_1.SerialPhraseme;\nexports.TonalAssimilationPhraseme = phraseme_1.TonalAssimilationPhraseme;\nvar morpheme_3 = require(\"./kana/morpheme\");\nexports.KanaUncombiningMorpheme = morpheme_3.KanaUncombiningMorpheme;\nvar lexeme_3 = require(\"./tonal/lexeme\");\nexports.TonalWord = lexeme_3.TonalWord;\nvar phraseme_2 = require(\"./tonal/phraseme\");\nexports.TonalPhrase = phraseme_2.TonalPhrase;\nvar grapheme_3 = require(\"./grapheme\");\nexports.Sound = grapheme_3.Sound;\nexports.SoundGeneration = grapheme_3.SoundGeneration;\nvar morpheme_4 = require(\"./dparser/morpheme\");\nexports.TonalCombiningForms = morpheme_4.TonalCombiningForms;\nvar lexeme_4 = require(\"./dparser/lexeme\");\nexports.TonalDesinenceInflection = lexeme_4.TonalDesinenceInflection;\nvar prediction_1 = require(\"./tonal/prediction\");\nexports.Prediction = prediction_1.Prediction;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst grapheme_1 = require(\"../grapheme\");\nconst morpheme_1 = require(\"./morpheme\");\nconst kana_1 = require(\"./kana\");\nconst analyzer_1 = require(\"../analyzer\");\nconst morpheme_2 = require(\"../morpheme\");\n//------------------------------------------------------------------------------\nclass KanaLemmatizationAnalyzer extends analyzer_1.Analyzer {\n    graphAnalyze(str) {\n        // graphemic analysis\n        const gm = new grapheme_1.GraphemeMaker(kana_1.lowerLettersKana);\n        return gm.makeGraphemes(str);\n    }\n    morphAnalyze(x) {\n        // morphological analysis\n        let graphemes = [];\n        if (typeof x == 'object') {\n            graphemes = x;\n        }\n        else if (typeof x == 'string') {\n            graphemes = this.graphAnalyze(x);\n        }\n        const mm = new morpheme_1.KanaUncombiningMorphemeMaker(new morpheme_2.KanaCombiningMetaplasm());\n        return mm.makeInputingMorphemes(graphemes);\n    }\n}\nexports.KanaLemmatizationAnalyzer = KanaLemmatizationAnalyzer;\n//# sourceMappingURL=analyzer.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst kana_1 = require(\"./kana\");\nfunction checkLetterSizeKana() {\n    if (kana_1.kanaPositionalSound.size !== kana_1.lowerLettersKana.size) {\n        console.log('sizes unmatched');\n    }\n}\nexports.checkLetterSizeKana = checkLetterSizeKana;\nfunction checkChouon(previousLetter, nextLetter) {\n    if (previousLetter === nextLetter)\n        return true;\n    if (previousLetter === 'e' && nextLetter === 'i')\n        return true;\n    if (previousLetter === 'o' && nextLetter === 'u')\n        return true;\n    return false;\n}\nfunction lookup(str) {\n    let results = kana_1.hiraganaKatakana.get(str);\n    if (results == undefined) {\n        results = kana_1.gailaigo.get(str);\n    }\n    return results;\n}\nfunction getKanaBlocks(ms) {\n    // string one is hiragana, string two is katakana, string 3 is chouon\n    let kanaCompositions = ['', '', ''];\n    let previous = '';\n    for (let e of ms) {\n        let ks = lookup(e.syllable.literal);\n        if (ks != undefined && ks[0] != undefined) {\n            // in case the kana is absent, we check against ks[0]\n            kanaCompositions[0] += ks[0];\n            kanaCompositions[1] += ks[1];\n            if (previous.length > 0 &&\n                checkChouon(previous[previous.length - 1], e.syllable.literal[e.syllable.literal.length - 1]) &&\n                new kana_1.InitialConsonantSet().includes(e.syllable.literal) == false &&\n                e.syllable.literal.length == 1) {\n                // a vowel does not begin with a consonant and is of length 1\n                // a vowel follows a previous vowel\n                kanaCompositions[2] += 'ー';\n            }\n            else {\n                kanaCompositions[2] += ks[1];\n            }\n        }\n        else if (new kana_1.FinalConsonantSet().includes(e.syllable.literal[e.syllable.literal.length - 1]) == true) {\n            ks = lookup(e.syllable.literal.substring(0, e.syllable.literal.length - 1));\n            if (ks != undefined && ks[0] != undefined) {\n                kanaCompositions[0] += ks[0];\n                kanaCompositions[1] += ks[1];\n                kanaCompositions[2] += ks[1];\n            }\n            if (new kana_1.Hatsuon().includes(e.syllable.literal[e.syllable.literal.length - 1])) {\n                ks = kana_1.hatsuon.get('n');\n                if (ks) {\n                    kanaCompositions[0] += ks[0];\n                    kanaCompositions[1] += ks[1];\n                    kanaCompositions[2] += ks[1];\n                }\n            }\n            else {\n                ks = kana_1.kogakimoji.get('chu');\n                if (ks) {\n                    kanaCompositions[0] += ks[0];\n                    kanaCompositions[1] += ks[1];\n                    kanaCompositions[2] += ks[1];\n                }\n            }\n        }\n        else {\n            let first = e.syllable.literal[0];\n            let second = e.syllable.literal[1];\n            if (first === second && new kana_1.GerminatedConsonantSet().includes(first) == true) {\n                ks = kana_1.kogakimoji.get('chu');\n                if (ks) {\n                    kanaCompositions[0] += ks[0];\n                    kanaCompositions[1] += ks[1];\n                    kanaCompositions[2] += ks[1];\n                }\n                ks = kana_1.hiraganaKatakana.get(e.syllable.literal.substring(1, e.syllable.literal.length));\n                if (ks) {\n                    kanaCompositions[0] += ks[0];\n                    kanaCompositions[1] += ks[1];\n                    kanaCompositions[2] += ks[1];\n                }\n            }\n        }\n        previous = e.syllable.literal;\n    }\n    // remove duplicates\n    if (kanaCompositions[1] === kanaCompositions[2])\n        kanaCompositions[2] = '';\n    return kanaCompositions;\n}\nexports.getKanaBlocks = getKanaBlocks;\n//# sourceMappingURL=init.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst grapheme_1 = require(\"../grapheme\");\n//------------------------------------------------------------------------------\nvar KanaLetterTags;\n(function (KanaLetterTags) {\n    KanaLetterTags[\"a\"] = \"a\";\n    KanaLetterTags[\"e\"] = \"e\";\n    KanaLetterTags[\"i\"] = \"i\";\n    KanaLetterTags[\"o\"] = \"o\";\n    KanaLetterTags[\"u\"] = \"u\";\n    KanaLetterTags[\"b\"] = \"b\";\n    KanaLetterTags[\"c\"] = \"c\";\n    KanaLetterTags[\"ch\"] = \"ch\";\n    KanaLetterTags[\"d\"] = \"d\";\n    KanaLetterTags[\"f\"] = \"f\";\n    KanaLetterTags[\"g\"] = \"g\";\n    KanaLetterTags[\"h\"] = \"h\";\n    KanaLetterTags[\"j\"] = \"j\";\n    KanaLetterTags[\"k\"] = \"k\";\n    KanaLetterTags[\"l\"] = \"l\";\n    KanaLetterTags[\"m\"] = \"m\";\n    KanaLetterTags[\"r\"] = \"r\";\n    KanaLetterTags[\"s\"] = \"s\";\n    KanaLetterTags[\"v\"] = \"v\";\n    KanaLetterTags[\"z\"] = \"z\";\n    KanaLetterTags[\"p\"] = \"p\";\n    KanaLetterTags[\"t\"] = \"t\";\n    KanaLetterTags[\"w\"] = \"w\";\n    KanaLetterTags[\"y\"] = \"y\";\n    KanaLetterTags[\"n\"] = \"n\";\n    KanaLetterTags[\"ng\"] = \"ng\";\n})(KanaLetterTags || (KanaLetterTags = {}));\nclass LettersOfKana extends grapheme_1.Letters {\n}\nexports.LettersOfKana = LettersOfKana;\nexports.lowerLettersKana = new LettersOfKana([\n    KanaLetterTags.a,\n    KanaLetterTags.e,\n    KanaLetterTags.i,\n    KanaLetterTags.o,\n    KanaLetterTags.u,\n    KanaLetterTags.b,\n    KanaLetterTags.c,\n    KanaLetterTags.ch,\n    KanaLetterTags.d,\n    KanaLetterTags.f,\n    KanaLetterTags.g,\n    KanaLetterTags.h,\n    KanaLetterTags.j,\n    KanaLetterTags.k,\n    KanaLetterTags.l,\n    KanaLetterTags.m,\n    KanaLetterTags.r,\n    KanaLetterTags.s,\n    KanaLetterTags.v,\n    KanaLetterTags.z,\n    KanaLetterTags.p,\n    KanaLetterTags.t,\n    KanaLetterTags.w,\n    KanaLetterTags.y,\n    KanaLetterTags.n,\n    KanaLetterTags.ng\n]);\n//------------------------------------------------------------------------------\nvar KanaSoundTags;\n(function (KanaSoundTags) {\n    KanaSoundTags[\"germinatedConsonant\"] = \"germinatedConsonant\";\n    KanaSoundTags[\"initialConsonant\"] = \"initialConsonant\";\n    KanaSoundTags[\"semivowel\"] = \"semivowel\";\n    KanaSoundTags[\"vowel\"] = \"vowel\";\n    KanaSoundTags[\"finalConsonant\"] = \"finalConsonant\";\n})(KanaSoundTags = exports.KanaSoundTags || (exports.KanaSoundTags = {}));\nclass GerminatedConsonant extends grapheme_1.Sound {\n    constructor() {\n        super(...arguments);\n        this.name = KanaSoundTags.germinatedConsonant;\n    }\n}\nclass InitialConsonant extends grapheme_1.Sound {\n    constructor() {\n        super(...arguments);\n        this.name = KanaSoundTags.initialConsonant;\n    }\n}\nclass Semivowel extends grapheme_1.Sound {\n    constructor() {\n        super(...arguments);\n        this.name = KanaSoundTags.semivowel;\n    }\n}\nclass Vowel extends grapheme_1.Sound {\n    constructor() {\n        super(...arguments);\n        this.name = KanaSoundTags.vowel;\n    }\n}\nclass FinalConsonant extends grapheme_1.Sound {\n    constructor() {\n        super(...arguments);\n        this.name = KanaSoundTags.finalConsonant;\n    }\n}\nclass InitialConsonantB extends InitialConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.b);\n    }\n}\nclass InitialConsonantC extends InitialConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.c);\n    }\n}\nclass InitialConsonantCH extends InitialConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.ch);\n    }\n}\nclass InitialConsonantD extends InitialConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.d);\n    }\n}\nclass InitialConsonantF extends InitialConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.f);\n    }\n}\nclass InitialConsonantG extends InitialConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.g);\n    }\n}\nclass InitialConsonantH extends InitialConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.h);\n    }\n}\nclass InitialConsonantJ extends InitialConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.j);\n    }\n}\nclass InitialConsonantK extends InitialConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.k);\n    }\n}\nclass InitialConsonantL extends InitialConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.l);\n    }\n}\nclass InitialConsonantM extends InitialConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.m);\n    }\n}\nclass InitialConsonantN extends InitialConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.n);\n    }\n}\nclass InitialConsonantNG extends InitialConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.ng);\n    }\n}\nclass InitialConsonantP extends InitialConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.p);\n    }\n}\nclass InitialConsonantR extends InitialConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.r);\n    }\n}\nclass InitialConsonantS extends InitialConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.s);\n    }\n}\nclass InitialConsonantT extends InitialConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.t);\n    }\n}\nclass InitialConsonantV extends InitialConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.v);\n    }\n}\nclass InitialConsonantW extends InitialConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.w);\n    }\n}\nclass InitialConsonantY extends InitialConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.y);\n    }\n}\nclass InitialConsonantZ extends InitialConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.z);\n    }\n}\nclass SemivowelW extends Semivowel {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.w);\n    }\n}\nclass SemivowelY extends Semivowel {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.y);\n    }\n}\nclass VowelA extends Vowel {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.a);\n    }\n}\nclass VowelE extends Vowel {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.e);\n    }\n}\nclass VowelI extends Vowel {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.i);\n    }\n}\nclass VowelO extends Vowel {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.o);\n    }\n}\nclass VowelU extends Vowel {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.u);\n    }\n}\nclass FinalConsonantB extends FinalConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.b);\n    }\n}\nclass FinalConsonantD extends FinalConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.d);\n    }\n}\nclass FinalConsonantG extends FinalConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.g);\n    }\n}\nclass FinalConsonantK extends FinalConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.k);\n    }\n}\nclass FinalConsonantH extends FinalConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.h);\n    }\n}\nclass FinalConsonantN extends FinalConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.n);\n    }\n}\nclass FinalConsonantP extends FinalConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.p);\n    }\n}\nclass FinalConsonantS extends FinalConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.s);\n    }\n}\nclass FinalConsonantT extends FinalConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.t);\n    }\n}\nclass GerminatedConsonantB extends GerminatedConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.b);\n    }\n}\nclass GerminatedConsonantC extends GerminatedConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.c);\n    }\n}\nclass GerminatedConsonantD extends GerminatedConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.d);\n    }\n}\nclass GerminatedConsonantG extends GerminatedConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.g);\n    }\n}\nclass GerminatedConsonantK extends GerminatedConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.k);\n    }\n}\nclass GerminatedConsonantP extends GerminatedConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.p);\n    }\n}\nclass GerminatedConsonantS extends GerminatedConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.s);\n    }\n}\nclass GerminatedConsonantT extends GerminatedConsonant {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(KanaLetterTags.t);\n    }\n}\nclass InitialConsonantSet extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new InitialConsonantB());\n        this.sounds.push(new InitialConsonantC());\n        this.sounds.push(new InitialConsonantCH());\n        this.sounds.push(new InitialConsonantD());\n        this.sounds.push(new InitialConsonantF());\n        this.sounds.push(new InitialConsonantG());\n        this.sounds.push(new InitialConsonantH());\n        this.sounds.push(new InitialConsonantJ());\n        this.sounds.push(new InitialConsonantK());\n        this.sounds.push(new InitialConsonantL());\n        this.sounds.push(new InitialConsonantM());\n        this.sounds.push(new InitialConsonantN());\n        this.sounds.push(new InitialConsonantNG());\n        this.sounds.push(new InitialConsonantP());\n        this.sounds.push(new InitialConsonantR());\n        this.sounds.push(new InitialConsonantS());\n        this.sounds.push(new InitialConsonantT());\n        this.sounds.push(new InitialConsonantV());\n        this.sounds.push(new InitialConsonantW());\n        this.sounds.push(new InitialConsonantY());\n        this.sounds.push(new InitialConsonantZ());\n    }\n}\nexports.InitialConsonantSet = InitialConsonantSet;\nclass VowelSet extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new VowelA());\n        this.sounds.push(new VowelI());\n        this.sounds.push(new VowelU());\n        this.sounds.push(new VowelE());\n        this.sounds.push(new VowelO());\n    }\n}\nexports.VowelSet = VowelSet;\nclass GerminatedConsonantSet extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new GerminatedConsonantB());\n        this.sounds.push(new GerminatedConsonantC());\n        this.sounds.push(new GerminatedConsonantD());\n        this.sounds.push(new GerminatedConsonantG());\n        this.sounds.push(new GerminatedConsonantK());\n        this.sounds.push(new GerminatedConsonantP());\n        this.sounds.push(new GerminatedConsonantS());\n        this.sounds.push(new GerminatedConsonantT());\n    }\n}\nexports.GerminatedConsonantSet = GerminatedConsonantSet;\nclass SemivowelSet extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new SemivowelW());\n        this.sounds.push(new SemivowelY());\n    }\n}\nexports.SemivowelSet = SemivowelSet;\nclass FinalConsonantSet extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new FinalConsonantB());\n        this.sounds.push(new FinalConsonantD());\n        this.sounds.push(new FinalConsonantG());\n        this.sounds.push(new FinalConsonantK());\n        this.sounds.push(new FinalConsonantN());\n        this.sounds.push(new FinalConsonantP());\n        this.sounds.push(new FinalConsonantS());\n        this.sounds.push(new FinalConsonantT());\n    }\n}\nexports.FinalConsonantSet = FinalConsonantSet;\nclass Hatsuon extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new FinalConsonantN());\n    }\n}\nexports.Hatsuon = Hatsuon;\n//------------------------------------------------------------------------------\nfunction positionalSound(sounds) {\n    return (t) => {\n        for (let i in sounds) {\n            if (sounds[i].name === t)\n                return sounds[i];\n        }\n        return new grapheme_1.Sound();\n    };\n}\nexports.positionalSound = positionalSound;\nconst psA = positionalSound([new VowelA()]);\nconst psB = positionalSound([new InitialConsonantB(), new FinalConsonantB(), new GerminatedConsonantB()]);\nconst psC = positionalSound([new InitialConsonantC(), new GerminatedConsonantC()]);\nconst psCh = positionalSound([new InitialConsonantCH()]);\nconst psD = positionalSound([new InitialConsonantD(), new FinalConsonantD(), new GerminatedConsonantD()]);\nconst psE = positionalSound([new VowelE()]);\nconst psF = positionalSound([new InitialConsonantF()]);\nconst psG = positionalSound([new InitialConsonantG(), new FinalConsonantG(), new GerminatedConsonantG()]);\nconst psH = positionalSound([new InitialConsonantH()]);\nconst psI = positionalSound([new VowelI()]);\nconst psJ = positionalSound([new InitialConsonantJ()]);\nconst psK = positionalSound([new InitialConsonantK(), new FinalConsonantK(), new GerminatedConsonantK()]);\nconst psL = positionalSound([new InitialConsonantL()]);\nconst psM = positionalSound([new InitialConsonantM()]);\nconst psN = positionalSound([new InitialConsonantN(), new FinalConsonantN()]);\nconst psNg = positionalSound([new InitialConsonantNG()]);\nconst psO = positionalSound([new VowelO()]);\nconst psP = positionalSound([new InitialConsonantP(), new FinalConsonantP(), new GerminatedConsonantP()]);\nconst psR = positionalSound([new InitialConsonantR()]);\nconst psS = positionalSound([new InitialConsonantS(), new FinalConsonantS(), new GerminatedConsonantS()]);\nconst psT = positionalSound([new InitialConsonantT(), new FinalConsonantT(), new GerminatedConsonantT()]);\nconst psU = positionalSound([new VowelU()]);\nconst psV = positionalSound([new InitialConsonantV()]);\nconst psW = positionalSound([new InitialConsonantW(), new SemivowelW()]);\nconst psY = positionalSound([new InitialConsonantY(), new SemivowelY()]);\nconst psZ = positionalSound([new InitialConsonantZ()]);\n//------------------------------------------------------------------------------\nexports.kanaPositionalSound = new Map()\n    .set(KanaLetterTags.a, psA)\n    .set(KanaLetterTags.b, psB)\n    .set(KanaLetterTags.c, psC)\n    .set(KanaLetterTags.ch, psCh)\n    .set(KanaLetterTags.d, psD)\n    .set(KanaLetterTags.e, psE)\n    .set(KanaLetterTags.f, psF)\n    .set(KanaLetterTags.g, psG)\n    .set(KanaLetterTags.h, psH)\n    .set(KanaLetterTags.i, psI)\n    .set(KanaLetterTags.j, psJ)\n    .set(KanaLetterTags.k, psK)\n    .set(KanaLetterTags.l, psL)\n    .set(KanaLetterTags.m, psM)\n    .set(KanaLetterTags.n, psN)\n    .set(KanaLetterTags.ng, psNg)\n    .set(KanaLetterTags.o, psO)\n    .set(KanaLetterTags.p, psP)\n    .set(KanaLetterTags.r, psR)\n    .set(KanaLetterTags.s, psS)\n    .set(KanaLetterTags.t, psT)\n    .set(KanaLetterTags.u, psU)\n    .set(KanaLetterTags.v, psV)\n    .set(KanaLetterTags.w, psW)\n    .set(KanaLetterTags.y, psY)\n    .set(KanaLetterTags.z, psZ);\n//------------------------------------------------------------------------------\nexports.kogakimoji = new Map().set(KanaLetterTags.ch + KanaLetterTags.u, ['っ', 'ッ']);\nexports.hatsuon = new Map().set(KanaLetterTags.n, ['ん', 'ン']);\nexports.others = new Map()\n    .set(KanaLetterTags.a, ['ぁ', 'ァ'])\n    .set(KanaLetterTags.i, ['ぃ', 'ィ'])\n    .set(KanaLetterTags.u, ['ぅ', 'ゥ'])\n    .set(KanaLetterTags.e, ['ぇ', 'ェ'])\n    .set(KanaLetterTags.o, ['ぉ', 'ォ'])\n    .set(KanaLetterTags.h + KanaLetterTags.a, ['', 'ㇵ'])\n    .set(KanaLetterTags.h + KanaLetterTags.i, ['', 'ㇶ'])\n    .set(KanaLetterTags.f + KanaLetterTags.u, ['', 'ㇷ'])\n    .set(KanaLetterTags.h + KanaLetterTags.e, ['', 'ㇸ'])\n    .set(KanaLetterTags.h + KanaLetterTags.o, ['', 'ㇹ'])\n    .set(KanaLetterTags.k + KanaLetterTags.a, ['ゕ', 'ヵ'])\n    .set(KanaLetterTags.k + KanaLetterTags.e, ['ゖ', 'ヶ'])\n    .set(KanaLetterTags.k + KanaLetterTags.u, ['', 'ㇰ'])\n    .set(KanaLetterTags.r + KanaLetterTags.a, ['', 'ㇻ'])\n    .set(KanaLetterTags.r + KanaLetterTags.i, ['', 'ㇼ'])\n    .set(KanaLetterTags.r + KanaLetterTags.u, ['', 'ㇽ'])\n    .set(KanaLetterTags.r + KanaLetterTags.e, ['', 'ㇾ'])\n    .set(KanaLetterTags.r + KanaLetterTags.o, ['', 'ㇿ'])\n    .set(KanaLetterTags.m + KanaLetterTags.u, ['', 'ㇺ'])\n    .set(KanaLetterTags.n + KanaLetterTags.u, ['', 'ㇴ'])\n    .set(KanaLetterTags.p + KanaLetterTags.u, ['', 'ㇷ゚'])\n    .set(KanaLetterTags.s + KanaLetterTags.i, ['', 'ㇱ'])\n    .set(KanaLetterTags.s + KanaLetterTags.u, ['', 'ㇲ'])\n    .set(KanaLetterTags.t + KanaLetterTags.o, ['', 'ㇳ'])\n    .set(KanaLetterTags.y + KanaLetterTags.a, ['ゃ', 'ャ'])\n    .set(KanaLetterTags.y + KanaLetterTags.u, ['ゅ', 'ュ'])\n    .set(KanaLetterTags.y + KanaLetterTags.o, ['ょ', 'ョ'])\n    .set(KanaLetterTags.w + KanaLetterTags.a, ['ゎ', 'ヮ'])\n    .set(KanaLetterTags.z + KanaLetterTags.u, ['づ', 'ヅ']);\nexports.hiraganaKatakana = new Map()\n    .set(KanaLetterTags.a, ['あ', 'ア'])\n    .set(KanaLetterTags.i, ['い', 'イ'])\n    .set(KanaLetterTags.u, ['う', 'ウ'])\n    .set(KanaLetterTags.e, ['え', 'エ'])\n    .set(KanaLetterTags.o, ['お', 'オ'])\n    .set(KanaLetterTags.k + KanaLetterTags.a, ['か', 'カ'])\n    .set(KanaLetterTags.k + KanaLetterTags.i, ['き', 'キ'])\n    .set(KanaLetterTags.k + KanaLetterTags.u, ['く', 'ク'])\n    .set(KanaLetterTags.k + KanaLetterTags.e, ['け', 'ケ'])\n    .set(KanaLetterTags.k + KanaLetterTags.o, ['こ', 'コ'])\n    .set(KanaLetterTags.s + KanaLetterTags.a, ['さ', 'サ'])\n    .set(KanaLetterTags.s + KanaLetterTags.i, ['し', 'シ'])\n    .set(KanaLetterTags.s + KanaLetterTags.u, ['す', 'ス'])\n    .set(KanaLetterTags.s + KanaLetterTags.e, ['せ', 'セ'])\n    .set(KanaLetterTags.s + KanaLetterTags.o, ['そ', 'ソ'])\n    .set(KanaLetterTags.t + KanaLetterTags.a, ['た', 'タ'])\n    .set(KanaLetterTags.c + KanaLetterTags.i, ['ち', 'チ'])\n    .set(KanaLetterTags.ch + KanaLetterTags.u, ['つ', 'ツ'])\n    .set(KanaLetterTags.t + KanaLetterTags.e, ['て', 'テ'])\n    .set(KanaLetterTags.t + KanaLetterTags.o, ['と', 'ト'])\n    .set(KanaLetterTags.n + KanaLetterTags.a, ['な', 'ナ'])\n    .set(KanaLetterTags.n + KanaLetterTags.i, ['に', 'ニ'])\n    .set(KanaLetterTags.n + KanaLetterTags.u, ['ぬ', 'ヌ'])\n    .set(KanaLetterTags.n + KanaLetterTags.e, ['ね', 'ネ'])\n    .set(KanaLetterTags.n + KanaLetterTags.o, ['の', 'ノ'])\n    .set(KanaLetterTags.h + KanaLetterTags.a, ['は', 'ハ'])\n    .set(KanaLetterTags.h + KanaLetterTags.i, ['ひ', 'ヒ'])\n    .set(KanaLetterTags.f + KanaLetterTags.u, ['ふ', 'フ'])\n    .set(KanaLetterTags.h + KanaLetterTags.e, ['へ', 'ヘ'])\n    .set(KanaLetterTags.h + KanaLetterTags.o, ['ほ', 'ホ'])\n    .set(KanaLetterTags.m + KanaLetterTags.a, ['ま', 'マ'])\n    .set(KanaLetterTags.m + KanaLetterTags.i, ['み', 'ミ'])\n    .set(KanaLetterTags.m + KanaLetterTags.u, ['む', 'ム'])\n    .set(KanaLetterTags.m + KanaLetterTags.e, ['め', 'メ'])\n    .set(KanaLetterTags.m + KanaLetterTags.o, ['も', 'モ'])\n    .set(KanaLetterTags.y + KanaLetterTags.a, ['や', 'ヤ'])\n    .set(KanaLetterTags.y + KanaLetterTags.u, ['ゆ', 'ユ'])\n    .set(KanaLetterTags.y + KanaLetterTags.o, ['よ', 'ヨ'])\n    .set(KanaLetterTags.r + KanaLetterTags.a, ['ら', 'ラ'])\n    .set(KanaLetterTags.r + KanaLetterTags.i, ['り', 'リ'])\n    .set(KanaLetterTags.r + KanaLetterTags.u, ['る', 'ル'])\n    .set(KanaLetterTags.r + KanaLetterTags.e, ['れ', 'レ'])\n    .set(KanaLetterTags.r + KanaLetterTags.o, ['ろ', 'ロ'])\n    .set(KanaLetterTags.w + KanaLetterTags.a, ['わ', 'ワ'])\n    .set(KanaLetterTags.w + KanaLetterTags.i, ['ゐ', 'ヰ'])\n    .set(KanaLetterTags.w + KanaLetterTags.e, ['ゑ', 'ヱ'])\n    .set(KanaLetterTags.w + KanaLetterTags.o, ['を', 'ヲ'])\n    .set(KanaLetterTags.g + KanaLetterTags.a, ['が', 'ガ'])\n    .set(KanaLetterTags.g + KanaLetterTags.i, ['ぎ', 'ギ'])\n    .set(KanaLetterTags.g + KanaLetterTags.u, ['ぐ', 'グ'])\n    .set(KanaLetterTags.g + KanaLetterTags.e, ['げ', 'ゲ'])\n    .set(KanaLetterTags.g + KanaLetterTags.o, ['ご', 'ゴ'])\n    .set(KanaLetterTags.z + KanaLetterTags.a, ['ざ', 'ザ'])\n    .set(KanaLetterTags.j + KanaLetterTags.i, ['じ', 'ジ'])\n    .set(KanaLetterTags.z + KanaLetterTags.u, ['ず', 'ズ'])\n    .set(KanaLetterTags.z + KanaLetterTags.e, ['ぜ', 'ゼ'])\n    .set(KanaLetterTags.z + KanaLetterTags.o, ['ぞ', 'ゾ'])\n    .set(KanaLetterTags.d + KanaLetterTags.a, ['だ', 'ダ'])\n    .set(KanaLetterTags.d + KanaLetterTags.e, ['で', 'デ'])\n    .set(KanaLetterTags.d + KanaLetterTags.o, ['ど', 'ド'])\n    .set(KanaLetterTags.b + KanaLetterTags.a, ['ば', 'バ'])\n    .set(KanaLetterTags.b + KanaLetterTags.i, ['び', 'ビ'])\n    .set(KanaLetterTags.b + KanaLetterTags.u, ['ぶ', 'ブ'])\n    .set(KanaLetterTags.b + KanaLetterTags.e, ['べ', 'ベ'])\n    .set(KanaLetterTags.b + KanaLetterTags.o, ['ぼ', 'ボ'])\n    .set(KanaLetterTags.p + KanaLetterTags.a, ['ぱ', 'パ'])\n    .set(KanaLetterTags.p + KanaLetterTags.i, ['ぴ', 'ピ'])\n    .set(KanaLetterTags.p + KanaLetterTags.u, ['ぷ', 'プ'])\n    .set(KanaLetterTags.p + KanaLetterTags.e, ['ぺ', 'ペ'])\n    .set(KanaLetterTags.p + KanaLetterTags.o, ['ぽ', 'ポ'])\n    .set(KanaLetterTags.k + KanaLetterTags.y + KanaLetterTags.a, ['きゃ', 'キャ'])\n    .set(KanaLetterTags.k + KanaLetterTags.y + KanaLetterTags.u, ['きゅ', 'キュ'])\n    .set(KanaLetterTags.k + KanaLetterTags.y + KanaLetterTags.o, ['きょ', 'キョ'])\n    .set(KanaLetterTags.s + KanaLetterTags.y + KanaLetterTags.a, ['しゃ', 'シャ'])\n    .set(KanaLetterTags.s + KanaLetterTags.y + KanaLetterTags.u, ['しゅ', 'シュ'])\n    .set(KanaLetterTags.s + KanaLetterTags.y + KanaLetterTags.o, ['しょ', 'ショ'])\n    .set(KanaLetterTags.c + KanaLetterTags.y + KanaLetterTags.a, ['ちゃ', 'チャ'])\n    .set(KanaLetterTags.c + KanaLetterTags.y + KanaLetterTags.u, ['ちゅ', 'チュ'])\n    .set(KanaLetterTags.c + KanaLetterTags.y + KanaLetterTags.o, ['ちょ', 'チョ'])\n    .set(KanaLetterTags.n + KanaLetterTags.y + KanaLetterTags.a, ['にゃ', 'ニャ'])\n    .set(KanaLetterTags.n + KanaLetterTags.y + KanaLetterTags.u, ['にゅ', 'ニュ'])\n    .set(KanaLetterTags.n + KanaLetterTags.y + KanaLetterTags.o, ['にょ', 'ニョ'])\n    .set(KanaLetterTags.h + KanaLetterTags.y + KanaLetterTags.a, ['ひゃ', 'ヒャ'])\n    .set(KanaLetterTags.h + KanaLetterTags.y + KanaLetterTags.u, ['ひゅ', 'ヒュ'])\n    .set(KanaLetterTags.h + KanaLetterTags.y + KanaLetterTags.o, ['ひょ', 'ヒョ'])\n    .set(KanaLetterTags.m + KanaLetterTags.y + KanaLetterTags.a, ['みゃ', 'ミャ'])\n    .set(KanaLetterTags.m + KanaLetterTags.y + KanaLetterTags.u, ['みゅ', 'みょ'])\n    .set(KanaLetterTags.m + KanaLetterTags.y + KanaLetterTags.o, ['ミュ', 'ミョ'])\n    .set(KanaLetterTags.r + KanaLetterTags.y + KanaLetterTags.a, ['りゃ', 'リャ'])\n    .set(KanaLetterTags.r + KanaLetterTags.y + KanaLetterTags.u, ['りゅ', 'リュ'])\n    .set(KanaLetterTags.r + KanaLetterTags.y + KanaLetterTags.o, ['りょ', 'リョ'])\n    .set(KanaLetterTags.g + KanaLetterTags.y + KanaLetterTags.a, ['ぎゃ', 'ギャ'])\n    .set(KanaLetterTags.g + KanaLetterTags.y + KanaLetterTags.u, ['ぎゅ', 'ギュ'])\n    .set(KanaLetterTags.g + KanaLetterTags.y + KanaLetterTags.o, ['ぎょ', 'ギョ'])\n    .set(KanaLetterTags.j + KanaLetterTags.a, ['じゃ', 'ジャ'])\n    .set(KanaLetterTags.j + KanaLetterTags.u, ['じゅ', 'ジュ'])\n    .set(KanaLetterTags.j + KanaLetterTags.o, ['じょ', 'ジョ'])\n    .set(KanaLetterTags.j + KanaLetterTags.y + KanaLetterTags.a, ['ぢゃ', 'ヂャ'])\n    .set(KanaLetterTags.j + KanaLetterTags.y + KanaLetterTags.u, ['ぢ゙ゅ', 'ヂュ'])\n    .set(KanaLetterTags.j + KanaLetterTags.y + KanaLetterTags.o, ['ぢ゙ょ', 'ヂョ'])\n    .set(KanaLetterTags.b + KanaLetterTags.y + KanaLetterTags.a, ['びゃ', 'ビャ'])\n    .set(KanaLetterTags.b + KanaLetterTags.y + KanaLetterTags.u, ['びゅ', 'ビュ'])\n    .set(KanaLetterTags.b + KanaLetterTags.y + KanaLetterTags.o, ['びょ', 'ビョ'])\n    .set(KanaLetterTags.p + KanaLetterTags.y + KanaLetterTags.a, ['ぴゃ', 'ピャ'])\n    .set(KanaLetterTags.p + KanaLetterTags.y + KanaLetterTags.u, ['ぴゅ', 'ピュ'])\n    .set(KanaLetterTags.p + KanaLetterTags.y + KanaLetterTags.o, ['ぴょ', 'ピョ']);\nexports.gailaigo = new Map()\n    .set(KanaLetterTags.s + KanaLetterTags.i, ['', 'スィ'])\n    .set(KanaLetterTags.s + KanaLetterTags.y + KanaLetterTags.e, ['', 'シェ'])\n    .set(KanaLetterTags.z + KanaLetterTags.i, ['', 'ズィ'])\n    .set(KanaLetterTags.j + KanaLetterTags.e, ['', 'ジェ'])\n    .set(KanaLetterTags.j + KanaLetterTags.w + KanaLetterTags.a, ['', 'ジュァ'])\n    .set(KanaLetterTags.j + KanaLetterTags.w + KanaLetterTags.i, ['', 'ジュィ'])\n    .set(KanaLetterTags.j + KanaLetterTags.w + KanaLetterTags.e, ['', 'ジュェ'])\n    .set(KanaLetterTags.j + KanaLetterTags.w + KanaLetterTags.o, ['', 'ジュォ'])\n    .set(KanaLetterTags.t + KanaLetterTags.i, ['', 'ティ'])\n    .set(KanaLetterTags.t + KanaLetterTags.u, ['', 'トゥ'])\n    .set(KanaLetterTags.c + KanaLetterTags.y + KanaLetterTags.e, ['', 'チェ'])\n    .set(KanaLetterTags.j + KanaLetterTags.y + KanaLetterTags.e, ['', 'ヂェ'])\n    .set(KanaLetterTags.c + KanaLetterTags.w + KanaLetterTags.a, ['', 'チュァ'])\n    .set(KanaLetterTags.c + KanaLetterTags.w + KanaLetterTags.i, ['', 'チュィ'])\n    .set(KanaLetterTags.c + KanaLetterTags.w + KanaLetterTags.e, ['', 'チュェ'])\n    .set(KanaLetterTags.c + KanaLetterTags.w + KanaLetterTags.o, ['', 'チュォ'])\n    .set(KanaLetterTags.ch + KanaLetterTags.a, ['', 'ツァ'])\n    .set(KanaLetterTags.ch + KanaLetterTags.i, ['', 'ツィ'])\n    .set(KanaLetterTags.ch + KanaLetterTags.e, ['', 'ツェ'])\n    .set(KanaLetterTags.ch + KanaLetterTags.o, ['', 'ツォ'])\n    .set(KanaLetterTags.d + KanaLetterTags.i, ['', 'ディ'])\n    .set(KanaLetterTags.d + KanaLetterTags.u, ['', 'ドゥ'])\n    .set(KanaLetterTags.f + KanaLetterTags.a, ['', 'ファ'])\n    .set(KanaLetterTags.f + KanaLetterTags.i, ['', 'フィ'])\n    .set(KanaLetterTags.f + KanaLetterTags.e, ['', 'フェ'])\n    .set(KanaLetterTags.f + KanaLetterTags.o, ['', 'フォ'])\n    .set(KanaLetterTags.y + KanaLetterTags.i, ['', 'イィ'])\n    .set(KanaLetterTags.y + KanaLetterTags.e, ['', 'イェ'])\n    .set(KanaLetterTags.w + KanaLetterTags.a, ['', 'ウァ'])\n    .set(KanaLetterTags.w + KanaLetterTags.a, ['', 'ウィ'])\n    .set(KanaLetterTags.w + KanaLetterTags.a, ['', 'ウェ'])\n    .set(KanaLetterTags.w + KanaLetterTags.a, ['', 'ウォ'])\n    .set(KanaLetterTags.v + KanaLetterTags.a, ['', 'ヴァ'])\n    .set(KanaLetterTags.v + KanaLetterTags.i, ['', 'ヴィ'])\n    .set(KanaLetterTags.v + KanaLetterTags.u, ['', 'ヴ'])\n    .set(KanaLetterTags.v + KanaLetterTags.e, ['', 'ヴェ'])\n    .set(KanaLetterTags.v + KanaLetterTags.o, ['', 'ヴォ']);\nexports.gailaigoY = new Map()\n    .set(KanaLetterTags.k + KanaLetterTags.y + KanaLetterTags.i, ['', 'キィ'])\n    .set(KanaLetterTags.k + KanaLetterTags.y + KanaLetterTags.e, ['', 'キェ'])\n    .set(KanaLetterTags.g + KanaLetterTags.y + KanaLetterTags.i, ['', 'ギィ'])\n    .set(KanaLetterTags.g + KanaLetterTags.y + KanaLetterTags.e, ['', 'ギェ'])\n    .set(KanaLetterTags.s + KanaLetterTags.y + KanaLetterTags.a, ['', 'スャ'])\n    .set(KanaLetterTags.s + KanaLetterTags.y + KanaLetterTags.u, ['', 'スュ'])\n    .set(KanaLetterTags.s + KanaLetterTags.y + KanaLetterTags.e, ['', 'スィェ'])\n    .set(KanaLetterTags.s + KanaLetterTags.y + KanaLetterTags.o, ['', 'スョ'])\n    .set(KanaLetterTags.z + KanaLetterTags.y + KanaLetterTags.a, ['', 'ズャ'])\n    .set(KanaLetterTags.z + KanaLetterTags.y + KanaLetterTags.u, ['', 'ズュ'])\n    .set(KanaLetterTags.z + KanaLetterTags.y + KanaLetterTags.e, ['', 'ズィェ'])\n    .set(KanaLetterTags.z + KanaLetterTags.y + KanaLetterTags.o, ['', 'ズョ'])\n    .set(KanaLetterTags.t + KanaLetterTags.y + KanaLetterTags.a, ['', 'テャ'])\n    .set(KanaLetterTags.t + KanaLetterTags.y + KanaLetterTags.u, ['', 'テュ'])\n    .set(KanaLetterTags.t + KanaLetterTags.y + KanaLetterTags.e, ['', 'ティェ'])\n    .set(KanaLetterTags.t + KanaLetterTags.y + KanaLetterTags.o, ['', 'テョ'])\n    .set(KanaLetterTags.d + KanaLetterTags.y + KanaLetterTags.a, ['', 'デャ'])\n    .set(KanaLetterTags.d + KanaLetterTags.y + KanaLetterTags.u, ['', 'デュ'])\n    .set(KanaLetterTags.d + KanaLetterTags.y + KanaLetterTags.e, ['', 'デェ', 'ディェ'])\n    .set(KanaLetterTags.d + KanaLetterTags.y + KanaLetterTags.o, ['', 'デョ'])\n    .set(KanaLetterTags.n + KanaLetterTags.y + KanaLetterTags.i, ['', 'ニィ'])\n    .set(KanaLetterTags.n + KanaLetterTags.y + KanaLetterTags.e, ['', 'ニェ'])\n    .set(KanaLetterTags.h + KanaLetterTags.y + KanaLetterTags.i, ['', 'ヒィ'])\n    .set(KanaLetterTags.h + KanaLetterTags.y + KanaLetterTags.e, ['', 'ヒェ'])\n    .set(KanaLetterTags.f + KanaLetterTags.y + KanaLetterTags.a, ['', 'フャ'])\n    .set(KanaLetterTags.f + KanaLetterTags.y + KanaLetterTags.u, ['', 'フュ'])\n    .set(KanaLetterTags.f + KanaLetterTags.y + KanaLetterTags.e, ['', 'フィェ'])\n    .set(KanaLetterTags.f + KanaLetterTags.y + KanaLetterTags.o, ['', 'フョ'])\n    .set(KanaLetterTags.b + KanaLetterTags.y + KanaLetterTags.e, ['', 'ビェ'])\n    .set(KanaLetterTags.p + KanaLetterTags.y + KanaLetterTags.e, ['', 'ピェ'])\n    .set(KanaLetterTags.m + KanaLetterTags.y + KanaLetterTags.i, ['', 'ミィ'])\n    .set(KanaLetterTags.m + KanaLetterTags.y + KanaLetterTags.e, ['', 'ミェ'])\n    .set(KanaLetterTags.r + KanaLetterTags.y + KanaLetterTags.i, ['', 'リィ'])\n    .set(KanaLetterTags.r + KanaLetterTags.y + KanaLetterTags.e, ['', 'リェ'])\n    .set(KanaLetterTags.w + KanaLetterTags.y + KanaLetterTags.a, ['', 'ウャ'])\n    .set(KanaLetterTags.w + KanaLetterTags.y + KanaLetterTags.u, ['', 'ウュ'])\n    .set(KanaLetterTags.w + KanaLetterTags.y + KanaLetterTags.o, ['', 'ウョ'])\n    .set(KanaLetterTags.v + KanaLetterTags.y + KanaLetterTags.a, ['', 'ヴャ'])\n    .set(KanaLetterTags.v + KanaLetterTags.y + KanaLetterTags.u, ['', 'ヴュ'])\n    .set(KanaLetterTags.v + KanaLetterTags.y + KanaLetterTags.e, ['', 'ヴィェ'])\n    .set(KanaLetterTags.v + KanaLetterTags.y + KanaLetterTags.o, ['', 'ヴョ']);\nexports.gailaigoW = new Map()\n    .set(KanaLetterTags.k + KanaLetterTags.w + KanaLetterTags.a, ['', 'クァ'])\n    .set(KanaLetterTags.k + KanaLetterTags.w + KanaLetterTags.i, ['', 'クィ'])\n    .set(KanaLetterTags.k + KanaLetterTags.w + KanaLetterTags.u, ['', 'クゥ'])\n    .set(KanaLetterTags.k + KanaLetterTags.w + KanaLetterTags.e, ['', 'クェ'])\n    .set(KanaLetterTags.k + KanaLetterTags.w + KanaLetterTags.o, ['', 'クォ'])\n    .set(KanaLetterTags.g + KanaLetterTags.w + KanaLetterTags.a, ['', 'グァ'])\n    .set(KanaLetterTags.g + KanaLetterTags.w + KanaLetterTags.i, ['', 'グィ'])\n    .set(KanaLetterTags.g + KanaLetterTags.w + KanaLetterTags.u, ['', 'グゥ'])\n    .set(KanaLetterTags.g + KanaLetterTags.w + KanaLetterTags.e, ['', 'グェ'])\n    .set(KanaLetterTags.g + KanaLetterTags.w + KanaLetterTags.o, ['', 'グォ'])\n    .set(KanaLetterTags.s + KanaLetterTags.w + KanaLetterTags.a, ['', 'スァ'])\n    .set(KanaLetterTags.s + KanaLetterTags.w + KanaLetterTags.i, ['', 'スゥィ'])\n    .set(KanaLetterTags.s + KanaLetterTags.w + KanaLetterTags.e, ['', 'スェ'])\n    .set(KanaLetterTags.s + KanaLetterTags.w + KanaLetterTags.o, ['', 'スォ'])\n    .set(KanaLetterTags.z + KanaLetterTags.w + KanaLetterTags.e, ['', 'ズェ'])\n    .set(KanaLetterTags.t + KanaLetterTags.w + KanaLetterTags.a, ['', 'トァ'])\n    .set(KanaLetterTags.t + KanaLetterTags.w + KanaLetterTags.i, ['', 'トィ'])\n    .set(KanaLetterTags.t + KanaLetterTags.w + KanaLetterTags.e, ['', 'トェ'])\n    .set(KanaLetterTags.t + KanaLetterTags.w + KanaLetterTags.o, ['', 'トォ'])\n    .set(KanaLetterTags.d + KanaLetterTags.w + KanaLetterTags.a, ['', 'ドァ'])\n    .set(KanaLetterTags.d + KanaLetterTags.w + KanaLetterTags.i, ['', 'ドィ'])\n    .set(KanaLetterTags.d + KanaLetterTags.w + KanaLetterTags.e, ['', 'ドェ'])\n    .set(KanaLetterTags.d + KanaLetterTags.w + KanaLetterTags.o, ['', 'ドォ'])\n    .set(KanaLetterTags.n + KanaLetterTags.w + KanaLetterTags.a, ['', 'ヌァ'])\n    .set(KanaLetterTags.n + KanaLetterTags.w + KanaLetterTags.i, ['', 'ヌィ'])\n    .set(KanaLetterTags.n + KanaLetterTags.w + KanaLetterTags.e, ['', 'ヌェ'])\n    .set(KanaLetterTags.n + KanaLetterTags.w + KanaLetterTags.o, ['', 'ヌォ'])\n    .set(KanaLetterTags.b + KanaLetterTags.w + KanaLetterTags.a, ['', 'ブァ'])\n    .set(KanaLetterTags.b + KanaLetterTags.w + KanaLetterTags.i, ['', 'ブィ'])\n    .set(KanaLetterTags.b + KanaLetterTags.w + KanaLetterTags.e, ['', 'ブェ'])\n    .set(KanaLetterTags.b + KanaLetterTags.w + KanaLetterTags.o, ['', 'ブォ'])\n    .set(KanaLetterTags.p + KanaLetterTags.w + KanaLetterTags.a, ['', 'プァ'])\n    .set(KanaLetterTags.p + KanaLetterTags.w + KanaLetterTags.i, ['', 'プィ'])\n    .set(KanaLetterTags.p + KanaLetterTags.w + KanaLetterTags.e, ['', 'プェ'])\n    .set(KanaLetterTags.p + KanaLetterTags.w + KanaLetterTags.o, ['', 'プォ'])\n    .set(KanaLetterTags.m + KanaLetterTags.w + KanaLetterTags.a, ['', 'ムァ'])\n    .set(KanaLetterTags.m + KanaLetterTags.w + KanaLetterTags.i, ['', 'ムィ'])\n    .set(KanaLetterTags.m + KanaLetterTags.w + KanaLetterTags.e, ['', 'ムェ'])\n    .set(KanaLetterTags.m + KanaLetterTags.w + KanaLetterTags.o, ['', 'ムォ'])\n    .set(KanaLetterTags.r + KanaLetterTags.w + KanaLetterTags.a, ['', 'ルァ'])\n    .set(KanaLetterTags.r + KanaLetterTags.w + KanaLetterTags.i, ['', 'ルィ'])\n    .set(KanaLetterTags.r + KanaLetterTags.w + KanaLetterTags.e, ['', 'ルェ'])\n    .set(KanaLetterTags.r + KanaLetterTags.w + KanaLetterTags.o, ['', 'ルォ']);\nexports.special = new Map()\n    .set(KanaLetterTags.ng + KanaLetterTags.a, ['', 'カ゚'])\n    .set(KanaLetterTags.ng + KanaLetterTags.i, ['', 'キ゚'])\n    .set(KanaLetterTags.ng + KanaLetterTags.u, ['', 'ク゚'])\n    .set(KanaLetterTags.ng + KanaLetterTags.e, ['', 'ケ゚'])\n    .set(KanaLetterTags.ng + KanaLetterTags.o, ['', 'コ゚'])\n    .set(KanaLetterTags.s + KanaLetterTags.i, ['', 'セィ'])\n    .set(KanaLetterTags.z + KanaLetterTags.i, ['', 'ゼィ'])\n    .set(KanaLetterTags.s + KanaLetterTags.y + KanaLetterTags.i, ['', 'シィ'])\n    .set(KanaLetterTags.j + KanaLetterTags.i, ['', 'ジィ'])\n    .set(KanaLetterTags.c + KanaLetterTags.y + KanaLetterTags.i, ['', 'チィ'])\n    .set(KanaLetterTags.ch + KanaLetterTags.u, ['', 'ツゥ'])\n    .set(KanaLetterTags.j + KanaLetterTags.y + KanaLetterTags.i, ['', 'ヂィ'])\n    .set(KanaLetterTags.h + KanaLetterTags.u, ['', 'ホゥ'])\n    .set(KanaLetterTags.f + KanaLetterTags.u, ['', 'フゥ'])\n    .set(KanaLetterTags.y + KanaLetterTags.e, ['', 'ユェ'])\n    .set(KanaLetterTags.l + KanaLetterTags.a, ['', 'ラ゚'])\n    .set(KanaLetterTags.l + KanaLetterTags.i, ['', 'リ゚'])\n    .set(KanaLetterTags.l + KanaLetterTags.u, ['', 'ル゚'])\n    .set(KanaLetterTags.l + KanaLetterTags.e, ['', 'レ゚'])\n    .set(KanaLetterTags.l + KanaLetterTags.o, ['', 'ロ゚'])\n    .set(KanaLetterTags.w + KanaLetterTags.u, ['', 'ウゥ'])\n    .set(KanaLetterTags.v + KanaLetterTags.a, ['', 'ヷ'])\n    .set(KanaLetterTags.v + KanaLetterTags.i, ['', 'ヸ'])\n    .set(KanaLetterTags.v + KanaLetterTags.e, ['', 'ヹ'])\n    .set(KanaLetterTags.v + KanaLetterTags.o, ['', 'ヺ']);\nexports.specialY = new Map()\n    .set(KanaLetterTags.ng + KanaLetterTags.y + KanaLetterTags.a, ['', 'キ゚ャ'])\n    .set(KanaLetterTags.ng + KanaLetterTags.y + KanaLetterTags.u, ['', 'キ゚ュ'])\n    .set(KanaLetterTags.ng + KanaLetterTags.y + KanaLetterTags.o, ['', 'キ゚ョ'])\n    .set(KanaLetterTags.t + KanaLetterTags.y + KanaLetterTags.e, ['', 'テェ'])\n    .set(KanaLetterTags.ch + KanaLetterTags.y + KanaLetterTags.a, ['', 'ツャ'])\n    .set(KanaLetterTags.ch + KanaLetterTags.y + KanaLetterTags.u, ['', 'ツュ'])\n    .set(KanaLetterTags.ch + KanaLetterTags.y + KanaLetterTags.o, ['', 'ツョ'])\n    .set(KanaLetterTags.b + KanaLetterTags.y + KanaLetterTags.i, ['', 'ビィ'])\n    .set(KanaLetterTags.p + KanaLetterTags.y + KanaLetterTags.i, ['', 'ピィ'])\n    .set(KanaLetterTags.l + KanaLetterTags.y + KanaLetterTags.a, ['', 'リ゚ャ'])\n    .set(KanaLetterTags.l + KanaLetterTags.y + KanaLetterTags.u, ['', 'リ゚ュ'])\n    .set(KanaLetterTags.l + KanaLetterTags.y + KanaLetterTags.o, ['', 'リ゚ョ'])\n    .set(KanaLetterTags.w + KanaLetterTags.y + KanaLetterTags.a, ['', 'ヰャ'])\n    .set(KanaLetterTags.w + KanaLetterTags.y + KanaLetterTags.u, ['', 'ヰュ'])\n    .set(KanaLetterTags.w + KanaLetterTags.y + KanaLetterTags.o, ['', 'ヰョ']);\nexports.specialW = new Map()\n    .set(KanaLetterTags.k + KanaLetterTags.w + KanaLetterTags.a, ['', 'クヮ'])\n    .set(KanaLetterTags.g + KanaLetterTags.w + KanaLetterTags.a, ['', 'グヮ'])\n    .set(KanaLetterTags.s + KanaLetterTags.w + KanaLetterTags.u, ['', 'スゥ'])\n    .set(KanaLetterTags.z + KanaLetterTags.w + KanaLetterTags.a, ['', 'ズァ'])\n    .set(KanaLetterTags.z + KanaLetterTags.w + KanaLetterTags.i, ['', 'ズゥィ'])\n    .set(KanaLetterTags.z + KanaLetterTags.w + KanaLetterTags.e, ['', 'ズゥ'])\n    .set(KanaLetterTags.z + KanaLetterTags.w + KanaLetterTags.o, ['', 'ズォ'])\n    .set(KanaLetterTags.t + KanaLetterTags.w + KanaLetterTags.a, ['', 'トゥァ'])\n    .set(KanaLetterTags.t + KanaLetterTags.w + KanaLetterTags.i, ['', 'トゥィ'])\n    .set(KanaLetterTags.t + KanaLetterTags.w + KanaLetterTags.u, ['', 'トゥゥ'])\n    .set(KanaLetterTags.t + KanaLetterTags.w + KanaLetterTags.e, ['', 'トゥェ'])\n    .set(KanaLetterTags.t + KanaLetterTags.w + KanaLetterTags.o, ['', 'トゥォ'])\n    .set(KanaLetterTags.d + KanaLetterTags.w + KanaLetterTags.a, ['', 'ドゥァ'])\n    .set(KanaLetterTags.d + KanaLetterTags.w + KanaLetterTags.i, ['', 'ドゥィ'])\n    .set(KanaLetterTags.d + KanaLetterTags.w + KanaLetterTags.u, ['', 'ドゥゥ'])\n    .set(KanaLetterTags.d + KanaLetterTags.w + KanaLetterTags.e, ['', 'ドゥェ'])\n    .set(KanaLetterTags.d + KanaLetterTags.w + KanaLetterTags.o, ['', 'ドゥォ'])\n    .set(KanaLetterTags.n + KanaLetterTags.w + KanaLetterTags.u, ['', 'ヌゥ'])\n    .set(KanaLetterTags.h + KanaLetterTags.w + KanaLetterTags.a, ['', 'ホゥァ'])\n    .set(KanaLetterTags.h + KanaLetterTags.w + KanaLetterTags.i, ['', 'ホゥィ'])\n    .set(KanaLetterTags.h + KanaLetterTags.w + KanaLetterTags.u, ['', 'ホゥゥ'])\n    .set(KanaLetterTags.h + KanaLetterTags.w + KanaLetterTags.e, ['', 'ホゥェ'])\n    .set(KanaLetterTags.h + KanaLetterTags.w + KanaLetterTags.o, ['', 'ホゥォ'])\n    .set(KanaLetterTags.b + KanaLetterTags.w + KanaLetterTags.u, ['', 'ブゥ'])\n    .set(KanaLetterTags.p + KanaLetterTags.w + KanaLetterTags.u, ['', 'プゥ'])\n    .set(KanaLetterTags.m + KanaLetterTags.w + KanaLetterTags.u, ['', 'ムゥ'])\n    .set(KanaLetterTags.v + KanaLetterTags.w + KanaLetterTags.a, ['', 'ヴゥァ'])\n    .set(KanaLetterTags.v + KanaLetterTags.w + KanaLetterTags.i, ['', 'ヴゥィ'])\n    .set(KanaLetterTags.v + KanaLetterTags.w + KanaLetterTags.u, ['', 'ヴゥゥ'])\n    .set(KanaLetterTags.v + KanaLetterTags.w + KanaLetterTags.e, ['', 'ヴゥェ'])\n    .set(KanaLetterTags.v + KanaLetterTags.w + KanaLetterTags.o, ['', 'ヴゥォ']);\nexports.specialH = new Map()\n    .set(KanaLetterTags.t + KanaLetterTags.h + KanaLetterTags.a, ['', 'テァ'])\n    .set(KanaLetterTags.t + KanaLetterTags.h + KanaLetterTags.u, ['', 'テゥ'])\n    .set(KanaLetterTags.t + KanaLetterTags.h + KanaLetterTags.o, ['', 'テォ'])\n    .set(KanaLetterTags.d + KanaLetterTags.h + KanaLetterTags.a, ['', 'デァ'])\n    .set(KanaLetterTags.d + KanaLetterTags.h + KanaLetterTags.u, ['', 'デゥ'])\n    .set(KanaLetterTags.d + KanaLetterTags.h + KanaLetterTags.o, ['', 'デォ']);\n//# sourceMappingURL=kana.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst morpheme_1 = require(\"../morpheme\");\nconst morpheme_2 = require(\"../morpheme\");\nconst kana_1 = require(\"./kana\");\nconst soundgen_1 = require(\"./soundgen\");\n//------------------------------------------------------------------------------\nclass KanaSyllable extends morpheme_1.Syllable {\n}\nexports.KanaSyllable = KanaSyllable;\n//------------------------------------------------------------------------------\nclass KanaUncombiningMorpheme extends morpheme_1.Morpheme {\n    constructor(syllable, sounds, kcm) {\n        super();\n        this.syllable = syllable;\n        this.metaplasm = kcm;\n        this.sounds = new Array();\n        this.sounds = sounds;\n    }\n}\nexports.KanaUncombiningMorpheme = KanaUncombiningMorpheme;\n//------------------------------------------------------------------------------\nfunction syllabifyKana(letters, beginOfSyllable) {\n    let literal = '';\n    let matched = '';\n    let lookahead = '';\n    let ltrs = new Array();\n    let matchedLtrs = new Array();\n    const sov = new kana_1.VowelSet();\n    for (let i = beginOfSyllable; i < letters.length; i++) {\n        literal = literal + letters[i].literal;\n        ltrs.push(letters[i].literal);\n        if (kana_1.hiraganaKatakana.has(literal) || kana_1.gailaigo.has(literal)) {\n            matched = literal;\n            Object.assign(matchedLtrs, ltrs);\n            if (i + 1 < letters.length)\n                lookahead = letters[i + 1].literal; // look-ahead\n        }\n        else {\n            if (literal.length == 3 && literal[0] === literal[1] && sov.includes(literal[2])) {\n                // for consonant germination of sokuon\n                matched = literal;\n                ltrs.shift(); // shift the germinated consonants\n                Object.assign(matchedLtrs, ltrs);\n            }\n        }\n    }\n    let list = new Array();\n    if (matched.length > 0) {\n        //console.log(matchedLtrs, lookahead)\n        const ksg = new soundgen_1.KanaSoundGenerator();\n        list = ksg.generate(matchedLtrs, lookahead);\n        // console.log(list)\n    }\n    let arraysOfLetters = new Array();\n    let mp = new morpheme_1.MatchedPattern();\n    let sounds = new Array();\n    for (let m in list) {\n        let min = Math.min(letters.length - beginOfSyllable, list[m].length);\n        if (list[m].length == min) {\n            for (let n = 0; n < min; n++) {\n                if (list[m][n] != undefined) {\n                    if (letters[beginOfSyllable + n].literal === list[m][n].toString()) {\n                        if (n + 1 == min) {\n                            // copy the matched letters\n                            let arr = new Array();\n                            for (let q = 0; q < min; q++) {\n                                arr[q] = letters[beginOfSyllable + q];\n                            }\n                            arraysOfLetters.push(arr);\n                            sounds = list[m];\n                        }\n                    }\n                    else {\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    if (arraysOfLetters.length == 1) {\n        // only one matched\n        // copy the matched letters\n        for (let q = 0; q < arraysOfLetters[0].length; q++) {\n            mp.letters[q] = letters[beginOfSyllable + q];\n            mp.pattern[q] = sounds[q];\n        }\n        return mp;\n    }\n    if (arraysOfLetters.length > 1) {\n        let longerEntry = -1; // length of the longest matched entry\n        let shorterEntry = -1;\n        let index = 0;\n        for (let j = 0; j < arraysOfLetters.length; j++) {\n            if (arraysOfLetters[j].length > arraysOfLetters[index].length) {\n                index = j;\n            }\n        }\n        if (index > 0) {\n            longerEntry = index;\n            shorterEntry = 0;\n        }\n        else {\n            longerEntry = 0;\n            shorterEntry = 1;\n        }\n        if (letters.length - beginOfSyllable == arraysOfLetters[longerEntry].length) {\n            if (new kana_1.Hatsuon().includes(arraysOfLetters[longerEntry][arraysOfLetters[longerEntry].length - 1].literal)) {\n                // return the longer one\n                for (let q = 0; q < arraysOfLetters[longerEntry].length; q++) {\n                    mp.letters[q] = letters[beginOfSyllable + q];\n                    mp.pattern[q] = sounds[q];\n                }\n                return mp;\n            }\n            // return the shorter one\n            for (let q = 0; q < arraysOfLetters[shorterEntry].length; q++) {\n                mp.letters[q] = letters[beginOfSyllable + q];\n                mp.pattern[q] = sounds[q];\n            }\n            return mp;\n        }\n        // look ahead for 1 letter\n        if (letters.length - beginOfSyllable == arraysOfLetters[longerEntry].length + 1) {\n            if (new kana_1.InitialConsonantSet().includes(letters[beginOfSyllable + arraysOfLetters[longerEntry].length].literal) == true) {\n                // consonant-ending\n                // return the longer one\n                for (let q = 0; q < arraysOfLetters[longerEntry].length; q++) {\n                    mp.letters[q] = letters[beginOfSyllable + q];\n                    mp.pattern[q] = sounds[q];\n                }\n            }\n            else {\n                // vowel ending\n                // return the shorter one\n                for (let q = 0; q < arraysOfLetters[shorterEntry].length; q++) {\n                    mp.letters[q] = letters[beginOfSyllable + q];\n                    mp.pattern[q] = sounds[q];\n                }\n            }\n            return mp;\n        }\n        // look ahead for 2 letters\n        if (letters.length - beginOfSyllable > arraysOfLetters[longerEntry].length + 1) {\n            if (new kana_1.VowelSet().includes(letters[beginOfSyllable + arraysOfLetters[longerEntry].length].literal) ==\n                true ||\n                new kana_1.SemivowelSet().includes(letters[beginOfSyllable + arraysOfLetters[longerEntry].length].literal) ==\n                    true) {\n                // return the shorter one\n                for (let q = 0; q < arraysOfLetters[shorterEntry].length; q++) {\n                    mp.letters[q] = letters[beginOfSyllable + q];\n                    mp.pattern[q] = sounds[q];\n                }\n                return mp;\n            }\n            // return the longer one\n            for (let q = 0; q < arraysOfLetters[longerEntry].length; q++) {\n                mp.letters[q] = letters[beginOfSyllable + q];\n                mp.pattern[q] = sounds[q];\n            }\n        }\n    }\n    return mp;\n}\n//------------------------------------------------------------------------------\nclass KanaUncombiningMorphemeMaker extends morpheme_2.MorphemeMaker {\n    constructor(kcm) {\n        super();\n        this.metaplasm = kcm;\n    }\n    createMorphemes() {\n        return new Array();\n    }\n    createMorpheme(msp) {\n        return new KanaUncombiningMorpheme(new KanaSyllable(msp.letters), msp.pattern, this.metaplasm);\n    }\n    postprocess(patterns) {\n        let morphemes = this.createMorphemes();\n        for (let i in patterns) {\n            morphemes.push(this.createMorpheme(patterns[i]));\n        }\n        return morphemes;\n    }\n    makeInputingMorphemes(gs) {\n        const ltrs = gs.map(it => it.letter);\n        const ptrns = this.make(ltrs, syllabifyKana);\n        const ms = this.postprocess(ptrns);\n        return ms;\n    }\n}\nexports.KanaUncombiningMorphemeMaker = KanaUncombiningMorphemeMaker;\n//# sourceMappingURL=morpheme.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst grapheme_1 = require(\"../grapheme\");\nconst kana_1 = require(\"./kana\");\nfunction initialConsonant(sg) {\n    const sics = new kana_1.InitialConsonantSet();\n    if (sics.includes(sg.letters[sg.sounds.length])) {\n        const ps = kana_1.kanaPositionalSound.get(sg.letters[sg.sounds.length]);\n        if (ps) {\n            const s = ps(kana_1.KanaSoundTags.initialConsonant);\n            if (s)\n                sg.sounds.push(s);\n        }\n    }\n    else\n        sg.matching = false;\n    return sg;\n}\nfunction semivowel(sg) {\n    const ssvs = new kana_1.SemivowelSet();\n    if (ssvs.includes(sg.letters[sg.sounds.length])) {\n        const ps = kana_1.kanaPositionalSound.get(sg.letters[sg.sounds.length]);\n        if (ps) {\n            const s = ps(kana_1.KanaSoundTags.semivowel);\n            if (s)\n                sg.sounds.push(s);\n        }\n    }\n    return sg;\n}\nfunction vowel(sg) {\n    const svs = new kana_1.VowelSet();\n    if (svs.includes(sg.letters[sg.sounds.length])) {\n        const ps = kana_1.kanaPositionalSound.get(sg.letters[sg.sounds.length]);\n        if (ps) {\n            const s = ps(kana_1.KanaSoundTags.vowel);\n            if (s)\n                sg.sounds.push(s);\n        }\n    }\n    return sg;\n}\nfunction finalConsonant(sg) {\n    const sfcs = new kana_1.FinalConsonantSet();\n    if (sfcs.includes(sg.letters[sg.sounds.length])) {\n        const ps = kana_1.kanaPositionalSound.get(sg.letters[sg.sounds.length]);\n        if (ps) {\n            const s = ps(kana_1.KanaSoundTags.finalConsonant);\n            if (s)\n                sg.sounds.push(s);\n        }\n    }\n    return sg;\n}\nfunction germinatedConsonant(sg) {\n    const sgcs = new kana_1.GerminatedConsonantSet();\n    if (sgcs.includes(sg.letters[sg.sounds.length])) {\n        const ps = kana_1.kanaPositionalSound.get(sg.letters[sg.sounds.length]);\n        if (ps) {\n            const s = ps(kana_1.KanaSoundTags.germinatedConsonant);\n            if (s)\n                sg.sounds.push(s);\n        }\n    }\n    return sg;\n}\nconst scV = grapheme_1.pipe(vowel);\nconst scCV = grapheme_1.pipe(initialConsonant, vowel);\nconst scCVC = grapheme_1.pipe(initialConsonant, vowel, finalConsonant);\nconst scCSV = grapheme_1.pipe(initialConsonant, semivowel, vowel);\nconst scCCV = grapheme_1.pipe(germinatedConsonant, initialConsonant, vowel);\nclass KanaSoundGenerator {\n    constructor() {\n        this.sylCompositions = [scV, scCV, scCVC, scCSV, scCCV];\n    }\n    genSokuonAndGerminated(letters, lookahead) {\n        let strs = new Array();\n        strs.push(letters);\n        // consonant germination\n        if (new kana_1.GerminatedConsonantSet().includes(letters[0]) == true) {\n            let syl = new Array();\n            syl.push(letters[0].charAt(0));\n            for (let e of letters) {\n                syl.push(e);\n            }\n            strs.push(syl);\n        }\n        // sokuon\n        let fcs = new kana_1.FinalConsonantSet();\n        for (let e of fcs.sounds) {\n            let syl = new Array();\n            Object.assign(syl, letters);\n            syl.push(e.toString());\n            if (e.toString() === lookahead)\n                strs.push(syl);\n        }\n        return strs;\n    }\n    generate(letters, lookahead) {\n        let strs = new Array();\n        let sequences = new Array(); // to be returned\n        strs = this.genSokuonAndGerminated(letters, lookahead);\n        //console.log(strs)\n        for (let i in strs) {\n            // generates all needed sounds to be processed\n            for (let j = 0; j < this.sylCompositions.length; j++) {\n                let sg = new grapheme_1.SoundGeneration();\n                sg.letters = strs[i];\n                //console.log(`j: ${j}`)\n                sg = this.sylCompositions[j](sg);\n                if (sg.letters.length == sg.sounds.length && sg.matching == true) {\n                    sequences.push(sg.sounds);\n                    break;\n                }\n            }\n        }\n        //console.log(sequences)\n        return sequences;\n    }\n}\nexports.KanaSoundGenerator = KanaSoundGenerator;\n//# sourceMappingURL=soundgen.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//------------------------------------------------------------------------------\nclass Metaplasm {\n}\nexports.Metaplasm = Metaplasm;\nclass TonalInflectionMetaplasm extends Metaplasm {\n    apply(morphemes) {\n        return [];\n    }\n}\nexports.TonalInflectionMetaplasm = TonalInflectionMetaplasm;\nclass TonalZeroInflection extends TonalInflectionMetaplasm {\n}\nexports.TonalZeroInflection = TonalZeroInflection;\nclass TonalAssimilationMetaplasm extends Metaplasm {\n    apply(morphemes) {\n        return [];\n    }\n}\nexports.TonalAssimilationMetaplasm = TonalAssimilationMetaplasm;\nclass TonalLemmatizationMetaplasm extends Metaplasm {\n    apply(morphemes, inflectionalEnding) { }\n}\nexports.TonalLemmatizationMetaplasm = TonalLemmatizationMetaplasm;\n//------------------------------------------------------------------------------\nclass Lexeme {\n}\nexports.Lexeme = Lexeme;\n//------------------------------------------------------------------------------\nclass Word {\n    constructor(syllables) {\n        this.literal = '';\n        if (syllables) {\n            this.syllables = syllables;\n        }\n        else {\n            this.syllables = new Array();\n        }\n    }\n    popSyllable() {\n        this.syllables = this.syllables.slice(0, this.syllables.length - 1);\n        this.concat();\n    }\n    pushSyllable(syl) {\n        this.syllables.push(syl);\n        this.concat();\n    }\n    replaceSyllable(i, syl) {\n        if (i < this.syllables.length) {\n            this.syllables.splice(i, 1, syl);\n        }\n        this.concat();\n    }\n    concat() {\n        this.literal = this.syllables.map(x => (x ? x.literal : '')).join('');\n    }\n}\nexports.Word = Word;\n//------------------------------------------------------------------------------\nclass LexemeMaker {\n}\nexports.LexemeMaker = LexemeMaker;\n//# sourceMappingURL=lexeme.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst grapheme_1 = require(\"./grapheme\");\nclass CombiningMetaplasm {\n}\nexports.CombiningMetaplasm = CombiningMetaplasm;\nclass TonalCombiningMetaplasm extends CombiningMetaplasm {\n    apply(sounds, allomorph) {\n        return [];\n    }\n}\nexports.TonalCombiningMetaplasm = TonalCombiningMetaplasm;\nclass TonalZeroCombining extends TonalCombiningMetaplasm {\n}\nexports.TonalZeroCombining = TonalZeroCombining;\nclass RemovingEpenthesisOfAy extends TonalCombiningMetaplasm {\n    applyToLetters(letters) {\n        letters.shift();\n        return letters;\n    }\n    applyToString(str) {\n        return str.slice(1, 2);\n    }\n}\nexports.RemovingEpenthesisOfAy = RemovingEpenthesisOfAy;\nclass RemovingNasalizationOfAy extends TonalCombiningMetaplasm {\n}\nexports.RemovingNasalizationOfAy = RemovingNasalizationOfAy;\nclass KanaCombiningMetaplasm extends CombiningMetaplasm {\n}\nexports.KanaCombiningMetaplasm = KanaCombiningMetaplasm;\n//------------------------------------------------------------------------------\nclass Morpheme {\n}\nexports.Morpheme = Morpheme;\n//------------------------------------------------------------------------------\nclass MatchedPattern {\n    constructor() {\n        this.letters = new Array();\n        this.pattern = new Array();\n    }\n    get matchedLength() {\n        return this.letters.length;\n    } // length of pattern can be optionally returned\n    get lastLetter() {\n        if (this.letters.length > 0)\n            return this.letters[this.letters.length - 1];\n        return new grapheme_1.AlphabeticLetter([]);\n    }\n    get lastSecondLetter() {\n        if (this.letters.length > 1)\n            return this.letters[this.letters.length - 2];\n        return new grapheme_1.AlphabeticLetter([]);\n    }\n}\nexports.MatchedPattern = MatchedPattern;\n//------------------------------------------------------------------------------\nclass Syllable {\n    constructor(letters) {\n        this.literal = '';\n        this.letters = new Array();\n        if (letters) {\n            const len = letters.length;\n            for (let i = 0; i < len; i++) {\n                this.pushLetter(letters[i]);\n            }\n        }\n    }\n    pushLetter(l) {\n        this.letters.push(l);\n        this.concat();\n    }\n    replaceLetter(i, l) {\n        this.letters.splice(i, 1, l);\n        this.concat();\n    }\n    insertLetter(i, l) {\n        this.letters.splice(i, 0, l);\n        this.concat();\n    }\n    concat() {\n        this.literal = this.letters.map(x => (x ? x.literal : '')).join('');\n    }\n}\nexports.Syllable = Syllable;\n//------------------------------------------------------------------------------\nclass MorphemeMaker {\n    make(letters, syllabify) {\n        let patterns = new Array();\n        let beginOfSyllable = 0;\n        for (let i = 0; i < letters.length; i++) {\n            let msp = new MatchedPattern();\n            if (i - beginOfSyllable == 0) {\n                msp = syllabify(letters, beginOfSyllable);\n                if (msp.matchedLength == 0) {\n                    //console.log('no matched syllables found. the syllable might need to be added')\n                }\n                //console.log(\"matchedLen: %d\", msp.matchedLength);\n                //console.log(msp.pattern);\n                //console.log(msp.letters)\n                if (msp.letters.length > 0) {\n                    for (let j in msp.letters) {\n                        //console.log(\"msp.letters: %s\", msp.letters[j].literal)\n                    }\n                    patterns.push(msp);\n                }\n                beginOfSyllable += msp.matchedLength;\n            }\n            if (patterns.length == 0) {\n                //console.log('nothing matched')\n            }\n            else if (patterns.length >= 1) {\n                if (msp == undefined)\n                    break;\n                if (msp.matchedLength > 0) {\n                    i += beginOfSyllable - i - 1;\n                }\n            }\n        }\n        return patterns;\n    }\n}\nexports.MorphemeMaker = MorphemeMaker;\n//# sourceMappingURL=morpheme.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass PhrasalMetaplasm {\n}\nexports.PhrasalMetaplasm = PhrasalMetaplasm;\nclass TonalPhrasalInflectionMetaplasm extends PhrasalMetaplasm {\n    apply(lexemeOne, lexemeTwo) {\n        return [];\n    }\n    applyTwoParticles(lexemeOne, lexemeTwo, lexemeThree) {\n        return [];\n    }\n}\nexports.TonalPhrasalInflectionMetaplasm = TonalPhrasalInflectionMetaplasm;\nclass TonalPhrasalZeroInflection extends TonalPhrasalInflectionMetaplasm {\n}\nexports.TonalPhrasalZeroInflection = TonalPhrasalZeroInflection;\nclass TonalPhrasalAssimilationMetaplasm extends PhrasalMetaplasm {\n    apply(lexemeOne, lexemeTwo) {\n        return [];\n    }\n}\nexports.TonalPhrasalAssimilationMetaplasm = TonalPhrasalAssimilationMetaplasm;\n// -----------------------------------------------------------------------------\nclass ToneGroup {\n    constructor() {\n        this.inflectionalEndings = new Array();\n    }\n}\nexports.ToneGroup = ToneGroup;\nclass ToneSandhiGroup extends ToneGroup {\n}\n// -----------------------------------------------------------------------------\nclass Phraseme {\n}\nexports.Phraseme = Phraseme;\n// -----------------------------------------------------------------------------\nclass Phrase {\n    constructor() {\n        this.literal = '';\n    }\n}\nexports.Phrase = Phrase;\n//# sourceMappingURL=phraseme.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst analyzer_1 = require(\"./tonal/analyzer\");\nconst symbols_1 = require(\"./dparser/symbols\");\nconst rules_1 = require(\"./dparser/rules\");\nconst lexeme_1 = require(\"./lexeme\");\nconst lemmatizer_1 = require(\"./tonal/lemmatizer\");\nclass Token {\n    constructor(text) {\n        this.text = text;\n        this.pos = '';\n        this.tag = '';\n        this.lemma = '';\n        this.dep = '';\n        this.head = undefined;\n    }\n}\nexports.Token = Token;\nclass TokenAnalysis {\n    constructor() {\n        this.word = new lexeme_1.Word();\n        this.lemmas = new Array();\n        this.inflectionalEnding = '';\n        this.soundSequences = new Array();\n        this.blockSequences = [];\n        this.uncombiningSequences = new Array(); // uncombining form sequences\n    }\n}\nexports.TokenAnalysis = TokenAnalysis;\nclass TokenLemmatizer {\n    constructor() {\n        this.getTonalLemmas = (doc) => {\n            const tla = new analyzer_1.TonalLemmatizationAnalyzer();\n            const lmtzr = new lemmatizer_1.TonalLemmatizer();\n            const sophv = new rules_1.SetOfPhrasalVerbs();\n            let j = 0;\n            let k = 0;\n            let len = 0;\n            for (let i = 0; i < doc.tokens.length; i++) {\n                if (len == i) {\n                    // loop over the doc.speeches sequence\n                    if (j < doc.speeches.length) {\n                        len += doc.speeches[j].elements.length;\n                        if (j + 1 < doc.speeches.length)\n                            j++;\n                        k = 0;\n                    }\n                }\n                else {\n                    k++;\n                }\n                if (doc.tokens[i].text === 'che' || doc.tokens[i].text === 'he') {\n                    doc.tokens[i].lemma = doc.tokens[i].text;\n                    continue; // defective\n                }\n                if (doc.tokens[i].tag === symbols_1.Tagset.AUXN || doc.tokens[i].tag === symbols_1.Tagset.AUX) {\n                    doc.tokens[i].lemma = doc.tokens[i].text;\n                    continue;\n                }\n                if (doc.tokens[i].tag === symbols_1.Tagset.VB && i + 1 < doc.tokens.length) {\n                    if (doc.tokens[i + 1].tag === symbols_1.Tagset.PPV || doc.tokens[i + 1].tag === symbols_1.Tagset.APPR) {\n                        for (let j in sophv.phrms) {\n                            if (doc.tokens[i].text === sophv.phrms[j].phrase.words[0].literal &&\n                                doc.tokens[i + 1].text === sophv.phrms[j].phrase.words[1].literal) {\n                                doc.tokens[i].lemma = sophv.phrms[j].phrase.words[0].literal;\n                                doc.tokens[i + 1].lemma = sophv.phrms[j].phrase.words[1].literal;\n                                i++;\n                                break;\n                            }\n                            else if (doc.tokens[i].text === sophv.phrms[j].getForms()[0].words[0].literal &&\n                                doc.tokens[i + 1].text === sophv.phrms[j].phrase.words[1].literal) {\n                                doc.tokens[i].lemma = sophv.phrms[j].phrase.words[0].literal;\n                                doc.tokens[i + 1].lemma = sophv.phrms[j].phrase.words[1].literal;\n                                i++;\n                                break;\n                            }\n                        }\n                        continue;\n                    }\n                }\n                if (doc.tokens[i].tag === symbols_1.Tagset.VB) {\n                    if (i + 1 < doc.tokens.length && doc.tokens[i + 1].tag === symbols_1.Tagset.AUXN) {\n                        doc.tokens[i].lemma = doc.tokens[i].text; // copy the base form\n                        continue;\n                    }\n                }\n                if (doc.speeches[j] && k + 1 == doc.speeches[j].elements.length) {\n                    // at the end of a speech\n                    // need to further check if the speech is a noun chunk or verb phrase\n                    doc.tokens[i].lemma = doc.tokens[i].text; // copy the base form\n                    continue;\n                }\n                let lemmas = [];\n                lemmas = lmtzr.lemmatize(doc.tokens[i].text).getLemmas();\n                if (lemmas.length > 0)\n                    doc.tokens[i].lemma = lemmas[0].literal;\n            }\n            return doc;\n        };\n    }\n}\nexports.TokenLemmatizer = TokenLemmatizer;\n//# sourceMappingURL=token.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst analyzer_1 = require(\"../analyzer\");\nconst lexeme_1 = require(\"./lexeme\");\nconst grapheme_1 = require(\"../grapheme\");\nconst version2_1 = require(\"./version2\");\nconst morpheme_1 = require(\"./morpheme\");\n//------------------------------------------------------------------------------\nclass TonalLemmatizationAnalyzer extends analyzer_1.Analyzer {\n    graphAnalyze(str) {\n        // graphemic analysis\n        const gm = new grapheme_1.GraphemeMaker(version2_1.lowerLettersTonal);\n        return gm.makeGraphemes(str);\n    }\n    morphAnalyze(x) {\n        // morphological analysis\n        let gs = [];\n        if (typeof x == 'object') {\n            gs = x;\n        }\n        else if (typeof x == 'string') {\n            gs = this.graphAnalyze(x);\n        }\n        const mm = new morpheme_1.TonalUncombiningMorphemeMaker();\n        return mm.makeMorphemes(gs);\n    }\n    lexAnalyze(x) {\n        // lexical analysis\n        let ms = [];\n        if (typeof x == 'object') {\n            ms = x;\n        }\n        else if (typeof x == 'string') {\n            ms = this.morphAnalyze(x);\n        }\n        const lm = new lexeme_1.TonalLemmatizationLexemeMaker();\n        return lm.makeLexemes(ms);\n    }\n}\nexports.TonalLemmatizationAnalyzer = TonalLemmatizationAnalyzer;\n//# sourceMappingURL=analyzer.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst version2_1 = require(\"./version2\");\n// m, n, ng\nexports.nasalInitialSounds = [\n    version2_1.TonalLetterTags.m.toString(),\n    version2_1.TonalLetterTags.n.toString(),\n    version2_1.TonalLetterTags.ng.toString()\n];\nexports.combiningRules = new Map()\n    .set(version2_1.TonalLetterTags.zero, [version2_1.TonalLetterTags.z])\n    .set(version2_1.TonalLetterTags.y, [version2_1.TonalLetterTags.zero, version2_1.TonalLetterTags.f])\n    .set(version2_1.TonalLetterTags.w, [version2_1.TonalLetterTags.y])\n    .set(version2_1.TonalLetterTags.x, [version2_1.TonalLetterTags.z, version2_1.TonalLetterTags.w])\n    .set(version2_1.TonalLetterTags.z, [version2_1.TonalLetterTags.w])\n    .set(version2_1.TonalLetterTags.p, [version2_1.TonalLetterTags.f])\n    .set(version2_1.TonalLetterTags.t, [version2_1.TonalLetterTags.f])\n    .set(version2_1.TonalLetterTags.k, [version2_1.TonalLetterTags.f])\n    .set(version2_1.TonalLetterTags.h, [version2_1.TonalLetterTags.y, version2_1.TonalLetterTags.f])\n    .set(version2_1.TonalLetterTags.pp, [version2_1.TonalLetterTags.w, version2_1.TonalLetterTags.x])\n    .set(version2_1.TonalLetterTags.tt, [version2_1.TonalLetterTags.w, version2_1.TonalLetterTags.x])\n    .set(version2_1.TonalLetterTags.kk, [version2_1.TonalLetterTags.w, version2_1.TonalLetterTags.x])\n    .set(version2_1.TonalLetterTags.hh, [version2_1.TonalLetterTags.w, version2_1.TonalLetterTags.x]);\n// w, x\nexports.tonalsWx = [version2_1.TonalLetterTags.w.toString(), version2_1.TonalLetterTags.x.toString()];\n// b, l, g, m, n\nexports.epentheticSounds = [\n    version2_1.TonalLetterTags.b.toString(),\n    version2_1.TonalLetterTags.l.toString(),\n    version2_1.TonalLetterTags.g.toString(),\n    version2_1.TonalLetterTags.m.toString(),\n    version2_1.TonalLetterTags.n.toString()\n];\n// j, l, s\nexports.euphonicFinalsJls = [\n    version2_1.TonalLetterTags.j.toString(),\n    version2_1.TonalLetterTags.l.toString(),\n    version2_1.TonalLetterTags.s.toString()\n];\n// b, g, k, p\nexports.euphonicFinalsBgkp = [\n    version2_1.TonalLetterTags.b.toString(),\n    version2_1.TonalLetterTags.g.toString(),\n    version2_1.TonalLetterTags.k.toString(),\n    version2_1.TonalLetterTags.p.toString()\n];\n// jj, ll, ss\nexports.euphonicFinalsJjllss = [\n    version2_1.TonalLetterTags.jj.toString(),\n    version2_1.TonalLetterTags.ll.toString(),\n    version2_1.TonalLetterTags.ss.toString()\n];\n// bb, gg, kk, pp\nexports.euphonicFinalsBbggkkpp = [\n    version2_1.TonalLetterTags.bb.toString(),\n    version2_1.TonalLetterTags.gg.toString(),\n    version2_1.TonalLetterTags.kk.toString(),\n    version2_1.TonalLetterTags.pp.toString()\n];\n// t\nexports.initialsForEuphonicT = [\n    version2_1.TonalLetterTags.p.toString(),\n    version2_1.TonalLetterTags.k.toString(),\n    version2_1.TonalLetterTags.b.toString(),\n    version2_1.TonalLetterTags.g.toString(),\n    version2_1.TonalLetterTags.j.toString(),\n    version2_1.TonalLetterTags.q.toString(),\n    version2_1.TonalLetterTags.s.toString(),\n    version2_1.TonalLetterTags.v.toString(),\n    version2_1.TonalLetterTags.m.toString(),\n    version2_1.TonalLetterTags.n.toString(),\n    version2_1.TonalLetterTags.ng.toString()\n];\n// tt\nexports.initialsForEuphonicTt = [\n    version2_1.TonalLetterTags.p.toString(),\n    version2_1.TonalLetterTags.k.toString(),\n    version2_1.TonalLetterTags.g.toString(),\n    version2_1.TonalLetterTags.q.toString(),\n    version2_1.TonalLetterTags.s.toString(),\n    version2_1.TonalLetterTags.v.toString(),\n    version2_1.TonalLetterTags.m.toString(),\n    version2_1.TonalLetterTags.n.toString(),\n    version2_1.TonalLetterTags.ng.toString()\n];\nexports.voicelessVoicedFinals = new Map()\n    .set(version2_1.TonalLetterTags.k, version2_1.TonalLetterTags.g)\n    .set(version2_1.TonalLetterTags.p, version2_1.TonalLetterTags.b)\n    .set(version2_1.TonalLetterTags.t, version2_1.TonalLetterTags.l)\n    .set(version2_1.TonalLetterTags.kk, version2_1.TonalLetterTags.gg)\n    .set(version2_1.TonalLetterTags.pp, version2_1.TonalLetterTags.bb)\n    .set(version2_1.TonalLetterTags.tt, version2_1.TonalLetterTags.ll);\n// .set(TonalLetterTags.g, TonalLetterTags.k)\n// .set(TonalLetterTags.b, TonalLetterTags.p)\n// .set(TonalLetterTags.l, TonalLetterTags.t)\n// .set(TonalLetterTags.gg, TonalLetterTags.kk)\n// .set(TonalLetterTags.bb, TonalLetterTags.pp)\n// .set(TonalLetterTags.ll, TonalLetterTags.tt);\n// tt, t\nexports.euphonicTtT = new Map()\n    .set(version2_1.TonalLetterTags.t + version2_1.TonalLetterTags.p, version2_1.TonalLetterTags.p)\n    .set(version2_1.TonalLetterTags.t + version2_1.TonalLetterTags.v, version2_1.TonalLetterTags.p)\n    .set(version2_1.TonalLetterTags.t + version2_1.TonalLetterTags.k, version2_1.TonalLetterTags.k)\n    .set(version2_1.TonalLetterTags.t + version2_1.TonalLetterTags.q, version2_1.TonalLetterTags.k)\n    .set(version2_1.TonalLetterTags.t + version2_1.TonalLetterTags.m, version2_1.TonalLetterTags.h)\n    .set(version2_1.TonalLetterTags.t + version2_1.TonalLetterTags.n, version2_1.TonalLetterTags.h)\n    .set(version2_1.TonalLetterTags.t + version2_1.TonalLetterTags.ng, version2_1.TonalLetterTags.h)\n    .set(version2_1.TonalLetterTags.tt + version2_1.TonalLetterTags.p, version2_1.TonalLetterTags.pp)\n    .set(version2_1.TonalLetterTags.tt + version2_1.TonalLetterTags.v, version2_1.TonalLetterTags.pp)\n    .set(version2_1.TonalLetterTags.tt + version2_1.TonalLetterTags.k, version2_1.TonalLetterTags.kk)\n    .set(version2_1.TonalLetterTags.tt + version2_1.TonalLetterTags.q, version2_1.TonalLetterTags.kk)\n    .set(version2_1.TonalLetterTags.tt + version2_1.TonalLetterTags.m, version2_1.TonalLetterTags.hh)\n    .set(version2_1.TonalLetterTags.tt + version2_1.TonalLetterTags.n, version2_1.TonalLetterTags.hh)\n    .set(version2_1.TonalLetterTags.tt + version2_1.TonalLetterTags.ng, version2_1.TonalLetterTags.hh);\n// b, g, h, l\nexports.initialBghl = [\n    // turn preceding finals to voiced ones\n    version2_1.TonalLetterTags.b.toString(),\n    version2_1.TonalLetterTags.g.toString(),\n    version2_1.TonalLetterTags.h.toString(),\n    version2_1.TonalLetterTags.l.toString()\n];\n// 8 to 1\nexports.eighthToFirst = new Map()\n    .set(version2_1.TonalLetterTags.pp, version2_1.TonalLetterTags.p)\n    .set(version2_1.TonalLetterTags.tt, version2_1.TonalLetterTags.t)\n    .set(version2_1.TonalLetterTags.kk, version2_1.TonalLetterTags.k)\n    .set(version2_1.TonalLetterTags.hh, version2_1.TonalLetterTags.h);\n//# sourceMappingURL=collections.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst version2_1 = require(\"./version2\");\nfunction checkLetterSizeTonal() {\n    if (version2_1.tonalPositionalSounds.size !== version2_1.lowerLettersTonal.size) {\n        console.log('sizes unmatched');\n    }\n}\nexports.checkLetterSizeTonal = checkLetterSizeTonal;\n//# sourceMappingURL=init.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst analyzer_1 = require(\"./analyzer\");\nclass TonalLemmatizer {\n    lemmatize(word) {\n        const tia = new analyzer_1.TonalLemmatizationAnalyzer();\n        const mrphs = tia.morphAnalyze(word);\n        const lx = tia.lexAnalyze(mrphs);\n        return lx;\n    }\n}\nexports.TonalLemmatizer = TonalLemmatizer;\n//# sourceMappingURL=lemmatizer.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst lexeme_1 = require(\"../lexeme\");\nconst version2_1 = require(\"./version2\");\nconst version2_2 = require(\"./version2\");\nclass TonalLemmatization extends lexeme_1.TonalLemmatizationMetaplasm {\n    apply(morphemes, inflectionalEnding) {\n        return this.populateLemmata(morphemes, inflectionalEnding);\n    }\n    getLemmas(morphemes, inflectionalEnding) {\n        if (inflectionalEnding) {\n            if (inflectionalEnding instanceof FreeInflectionalEnding) {\n                const ret = [];\n                const arr = morphemes[morphemes.length - 1].getForms();\n                for (let key in arr) {\n                    const wrd = new TonalWord(morphemes.map(x => x.syllable));\n                    wrd.popSyllable();\n                    wrd.pushSyllable(arr[key]);\n                    ret.push(wrd);\n                }\n                return ret;\n            }\n            else if (inflectionalEnding instanceof CheckedInflectionalEnding) {\n                if (morphemes[morphemes.length - 1].getForms().length == 0)\n                    return [];\n                const wrd = new TonalWord(morphemes.map(x => x.syllable));\n                wrd.popSyllable();\n                wrd.pushSyllable(morphemes[morphemes.length - 1].getForms()[0]);\n                return [wrd];\n            }\n        }\n        return [];\n    }\n    populateLemmata(morphemes, inflectionalEnding) {\n        let lemmata = new Array();\n        // turn morphemes into lemmas\n        let lms = this.getLemmas(morphemes, inflectionalEnding);\n        if (lms.length > 0) {\n            for (let key in lms) {\n                lemmata.push(lms[key]);\n            }\n        }\n        return lemmata;\n    }\n}\nexports.TonalLemmatization = TonalLemmatization;\n//------------------------------------------------------------------------------\nclass Ending {\n}\nclass InflectionalEnding extends Ending {\n    constructor() {\n        super(...arguments);\n        this.affix = new version2_2.TonalAffix(); // the affix of this word\n    }\n    toString() {\n        return this.affix.toString();\n    }\n}\nexports.InflectionalEnding = InflectionalEnding;\nclass FreeInflectionalEnding extends InflectionalEnding {\n}\nexports.FreeInflectionalEnding = FreeInflectionalEnding;\nclass CheckedInflectionalEnding extends InflectionalEnding {\n}\nexports.CheckedInflectionalEnding = CheckedInflectionalEnding;\nclass TonalSymbolEnding extends Ending {\n    constructor() {\n        super(...arguments);\n        this.allomorph = new version2_1.Allomorph();\n    }\n    toString() {\n        return this.allomorph.toString();\n    }\n}\nexports.TonalSymbolEnding = TonalSymbolEnding;\nclass FreeTonalEnding extends TonalSymbolEnding {\n}\nexports.FreeTonalEnding = FreeTonalEnding;\nclass CheckedTonalEnding extends TonalSymbolEnding {\n}\nexports.CheckedTonalEnding = CheckedTonalEnding;\n//------------------------------------------------------------------------------\nclass TonalWord extends lexeme_1.Word {\n    constructor(syllables) {\n        super();\n        this.syllables = new Array();\n        if (syllables != undefined) {\n            let len = syllables.length;\n            for (let i = 0; i < len; i++) {\n                this.pushSyllable(syllables[i]);\n            }\n        }\n    }\n}\nexports.TonalWord = TonalWord;\n//------------------------------------------------------------------------------\nclass TonalLemmatizationLexeme extends lexeme_1.Lexeme {\n    constructor(morphemes, metaplasm) {\n        super();\n        this.lemmata = new Array(); // lexical forms. underlying forms\n        if (morphemes.length == 0)\n            this.word = new TonalWord([]);\n        else\n            this.word = new TonalWord(morphemes.map(x => x.syllable));\n        if (morphemes.length > 0) {\n            if (morphemes[morphemes.length - 1].allomorph) {\n                this.inflectionalEnding = this.assignInflectionalEnding(morphemes[morphemes.length - 1].allomorph);\n            }\n            else {\n                this.inflectionalEnding = new InflectionalEnding();\n            }\n        }\n        else {\n            this.inflectionalEnding = new InflectionalEnding();\n        }\n        if (morphemes.length > 0)\n            this.lemmata = metaplasm.apply(morphemes, this.inflectionalEnding);\n    }\n    getLemmas() {\n        // this must be called after populateLemmata is called\n        return this.lemmata;\n    }\n    getInflectionalEnding() {\n        if (this.inflectionalEnding)\n            return this.inflectionalEnding.toString();\n        return '';\n    }\n    assignInflectionalEnding(allomorph) {\n        let infe = new InflectionalEnding();\n        // change allomorph to affix\n        if (allomorph instanceof version2_1.FreeAllomorph) {\n            let fie = new FreeInflectionalEnding();\n            fie.affix.tonal = allomorph.tonal;\n            infe = fie;\n        }\n        else if (allomorph instanceof version2_1.CheckedAllomorph) {\n            let cie = new CheckedInflectionalEnding();\n            cie.affix.tonal = allomorph.tonal;\n            infe = cie;\n        }\n        // this word is already in base form, and its last syllable is checked tone\n        return infe;\n    }\n}\nexports.TonalLemmatizationLexeme = TonalLemmatizationLexeme;\n//------------------------------------------------------------------------------\nclass TonalLemmatizationLexemeMaker extends lexeme_1.LexemeMaker {\n    constructor() {\n        super();\n    }\n    makeLexemes(morphemes) {\n        return this.make(morphemes);\n    }\n    make(morphemes) {\n        let isInflStemWithX = false; // inflectional stem with x in the middle\n        return new TonalLemmatizationLexeme(morphemes, new TonalLemmatization());\n    }\n}\nexports.TonalLemmatizationLexemeMaker = TonalLemmatizationLexemeMaker;\n//# sourceMappingURL=lexeme.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction isInLexcialRoots(strToFind) {\n    if (exports.lexicalRoots.includes(strToFind))\n        return true;\n    if (extraLexicalRoots.includes(strToFind))\n        return true;\n    return false;\n}\nexports.isInLexcialRoots = isInLexcialRoots;\n// prettier-ignore\nconst toBeVerified = [\n    'cett', 'choa',\n    'dom',\n    'gih',\n    'hioh', 'hoang',\n    'jex', 'jek', 'jeng', 'jih', 'jirnx', 'jirtt',\n    'len', 'lirey', 'loaiz',\n    'mah',\n    'na',\n    'oehh',\n    'qanh', 'qih', 'qoaiz', 'qngh',\n    'toehh',\n    'tom', 'tomz',\n    'virt',\n];\n// prettier-ignore\nconst extraLexicalRoots = [\n    'aih',\n    'coaih',\n    'dngh',\n    'gehh', 'giuh', 'gimw',\n    'homz',\n    'jip',\n    'kiaih', 'kuih',\n    'laih', 'langh', 'lip', 'lih', 'lit', 'loaih', 'loeh', 'loeih', 'lurih',\n    'mnghh',\n    'n',\n    'oh', 'op',\n    'sangh', 'sennh', 'sienh', 'simh', 'sinnh',\n];\n// prettier-ignore\nconst addonLexicalRoots = [\n    'ainn', 'ainny', 'ainnx', 'anny', 'aunn', 'aunny', 'aunnz',\n    'borh', 'borhh', 'borx', 'bory', 'borz',\n    'cainn', 'cainny', 'cainnw', 'cainnx', 'cannh', 'cennh', 'cennx', 'cennz', 'cennhh', 'cor', 'corh', 'corw', 'corx', 'cory', 'corz', 'cinnw', 'cinnh', 'cinnz', 'cir', 'cirinn', 'cirinny', 'cirw', 'ciry', 'cirx', 'coanny', 'coannw', 'coannz', 'cuinn', 'cuinny', 'cuinnw',\n    'chainn', 'chainnw', 'chainnx', 'channw', 'channx', 'chennx', 'chor', 'choreh', 'chorehh', 'chorew', 'chorex', 'chorez', 'chorh', 'chorhh', 'chorw', 'chorz', 'chir', 'chirinny', 'chirinnx', 'chirm', 'chirw', 'chiry', 'chirx', 'chirz', 'chiunnx', 'chm', 'chuinn', 'chuinny', 'chuinnw', 'chuinnx', 'chuinnz',\n    'dainyy', 'dainnw', 'dainnx', 'dainnz', 'dainnhh', 'denny', 'dennx', 'dorex', 'dorey', 'dorez', 'dorh', 'dorhh', 'dorw', 'dory', 'dorz', 'diann', 'diannw', 'dinnh', 'dinnw', 'dir', 'dirinnw', 'dirinnz', 'dirw', 'dirx', 'dirz', 'dirng', 'doanny', 'duinny', 'duinnw', 'duinnx', 'duinnz',\n    'enny', 'ennh', 'ennz', 'ennhh', 'or', 'ore', 'orehh', 'orex', 'orey', 'orez', 'orh', 'orw', 'orx', 'orz', 'orehh',\n    'goreh', 'gorehh', 'gorhh', 'gorex', 'gorez', 'gorx', 'giauh', 'girnx', 'girnz', 'girt', 'girx', 'giry', 'girz',\n    'hainny', 'hainnh', 'hainnz', 'hann', 'hannhh', 'henny', 'hennz', 'hennhh', 'hor', 'horez', 'horw', 'horx', 'hory', 'horz', 'haunn', 'haunny', 'haunnw', 'haunnh', 'haunnx', 'haunnhh', 'hinnh', 'hinnx', 'hio', 'hir', 'hirinnx', 'hirinnz', 'hirny', 'hirnz', 'hirw', 'hirx', 'hiry', 'hirtt', 'hirk', 'hiunny', 'hiunnw', 'hiunnz', 'hmhh', 'hmz', 'hngw', 'hoainnh', 'hoannw', 'honnz', 'hop', 'huinn', 'huinnh', 'huinnx', 'huinnz',\n    'ionn', 'innh', 'innhh', 'ir', 'irinnx', 'irn', 'irny', 'irpp', 'irw', 'irx', 'iry', 'irz',\n    'jiaunny', 'jiaunnw', 'jiaunnx', 'jinny', 'jiry', 'jirx', 'jorx',\n    'kannx', 'kainnh', 'kainnw', 'kaunnhh', 'kennh', 'kennx', 'kor', 'kore', 'koreh', 'korew', 'korw', 'korh', 'korx', 'kiann', 'kiannw', 'kinn', 'kir', 'kirnx', 'kirny', 'kirw', 'kngz', 'koainn', 'koainnw', 'konny', 'kuinnw',\n    'lorehh', 'lorex', 'lorh', 'lorx', 'liry', 'lirx', 'lirz',\n    'maix', 'mih', 'mihh', 'mng', 'moaix', 'moaiz', 'moex', 'moez', 'mui', 'muiz',\n    'naih', 'naix', 'ney', 'new', 'nez', 'nehh', 'niauw', 'niauh', 'niaw', 'nirix', 'niriz', 'niu', 'nngh', 'nox', 'nui', 'nuiy', 'nuiw', 'nuix', 'nuiz',\n    'ngai', 'ngaiy', 'ngauy', 'ngauh', 'ngauhh', 'ngaw', 'ngaz', 'nge', 'ngh', 'nghh', 'ngiahh', 'ngiriy', 'ngiuy', 'ngiux', 'ngiz', 'ngoeh', 'ngoehh',\n    'oainn', 'oainnh', 'oainnz', 'oainnhh', 'oannx',\n    'painn', 'pennw', 'por', 'porhh', 'porw', 'porx', 'porz', 'pinny', 'pinnhh', 'png', 'pngy', 'pngw', 'pngz', 'pnghh', 'poannx', 'ponn', 'puinn', 'puinnw', 'puinnx',\n    'qainny', 'qainnw', 'qainnz', 'qannhh', 'qore', 'qoreh', 'qorew', 'qorex', 'qorey', 'qorez', 'qorh', 'qorw', 'qory', 'qiaunnhh', 'qinny', 'qinnh', 'qinnhh', 'qir', 'qirinn', 'qirinny', 'qirn', 'qirnw', 'qirnz', 'qirw', 'qirx', 'qiry', 'qirz', 'qiunnx', 'qiunnz', 'qnghh', 'qoainnw', 'qoainnx', 'qoainnhh', 'qoannw', 'qoenny', 'qonnz', 'quinn', 'quinny', 'quinnw',\n    'sainn', 'sanny', 'sannw', 'sannx', 'sore', 'sorew', 'sorew', 'sorh', 'sorhh', 'sorx', 'sorw', 'sorz', 'sinnx', 'sinnhh', 'sir', 'sirinn', 'sirm', 'sirp', 'sirw', 'sirx', 'siry', 'sirz', 'sm', 'smw', 'smh', 'snghh', 'soainn', 'soainnh', 'soainnx', 'soainnhh', 'soenn', 'soenny', 'soennw', 'suinn', 'suinny', 'suinnw',\n    'tainnw', 'tainnz', 'tannx', 'tannz', 'tenn', 'tor', 'tore', 'torehh', 'torew', 'torhh', 'torw', 'tinnw', 'tinnx', 'tirx', 'tiry', 'tiunny', 'toannx', 'tuinnw', 'tuinnx', 'tuinnz',\n    'uihh', 'uinn', 'uinny', 'uinnx', 'uinnz',\n    'vainny', 'vainnx', 'vainnz', 'vor', 'vory', 'vorw', 'vorx', 'vorz', 'vinnx', 'vngx', 'vuinn', 'vuinny', 'vuinnx', 'vuinnz',\n];\n// prettier-ignore\nexports.lexicalRoots = [\n    'a', 'ay', 'az', 'ah', 'ahh', 'ai', 'aiy', 'aiw', 'ainnz', 'ak', 'am',\n    'amy', 'amw', 'amx', 'amz', 'an', 'any', 'anw', 'anx', 'anz', 'ang',\n    'angw', 'angx', 'angz', 'annw', 'annx', 'annz', 'ap', 'app', 'at', 'au',\n    'auy', 'auw', 'aux', 'auz',\n    'ba', 'bax', 'baz', 'bah', 'bai', 'baiy', 'baix', 'bak', 'bakk', 'ban',\n    'bany', 'banx', 'banz', 'bangy', 'bangw', 'bangx', 'bangz', 'bat', 'batt',\n    'bauy', 'bauz', 'bey', 'bex', 'bez', 'beh', 'behh', 'biy', 'bix', 'biz',\n    'bieny', 'bienx', 'bienz', 'biett', 'biauy', 'biaux', 'biauz', 'bih',\n    'bihh', 'bekk', 'biny', 'binx', 'binz', 'bengy', 'bengx', 'bengz', 'biury',\n    'biurx', 'biurz', 'bitt', 'biuz', 'bury', 'burx', 'burz', 'bok', 'bokk',\n    'bong', 'bongy', 'bongw', 'bongx', 'bongz', 'boy', 'box', 'boz', 'buy',\n    'bux', 'buz', 'boax', 'boah', 'boahh', 'boany', 'boatt', 'boey', 'boex',\n    'boez', 'boehh', 'bui', 'buny', 'bunw', 'bunx', 'bunz', 'but', 'butt',\n    'ca', 'cay', 'cax', 'caz', 'cah', 'cai', 'caiy', 'caiw', 'caix', 'caiz',\n    'cak', 'cakk', 'cam', 'camy', 'camw', 'camx', 'can', 'canw', 'canx',\n    'cang', 'cangy', 'cangw', 'canny', 'cannz', 'cap', 'capp', 'cat', 'catt',\n    'cau', 'cauy', 'cauw', 'cauhh', 'ce', 'cey', 'cew', 'cex', 'cez', 'ceh',\n    'cenn', 'cenny', 'cennw', 'ci', 'ciy', 'ciw', 'cix', 'ciz', 'cia', 'ciax',\n    'ciah', 'ciakk', 'ciam', 'ciamy', 'cien', 'cieny', 'cienx', 'ciangy',\n    'ciangw', 'ciangx', 'ciangz', 'ciann', 'cianny', 'ciannw', 'ciannx', 'ciap',\n    'ciet', 'ciau', 'ciauw', 'ciaux', 'cih', 'cihh', 'cek', 'cekk', 'cim',\n    'cimy', 'cin', 'cinw', 'ceng', 'cengy', 'cengw', 'cengx', 'cengz', 'cinn',\n    'cinny', 'cinnx', 'ciur', 'ciurw', 'ciurz', 'ciurh', 'ciurhh', 'ciok',\n    'ciokk', 'ciong', 'ciongw', 'cip', 'cit', 'ciu', 'ciuy', 'ciux', 'ciuz',\n    'ciunn', 'ciunny', 'ciunnw', 'ciunnx', 'ciunnz', 'cng', 'cngy', 'cngw',\n    'cngx', 'cngh', 'cnghh', 'cur', 'cury', 'curw', 'curh', 'cok', 'cokk',\n    'cong', 'congy', 'congw', 'congx', 'co', 'coy', 'cow', 'cu', 'cuy', 'cuw',\n    'cuz', 'coaw', 'coaz', 'coah', 'coahh', 'coan', 'coan', 'coanw', 'coanx',\n    'coangw', 'coann', 'coannw', 'coe', 'coey', 'coex', 'coez', 'cuh', 'cuhh',\n    'cui', 'cuiy', 'cuiw', 'cun', 'cuny', 'cunw', 'cunx', 'cunz', 'cut',\n    'cha', 'chay', 'chaw', 'chah', 'chahh', 'chai', 'chaiy', 'chaiw', 'chaix',\n    'chaiz', 'chainny', 'chak', 'chakk', 'cham', 'chamy', 'chamw', 'chamz',\n    'chan', 'chany', 'chanw', 'chanx', 'chanz', 'chang', 'changy', 'changw',\n    'changx', 'channy', 'channz', 'chapp', 'chat', 'chatt', 'chau', 'chauy',\n    'chauw', 'chaux', 'chauz', 'che', 'chey', 'chew', 'chex', 'chez', 'cheh',\n    'chehh', 'chenn', 'chenny', 'chennw', 'chennz', 'chi', 'chiy', 'chiw',\n    'chix', 'chiz', 'chia', 'chiay', 'chiaw', 'chiaz', 'chiah', 'chiahh',\n    'chiam', 'chiamw', 'chiamx', 'chiamz', 'chien', 'chieny', 'chienw',\n    'chienx', 'chienz', 'chiang', 'chiangy', 'chiangw', 'chiann', 'chianny',\n    'chiannw', 'chiannx', 'chiannz', 'chiap', 'chiapp', 'chiet', 'chiett',\n    'chiau', 'chiauy', 'chiauw', 'chiaux', 'chih', 'chihh', 'chek', 'chekk',\n    'chim', 'chimy', 'chimw', 'chimx', 'chin', 'chiny', 'chinw', 'chinx',\n    'chinz', 'cheng', 'chengy', 'chengw', 'chengx', 'chengz', 'chinn',\n    'chinny', 'chinnw', 'chinnx', 'chinnz', 'chiur', 'chiury', 'chiurw',\n    'chiurh', 'chiurhh', 'chiok', 'chiong', 'chiongy', 'chiongw', 'chiongx',\n    'chiongz', 'chip', 'chipp', 'chit', 'chitt', 'chiu', 'chiuy', 'chiuw',\n    'chiuz', 'chiunn', 'chiunny', 'chiunnw', 'chiunnz', 'chng', 'chngy',\n    'chngw', 'chngx', 'chngz', 'chur', 'chury', 'churw', 'churx', 'churz',\n    'churh', 'chok', 'chokk', 'chong', 'chongy', 'chongw', 'chongx', 'chongz',\n    'cho', 'choy', 'choz', 'chu', 'chuy', 'chuw', 'chux', 'chuxz', 'choay',\n    'choax', 'choaz', 'choah', 'choahh', 'choainnz', 'choan', 'choany',\n    'choanw', 'choanx', 'choanz', 'choann', 'choanny', 'choannw', 'choannx',\n    'choannz', 'chutt', 'choew', 'choez', 'chuh', 'chui', 'chuiy', 'chuiw',\n    'chuix', 'chuiz', 'chun', 'chuny', 'chunw', 'chunx', 'chunz', 'chut',\n    'chutt',\n    'da', 'day', 'daw', 'dah', 'dahh', 'dai', 'daiy', 'daiw', 'daix', 'daiz',\n    'dainn', 'dainny', 'dak', 'dakk', 'dam', 'damy', 'damw', 'damx', 'damz',\n    'dan', 'dany', 'danw', 'danx', 'danz', 'dang', 'dangy', 'dangw', 'dangx',\n    'dangz', 'dann', 'danny', 'dannw', 'dannx', 'dannz', 'dap', 'dapp', 'dat',\n    'datt', 'dau', 'dauy', 'dauw', 'daux', 'dauz', 'dauh', 'dauhh', 'de', 'dey',\n    'dew', 'dex', 'dez', 'deh', 'denn', 'dennw', 'dennz', 'di', 'diy', 'diw',\n    'dix', 'diz', 'dia', 'diah', 'diahh', 'diak', 'diakk', 'diam', 'diamy',\n    'diamw', 'diamx', 'diamz', 'dien', 'dieny', 'dienx', 'dienz', 'dianny',\n    'diannx', 'diannz', 'diap', 'diapp', 'diet', 'diett', 'diau', 'diauw',\n    'diaux', 'diauz', 'dih', 'dihh', 'dek', 'dekk', 'dimw', 'dimx', 'dimz',\n    'din', 'diny', 'dinw', 'dinx', 'dinz', 'deng', 'dengy', 'dengw', 'dengx',\n    'dengz', 'dinn', 'dinnx', 'dinnz', 'dinnhh', 'diurw', 'diurx', 'diurz',\n    'diurh', 'diurhh', 'diok', 'diokk', 'diong', 'diongy', 'diongw', 'diongx',\n    'diongz', 'dit', 'ditt', 'diu', 'diuy', 'diuw', 'diux', 'diuz', 'diuh',\n    'diunn', 'diunny', 'diunnw', 'diunnx', 'diunnz', 'dng', 'dngy', 'dngw',\n    'dngx', 'dngz', 'dur', 'dury', 'durw', 'durx', 'durz', 'durh', 'durhh',\n    'dok', 'dokk', 'domx', 'dong', 'dongy', 'dongw', 'dongx', 'dongz', 'do',\n    'doy', 'dow', 'dox', 'doz', 'du', 'duy', 'duw', 'dux', 'duz', 'doaw',\n    'doaz', 'doan', 'doany', 'doanw', 'doanz', 'doann', 'doannw', 'doannx',\n    'doannz', 'doat', 'doatt', 'doew', 'doex', 'doez', 'duh', 'duhh', 'dui',\n    'duiw', 'duix', 'duiz', 'dun', 'duny', 'dunw', 'dunz', 'dutt',\n    'e', 'ey', 'ew', 'ex', 'ez', 'eh', 'ehh', 'enn', 'ennx',\n    'ek', 'ekk', 'eng', 'engy', 'engw', 'engx', 'engz',\n    'gax', 'gaz', 'gaix', 'gaiz', 'gakk', 'gamy', 'gamx', 'gamz', 'gany',\n    'ganw', 'ganx', 'ganz', 'gangz', 'gaux', 'gew', 'gex', 'gez', 'giy', 'gix',\n    'giz', 'giax', 'giah', 'giahh', 'giamy', 'giamx', 'giamz', 'gieny', 'gienw',\n    'gienx', 'gienz', 'giang', 'giangw', 'giangz', 'giap', 'giapp', 'giet',\n    'giett', 'giaux', 'gekk', 'gimy', 'gimx', 'gimz', 'giny', 'ginx', 'ginz',\n    'gengy', 'gengx', 'giury', 'giurx', 'giurhh', 'giok', 'giokk', 'giongy',\n    'giuy', 'giux', 'gurx', 'gurz', 'gokk', 'gongx', 'gongz', 'gox', 'goz',\n    'guy', 'gux', 'guz', 'goay', 'goaz', 'goany', 'goanx', 'goanz', 'goatt',\n    'goez', 'goehh', 'guix', 'guiz',\n    'ha', 'haw', 'hax', 'haz', 'hah', 'hahh', 'hai', 'haiy', 'haix', 'haiz',\n    'hainn', 'hainnw', 'hainnx', 'hak', 'hakk', 'ham', 'hamy', 'hamw', 'hamx',\n    'hamz', 'han', 'hany', 'hanw', 'hanx', 'hanz', 'hang', 'hangw', 'hangx',\n    'hangz', 'hanny', 'hannx', 'hannz', 'hannh', 'hap', 'happ', 'hat', 'hatt',\n    'hau', 'hauy', 'hauw', 'haux', 'hauz', 'he', 'hey', 'hew', 'hex', 'hez',\n    'heh', 'hennw', 'hennx', 'hennh', 'hi', 'hiy', 'hiw', 'hix', 'hia', 'hiaz',\n    'hiah', 'hiahh', 'hiam', 'hiamy', 'hiamw', 'hiamx', 'hien', 'hieny',\n    'hienw', 'hienx', 'hienz', 'hiang', 'hiangy', 'hiangw', 'hiann', 'hianny',\n    'hiannw', 'hiannx', 'hiannz', 'hiannh', 'hiapp', 'hiet', 'hiett', 'hiau',\n    'hiauy', 'hiaux', 'hiauh', 'hek', 'hekk', 'him', 'himx', 'hin', 'hinx',\n    'hinz', 'heng', 'hengw', 'hengx', 'hengz', 'hinn', 'hinnw', 'hinnz',\n    'hiurx', 'hiurz', 'hiurh', 'hiurhh', 'hiok', 'hiong', 'hiongy', 'hiongw',\n    'hiongx', 'hip', 'hit', 'hitt', 'hiu', 'hiuy', 'hiuw', 'hiux', 'hiunn',\n    'hiunnhh', 'hmy', 'hmx', 'hmh', 'hmhh', 'hng', 'hngy', 'hngx', 'hngz',\n    'hngh', 'hnghh', 'hury', 'hurx', 'hurz', 'hurhh', 'hok', 'hokk', 'hong',\n    'hongy', 'hongw', 'hongx', 'hongz', 'honn', 'honny', 'honnw', 'honnh', 'ho',\n    'hoy', 'how', 'hox', 'hoz', 'hu', 'huy', 'huw', 'hux', 'huz', 'hoa', 'hoaw',\n    'hoax', 'hoaz', 'hoah', 'hoahh', 'hoaix', 'hoaiz', 'hoainnx', 'hoan',\n    'hoany', 'hoanw', 'hoanx', 'hoanz', 'hoann', 'hoanny', 'hoannx', 'hoannz',\n    'hoat', 'hoatt', 'hoe', 'hoey', 'hoew', 'hoex', 'hoez', 'hoeh', 'hui',\n    'huiy', 'huiw', 'huix', 'huiz', 'hun', 'huny', 'hunw', 'hunx', 'hunz',\n    'hut', 'hutt',\n    'i', 'iy', 'iw', 'ix', 'iz', 'ia', 'iay', 'iaw', 'iax', 'iaz', 'iah',\n    'iahh', 'iam', 'iamy', 'iamx', 'iamz', 'ien', 'ieny', 'ienw', 'ienx',\n    'iang', 'iangz', 'iann', 'ianny', 'iannw', 'iannx', 'iannz', 'iap', 'iapp',\n    'iet', 'iett', 'iau', 'iauy', 'iauw', 'iaux', 'iauz', 'iaunn', 'im', 'imy',\n    'imw', 'imx', 'in', 'iny', 'inw', 'inx', 'inz', 'inn', 'inny', 'innw',\n    'innx', 'innz', 'iur', 'iury', 'iurx', 'iurh', 'iurhh', 'iok', 'iokk',\n    'iong', 'iongy', 'iongw', 'iongx', 'iongz', 'ip', 'it', 'itt', 'iu', 'iuy',\n    'iuw', 'iux', 'iuz', 'iunn', 'iunny', 'iunnx', 'iunnz',\n    'jiy', 'jix', 'jiz', 'jia', 'jiay', 'jiamy', 'jienx', 'jiangy', 'jiapp',\n    'jiett', 'jiauy', 'jiauw', 'jiaux', 'jimy', 'jimx', 'jimz', 'jinx', 'jinz',\n    'jiurz', 'jiok', 'jiokk', 'jiongy', 'jiongx', 'jiongz', 'jipp', 'jitt',\n    'jiux', 'juy', 'jux', 'juz', 'joahh', 'joex', 'joez', 'junz',\n    'ka', 'kay', 'kaw', 'kah', 'kahh', 'kai', 'kaiy', 'kaiw', 'kainn', 'kainny',\n    'kak', 'kakk', 'kam', 'kamy', 'kamw', 'kan', 'kanw', 'kang', 'kangy',\n    'kangw', 'kann', 'kap', 'kapp', 'kat', 'kau', 'kauy', 'kauw', 'ke', 'key',\n    'kew', 'kex', 'keh', 'kehh', 'kenn', 'kennhh', 'ki', 'kiy', 'kiw', 'kix',\n    'kiz', 'kia', 'kiax', 'kiaz', 'kiah', 'kiakk', 'kiam', 'kiamw', 'kiamx',\n    'kiamz', 'kien', 'kieny', 'kienw', 'kienx', 'kiang', 'kiangw', 'kiap',\n    'kiet', 'kiett', 'kiau', 'kiauy', 'kiauw', 'kiauh', 'kih', 'kek', 'kim',\n    'kimy', 'kimx', 'kin', 'kiny', 'kinx', 'keng', 'kengy', 'kengw', 'kengx',\n    'kengz', 'kinnx', 'kiury', 'kiurw', 'kiurh', 'kiok', 'kiong', 'kiongy',\n    'kiongx', 'kip', 'kipp', 'kit', 'kitt', 'kiu', 'kiuy', 'kiux', 'kiuz',\n    'kiunn', 'kiunnz', 'kng', 'kngw', 'kur', 'kury', 'kurw', 'kurx', 'kok',\n    'kokk', 'kong', 'kongy', 'kongw', 'kongz', 'ko', 'koy', 'kow', 'ku', 'kux',\n    'kuz', 'koa', 'koay', 'koaw', 'koah', 'koaiw', 'koan', 'koany', 'koanw',\n    'koanx', 'koann', 'koanny', 'koannw', 'koat', 'koe', 'koew', 'koex', 'koeh',\n    'kuh', 'kui', 'kuiy', 'kuiw', 'kun', 'kuny', 'kunw', 'kunx', 'kut', 'kutt',\n    'la', 'lax', 'laz', 'lah', 'lahh', 'laix', 'laiz', 'lak', 'lakk', 'lam',\n    'lamy', 'lamw', 'lamx', 'lamz', 'lan', 'lany', 'lanx', 'lanz', 'lang',\n    'langy', 'langw', 'langx', 'langz', 'lap', 'lapp', 'latt', 'lauy', 'lauw',\n    'laux', 'lauz', 'lauhh', 'le', 'ley', 'lew', 'lex', 'lez', 'leh', 'lehh',\n    'li', 'liy', 'liw', 'lix', 'liz', 'liah', 'liahh', 'liam', 'liamy', 'liamw',\n    'liamx', 'liamz', 'lien', 'lieny', 'lienx', 'lienz', 'liang', 'liangy',\n    'liangx', 'liangz', 'liap', 'liapp', 'liett', 'liauy', 'liauw', 'liaux',\n    'liauz', 'lihh', 'lek', 'lekk', 'lim', 'limy', 'limx', 'limz', 'lin',\n    'liny', 'linw', 'linx', 'limz', 'leng', 'lengy', 'lengw', 'lengx', 'lengz',\n    'liury', 'liurx', 'liurz', 'liurhh', 'liok', 'liokk', 'liongy', 'liongw',\n    'liongx', 'liongz', 'lipp', 'liu', 'liuy', 'liuw', 'liux', 'liuz', 'lur',\n    'lury', 'lurw', 'lurx', 'lurz', 'lurh', 'lurhh', 'lok', 'lokk', 'long',\n    'longy', 'longw', 'longx', 'longz', 'loy', 'lox', 'loz', 'lu', 'luy',\n    'luw', 'lux', 'luz', 'loax', 'loaz', 'loah', 'loahh', 'loany', 'loanx',\n    'loanz', 'loatt', 'loex', 'loez', 'lui', 'luiy', 'luiw', 'luix', 'luiz',\n    'lun', 'luny', 'lunx', 'lunz', 'lut', 'lutt',\n    'my', 'mx', 'mz', 'ma', 'may', 'maw', 'max', 'maz', 'mai', 'maiy', 'maiw',\n    'maiz', 'mau', 'maux', 'mauz', 'mauh', 'me', 'mey', 'mex', 'mez', 'meh',\n    'mehh', 'mi', 'miy', 'mix', 'miz', 'miax', 'miaz', 'miauz', 'mih', 'mihh',\n    'mngy', 'mngx', 'mngz', 'mo', 'moy', 'mox', 'moz', 'moh', 'mohh', 'moa',\n    'moay', 'moax', 'moaz', 'muiy', 'muix',\n    'nay', 'naw', 'nax', 'naz', 'nah', 'nai', 'naiy', 'naiz', 'nauy', 'nauz',\n    'nauh', 'ne', 'nex', 'neh', 'ni', 'niy', 'nix', 'niz', 'niay', 'niax',\n    'niaz', 'niau', 'niauy', 'nih', 'niuy', 'niux', 'niuz', 'nng', 'nngy',\n    'nngw', 'nngx', 'nngz', 'noy', 'noz', 'noay', 'noaw', 'noax', 'noaz',\n    'ng', 'ngy', 'ngw', 'ngx', 'ngz', 'ngay', 'ngaiz', 'ngaux', 'ngauz', 'ngey',\n    'ngez', 'ngeh', 'ngehh', 'ngiax', 'ngiau', 'ngiauy', 'ngiauh', 'ngiauhh',\n    'ngoy', 'ngox', 'ngoz',\n    'o', 'oy', 'ox', 'oz', 'ok', 'om', 'omz', 'ong', 'ongy', 'ongx', 'ongz',\n    'onn', 'onnw',\n    'oa', 'oay', 'oax', 'oahh', 'oai', 'oainny', 'oan', 'oany', 'oanw', 'oanx',\n    'oanz', 'oang', 'oann', 'oanny', 'oannw', 'oannz', 'oat', 'oatt', 'oe',\n    'oey', 'oew', 'oex', 'oez', 'oeh',\n    'pa', 'paw', 'paz', 'pah', 'paiw', 'painny', 'painnz', 'pak', 'pakk', 'pan',\n    'pan', 'pang', 'pangy', 'pangw', 'pangx', 'pangz', 'pannw', 'pannz', 'pau',\n    'pauy', 'pauw', 'pauz', 'pauhh', 'pe', 'pey', 'pew', 'pez', 'penn', 'pennx',\n    'pennz', 'pi', 'piy', 'piw', 'pix', 'piz', 'piah', 'piahh', 'piak', 'piakk',\n    'pien', 'pienw', 'pienx', 'piang', 'piangz', 'piann', 'pianny', 'piannx',\n    'piet', 'piau', 'piauw', 'piaux', 'pih', 'pihh', 'pek', 'piny', 'pinx',\n    'pinz', 'peng', 'pengw', 'pengx', 'pengz', 'pinn', 'pinnw', 'pinnx',\n    'pinnz', 'piurw', 'piurx', 'pit', 'pngh', 'pur', 'pury', 'purw', 'purz',\n    'purh', 'pok', 'pokk', 'pong', 'pongy', 'pongw', 'pongx', 'pongz', 'po',\n    'poy', 'pow', 'pox', 'poz', 'puy', 'pux', 'puz', 'poaw', 'poah', 'poahh',\n    'poan', 'poanx', 'poanz', 'poann', 'poannw', 'poannz', 'poat', 'poe',\n    'poey', 'poew', 'poex', 'poez', 'poehh', 'puhh', 'puiy', 'puiw', 'pun',\n    'puny', 'punw', 'punx', 'put', 'putt',\n    'qa', 'qay', 'qaw', 'qaz', 'qah', 'qai', 'qaiy', 'qaiw', 'qainn', 'qainnx',\n    'qak', 'qakk', 'qam', 'qamy', 'qamw', 'qamx', 'qan', 'qany', 'qanw', 'qang',\n    'qangy', 'qangw', 'qangx', 'qangz', 'qann', 'qanny', 'qannw', 'qannx',\n    'qap', 'qat', 'qau', 'qauy', 'qauw', 'qaux', 'qauz', 'qauh', 'qe', 'qey',\n    'qew', 'qez', 'qeh', 'qehh', 'qenn', 'qenny', 'qennw', 'qi', 'qiy', 'qiw',\n    'qix', 'qiz', 'qia', 'qiaw', 'qiaz', 'qiahh', 'qiam', 'qiamy', 'qiamw',\n    'qiamx', 'qien', 'qieny', 'qienw', 'qienz', 'qiann', 'qianny', 'qiannw',\n    'qiannx', 'qiannz', 'qiap', 'qiet', 'qiett', 'qiau', 'qiauy', 'qiaux',\n    'qiauz', 'qek', 'qekk', 'qim', 'qimy', 'qimw', 'qimz', 'qin', 'qiny',\n    'qinw', 'qinz', 'qeng', 'qengy', 'qengw', 'qengx', 'qengz', 'qinn', 'qinnw',\n    'qinnx', 'qiurw', 'qiurx', 'qiurz', 'qiurh', 'qiok', 'qiokk', 'qiong',\n    'qiongy', 'qiongx', 'qiongz', 'qip', 'qipp', 'qitt', 'qiu', 'qiuy', 'qiuw',\n    'qiux', 'qiuz', 'qiunn', 'qng', 'qngy', 'qngw', 'qur', 'qury', 'qurw',\n    'qurx', 'qurz', 'qurh', 'qok', 'qokk', 'qong', 'qongy', 'qongw', 'qongx',\n    'qonnx', 'qo', 'qoy', 'qow', 'qox', 'qoz', 'qu', 'quy', 'quw', 'quz', 'qoa',\n    'qoay', 'qoaw', 'qoaz', 'qoah', 'qoai', 'qoaiy', 'qoaiw', 'qoainn',\n    'qoainny', 'qoainnz', 'qoan', 'qoany', 'qoanw', 'qoanx', 'qoanz', 'qoann',\n    'qoanny', 'qoannx', 'qoannz', 'qoat', 'qoe', 'qoey', 'qoew', 'qoeh', 'qui',\n    'quiy', 'quiw', 'quix', 'quiz', 'qun', 'quny', 'qunw', 'qunx', 'qunz',\n    'qut', 'qutt',\n    'sa', 'say', 'saw', 'sah', 'sahh', 'sai', 'saiy', 'saiw', 'saix', 'saiz',\n    'sak', 'sam', 'samy', 'samw', 'samx', 'san', 'sany', 'sanw', 'sang',\n    'sangy', 'sangw', 'sann', 'sannh', 'sap', 'sat', 'sau', 'sauw', 'se', 'sey',\n    'sew', 'sex', 'seh', 'sehh', 'senn', 'senny', 'sennw', 'si', 'siy', 'siw',\n    'six', 'siz', 'sia', 'siay', 'siaw', 'siax', 'siaz', 'siah', 'siahh',\n    'siak', 'siam', 'siamy', 'siamw', 'siamx', 'sien', 'sieny', 'sienw',\n    'sienx', 'sienz', 'siang', 'siangy', 'siangw', 'siangx', 'siangz', 'siann',\n    'sianny', 'siannw', 'siannx', 'siannz', 'siap', 'siapp', 'siet', 'siett',\n    'siau', 'siauy', 'siauw', 'siaux', 'siauz', 'sih', 'sihh', 'sek', 'sekk',\n    'sim', 'simy', 'simw', 'simx', 'simz', 'sin', 'sinw', 'sinx', 'sinz',\n    'seng', 'sengy', 'sengw', 'sengx', 'sengz', 'sinn', 'sinnw', 'sinnz',\n    'siur', 'siury', 'siurx', 'siurh', 'siurhh', 'siok', 'siokk', 'siong',\n    'siongy', 'siongw', 'siongx', 'siongz', 'sip', 'sipp', 'sit', 'sitt', 'siu',\n    'siuy', 'siuw', 'siux', 'siuz', 'siunn', 'siunny', 'siunnw', 'siunnx',\n    'siunnz', 'sng', 'sngy', 'sngw', 'sngx', 'sngh', 'sur', 'sury', 'surw',\n    'surx', 'surz', 'surh', 'sok', 'som', 'song', 'songy', 'songw', 'songx',\n    'so', 'soy', 'sow', 'su', 'suy', 'suw', 'sux', 'suz', 'soa', 'soay', 'soaw',\n    'soah', 'soai', 'soainnz', 'soan', 'soany', 'soanw', 'soanx', 'soanz',\n    'soann', 'soanny', 'soannw', 'soat', 'soe', 'soey', 'soew', 'soex', 'soeh',\n    'suh', 'sui', 'suiy', 'suiw', 'suix', 'suiz', 'sun', 'suny', 'sunw', 'sunx',\n    'sunz', 'sut', 'sutt',\n    'taw', 'tah', 'tahh', 'tai', 'taiy', 'taiw', 'taix', 'taiz', 'tak', 'takk',\n    'tam', 'tamw', 'tamx', 'tamz', 'tan', 'tany', 'tanw', 'tanx', 'tang',\n    'tangy', 'tangw', 'tangx', 'tann', 'tanny', 'tap', 'tat', 'tau', 'tauy',\n    'tauw', 'taux', 'tauz', 'te', 'tey', 'tew', 'tex', 'tez', 'teh', 'tehh',\n    'tennw', 'tennx', 'ti', 'tiy', 'tiw', 'tix', 'tiz', 'tiah', 'tiam', 'tiamy',\n    'tiamz', 'tien', 'tieny', 'tiann', 'tiannw', 'tiannx', 'tiannz', 'tiap',\n    'tiapp', 'tiet', 'tiau', 'tiauy', 'tiauw', 'tiaux', 'tiauz', 'tih', 'tihh',\n    'tek', 'tekk', 'tim', 'tin', 'tinx', 'tinz', 'teng', 'tengy', 'tengw',\n    'tengx', 'tinn', 'tinnz', 'tiur', 'tiurw', 'tiurx', 'tiok', 'tiong',\n    'tiongy', 'tiongw', 'tiongx', 'tiu', 'tiuy', 'tng', 'tngw', 'tngx', 'tngz',\n    'tur', 'tury', 'turw', 'turx', 'turh', 'turhh', 'tok', 'tokk', 'tong',\n    'tongy', 'tongw', 'tongz', 'toy', 'tow', 'tox', 'tuy', 'toa', 'toaz',\n    'toah', 'toanx', 'toann', 'toanny', 'toannw', 'toat', 'tuh', 'tui', 'tuiy',\n    'tuiw', 'tuix', 'tun', 'tuny', 'tunx', 'tunz', 'tut', 'tutt',\n    'u', 'uy', 'uw', 'ux', 'uz', 'uh', 'ui', 'uiy', 'uiw', 'uix', 'uiz', 'un',\n    'uny', 'unw', 'unx', 'unz', 'ut',\n    'ur', 'urw', 'urx', 'urh', 'urhh',\n    'va', 'vay', 'vaw', 'vax', 'vaz', 'vah', 'vai', 'vaiy', 'vaiw', 'vaix',\n    'vaiz', 'vak', 'vakk', 'van', 'vany', 'vanx', 'vanz', 'vang', 'vangy',\n    'vangw', 'vangx', 'vat', 'vatt', 'vau', 'vauy', 'vaux', 'vauz', 've', 'vey',\n    'vew', 'vex', 'vez', 'veh', 'vehh', 'venn', 'vennw', 'vennx', 'vennz', 'vi',\n    'viy', 'viw', 'vix', 'viz', 'viah', 'viak', 'viakk', 'vien', 'vieny',\n    'vienw', 'vienz', 'viangw', 'viangz', 'viann', 'vianny', 'viannw', 'viannx',\n    'viet', 'viett', 'viau', 'viauy', 'vih', 'vek', 'vekk', 'vin', 'viny',\n    'vinw', 'vinx', 'veng', 'vengy', 'vengw', 'vengx', 'vengz', 'vinn', 'vinny',\n    'vinnw', 'vinnz', 'viur', 'viury', 'viurz', 'vit', 'vitt', 'viu', 'vng',\n    'vngy', 'vngz', 'vur', 'vury', 'vurw', 'vurx', 'vurz', 'vurh', 'vurhh',\n    'vok', 'vokk', 'vongy', 'vongw', 'vongx', 'vongz', 'vo', 'voy', 'vow',\n    'vox', 'voz', 'vu', 'vuw', 'vux', 'vuz', 'voaw', 'voah', 'voahh',\n    'voan', 'voanw', 'voanx', 'voanz', 'voann', 'voanny', 'voannw', 'voannx',\n    'voannz', 'voat', 'voatt', 'voe', 'voey', 'voew', 'voex', 'voez', 'voeh',\n    'voehh', 'vuh', 'vui', 'vuix', 'vuiz', 'vun', 'vuny', 'vunw', 'vunx',\n    'vunz', 'vut', 'vutt',\n];\n//# sourceMappingURL=lexicalroots2.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst version2_1 = require(\"./version2\");\nconst collections_1 = require(\"./collections\");\n// mhf, nhf, nghf\nexports.regexMnngHF = /(m|ng?)hf/g;\n// mhf, nhf, nghf\nexports.smMnngHF = function (nasalFinal, neutralFinalH, firstTonalF) {\n    const snfs = new version2_1.NasalFinalSounds();\n    if (snfs.includes(nasalFinal) && version2_1.TonalLetterTags.h === neutralFinalH && version2_1.TonalLetterTags.f === firstTonalF)\n        return true;\n    return false;\n};\n// mhhw, mhhx, nhhw, nhhx, nghhw, nghhx\nexports.regexMnngHhWX = /(m|ng?)hh(w|x)/g;\n// mhhw\nexports.smMHhW = function (nasalFinal, neutralFinalHH, thirdTonalW) {\n    if (nasalFinal === version2_1.TonalLetterTags.m && neutralFinalHH === version2_1.TonalLetterTags.hh && thirdTonalW === version2_1.TonalLetterTags.w)\n        return true;\n    return false;\n};\n// mhhw, mhhx, nhhw, nhhx, nghhw, nghhx\nexports.smMnngHhWx = function (nasalFinal, neutralFinalHH, tonalWX) {\n    const snfs = new version2_1.NasalFinalSounds();\n    if (snfs.includes(nasalFinal) && version2_1.TonalLetterTags.hh === neutralFinalHH && collections_1.tonalsWx.includes(tonalWX))\n        return true;\n    return false;\n};\n// jf, lf, sf\nexports.regexJlsF = /(j|l|s)f/g;\n// jf, lf, sf\nexports.smJlsF = function (euphonicFinalJLS, firstTonalF) {\n    if (collections_1.euphonicFinalsJls.includes(euphonicFinalJLS) && version2_1.TonalLetterTags.f === firstTonalF)\n        return true;\n    return false;\n};\n// bf, gf, kf, pf\nexports.smBgkpF = function (euphonicFinalBGJKLPS, firstTonalF) {\n    if (collections_1.euphonicFinalsBgkp.includes(euphonicFinalBGJKLPS) && version2_1.TonalLetterTags.f === firstTonalF)\n        return true;\n    return false;\n};\n// jjw, jjx, llw, llx, ssw, ssx\nexports.regexJjllssWx = /(jj|ll|ss)(w|x)/g;\n// jjw, jjx, llw, llx, ssw, ssx\nexports.smJjllssWx = function (euphonicFinalJJLLSS, tonalWX) {\n    if (collections_1.euphonicFinalsJjllss.includes(euphonicFinalJJLLSS) && collections_1.tonalsWx.includes(tonalWX))\n        return true;\n    return false;\n};\n// bbw, bbx, ggw, ggx, kkw, kkx, ppw, ppx\nexports.smBbggkkppWx = function (euphonicFinalBBGGJJKKLLPPSS, tonalWX) {\n    if (collections_1.euphonicFinalsBbggkkpp.includes(euphonicFinalBBGGJJKKLLPPSS) && collections_1.tonalsWx.includes(tonalWX))\n        return true;\n    return false;\n};\n// bf, gf, jf, kf, lf, pf, sf\nexports.smBgjklpsF = function (euphonicFinalBGJKLPS, firstTonalF) {\n    const efs = new version2_1.EuphonicFinalsBGJKLPS();\n    if (efs.includes(euphonicFinalBGJKLPS) && version2_1.TonalLetterTags.f === firstTonalF)\n        return true;\n    return false;\n};\n// bbw, bbx, ggw, ggx, jjw, jjx, kkw, kkx, llw, llx, ppw, ppx, ssw, ssx\nexports.smBbggjjkkllppssWx = function (euphonicFinalBBGGJJKKLLPPSS, tonalWX) {\n    const efs = new version2_1.EuphonicFinalsBBGGJJKKLLPPSS();\n    if (efs.includes(euphonicFinalBBGGJJKKLLPPSS) && collections_1.tonalsWx.includes(tonalWX))\n        return true;\n    return false;\n};\n//# sourceMappingURL=matcher.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst morpheme_1 = require(\"../morpheme\");\nconst version2_1 = require(\"./version2\");\nconst grapheme_1 = require(\"../grapheme\");\nconst soundgen_1 = require(\"./soundgen\");\nconst lexicalroots2_1 = require(\"./lexicalroots2\");\nconst matcher_1 = require(\"./matcher\");\nconst collections_1 = require(\"./collections\");\n//------------------------------------------------------------------------------\nclass TonalUncombiningForms extends morpheme_1.TonalCombiningMetaplasm {\n    apply(sounds, allomorph) {\n        if (allomorph) {\n            if (allomorph instanceof version2_1.FreeAllomorph) {\n                if (allomorph instanceof version2_1.ZeroAllomorph) {\n                    // push y to make tone 2\n                    // 1 to 2\n                    const s = new TonalSyllable(sounds.map(x => new grapheme_1.AlphabeticLetter(x.characters)));\n                    const tnls = version2_1.freeAllomorphUncombiningRules.get('zero');\n                    if (tnls)\n                        s.pushLetter(new grapheme_1.AlphabeticLetter(tnls[0].characters));\n                    return [s];\n                }\n                else {\n                    // the 7th tone has two baseforms\n                    const ret = [];\n                    const rules = version2_1.freeAllomorphUncombiningRules.get(allomorph.toString());\n                    const tnls = !rules ? [] : rules;\n                    for (let i in tnls) {\n                        let s = new TonalSyllable(sounds.map(x => new grapheme_1.AlphabeticLetter(x.characters)));\n                        if (!(tnls[i] instanceof version2_1.ZeroAllomorph)) {\n                            // 2 to 3. 3 to 7. 7 to 5. 3 to 5.\n                            // replace z with f or x\n                            s.popLetter();\n                            s.pushLetter(new grapheme_1.AlphabeticLetter(tnls[i].characters));\n                            ret.push(s);\n                        }\n                        else {\n                            // 7 to 1\n                            // pop z\n                            s.popLetter();\n                            ret.push(s);\n                        }\n                    }\n                    return ret;\n                }\n            }\n            else if (allomorph instanceof version2_1.CheckedAllomorph) {\n                // pop the tone letter\n                // 1 to 4. 3 to 8. 2 to 4. 5 to 8.\n                if (allomorph.tonal.toString() === '')\n                    return [];\n                const s = new TonalSyllable(sounds.map(x => new grapheme_1.AlphabeticLetter(x.characters)));\n                s.popLetter();\n                return [s];\n            }\n        }\n        return [];\n    }\n}\nexports.TonalUncombiningForms = TonalUncombiningForms;\n//------------------------------------------------------------------------------\nclass CombiningAy extends morpheme_1.TonalCombiningMetaplasm {\n    apply(sounds, allomorph) {\n        if (allomorph) {\n            if (allomorph.tonal.toString() === version2_1.TonalLetterTags.f) {\n                if (allomorph instanceof version2_1.FreeAllomorph) {\n                    const ret = [];\n                    const rls = version2_1.uncombiningRulesAy.get(allomorph.toString());\n                    const tnls = !rls ? [] : rls;\n                    for (let i in tnls) {\n                        let s = new TonalSyllable(sounds.map(it => new grapheme_1.AlphabeticLetter(it.characters)));\n                        // 1 to 2. 1 to 3\n                        // replace f with y or w\n                        s.popLetter();\n                        s.pushLetter(new grapheme_1.AlphabeticLetter(tnls[i].characters));\n                        ret.push(s);\n                    }\n                    return ret;\n                }\n                else if (allomorph instanceof version2_1.CheckedAllomorph) {\n                    const s = new TonalSyllable(sounds.map(it => new grapheme_1.AlphabeticLetter(it.characters)));\n                    // pop f\n                    s.popLetter();\n                    return [s];\n                }\n            }\n            else if (allomorph.tonal.toString() === version2_1.TonalLetterTags.x) {\n                // 5 to 1. 5 to 7. 5 to 5.\n                if (allomorph instanceof version2_1.FreeAllomorph) {\n                    const ret = [];\n                    const rls = version2_1.uncombiningRulesAy.get(allomorph.toString());\n                    const tnls = !rls ? [] : rls;\n                    for (let i in tnls) {\n                        let s = new TonalSyllable(sounds.map(it => new grapheme_1.AlphabeticLetter(it.characters)));\n                        if (!(tnls[i] instanceof version2_1.ZeroTonal)) {\n                            if (tnls[i] instanceof version2_1.FreeTonalZ) {\n                                // 5 to 7\n                                // replace x with z\n                                s.popLetter();\n                                s.pushLetter(new grapheme_1.AlphabeticLetter(tnls[i].characters));\n                                ret.push(s);\n                            }\n                            else if (tnls[i] instanceof version2_1.FreeTonalX) {\n                                // 5 to 5\n                                ret.push(s);\n                            }\n                        }\n                        else {\n                            // 5 to 1\n                            // pop x\n                            s.popLetter();\n                            ret.push(s);\n                        }\n                    }\n                    return ret;\n                }\n                else if (allomorph instanceof version2_1.CheckedAllomorph) {\n                    // 5 to 8.\n                    const s = new TonalSyllable(sounds.map(it => new grapheme_1.AlphabeticLetter(it.characters)));\n                    // pop x\n                    s.popLetter();\n                    return [s];\n                }\n            }\n            else if (allomorph.tonal.toString() === version2_1.TonalLetterTags.y) {\n                return [];\n            }\n        }\n        return [];\n    }\n}\nexports.CombiningAy = CombiningAy;\n//------------------------------------------------------------------------------\nclass TonalReduplication extends morpheme_1.TonalCombiningMetaplasm {\n    constructor(sounds) {\n        super();\n        this.sounds = sounds;\n    }\n    apply(sounds, allomorph) {\n        if (allomorph) {\n            // skip the last syllable. it is the baseform\n            if (this.sounds[this.sounds.length - 1].toString() === sounds[sounds.length - 1].toString())\n                return [];\n            const s = new TonalSyllable(this.sounds.map(it => new grapheme_1.AlphabeticLetter(it.characters)));\n            return [s];\n        }\n        return [];\n    }\n}\nexports.TonalReduplication = TonalReduplication;\n//------------------------------------------------------------------------------\nfunction syllabifyTonal(letters, beginOfSyllable) {\n    // get the longest matched syllable pattern\n    let literal = '';\n    let matched = '';\n    let begin = 0;\n    let ltrs = new Array();\n    let matchedLtrs = new Array();\n    const sft = new version2_1.FreeTonalSounds();\n    const ssf = new version2_1.StopFinalSounds();\n    const faurs = version2_1.freeAllomorphUncombiningRules;\n    const ursa = version2_1.uncombiningRulesAy;\n    for (let i = beginOfSyllable; i < letters.length; i++) {\n        literal = literal + letters[i].literal;\n        ltrs.push(letters[i].literal);\n        //console.log(`begining of the loop: ${literal}. ${ltrs}`)\n        if (lexicalroots2_1.isInLexcialRoots(literal) && sft.includes(letters[i].literal)) {\n            //console.log(`i: ${i}, literal: ${literal}, tone: ${letters[i].literal}, letters[i+1]: ${letters[i + 1].literal}`)\n            if (begin === beginOfSyllable) {\n                matched = literal;\n                Object.assign(matchedLtrs, ltrs);\n            }\n            break;\n        }\n        else if (lexicalroots2_1.isInLexcialRoots(literal) && ssf.includes(letters[i].literal)) {\n            //console.log(`i: ${i}, literal: ${literal}, stopFinal: ${letters[i].literal}`)\n            //console.log(`begin: ${begin}, beginOfSyllable: ${beginOfSyllable}`)\n            if (begin === beginOfSyllable) {\n                matched = literal;\n                Object.assign(matchedLtrs, ltrs);\n            }\n            break;\n        }\n        else if (sft.includes(letters[i].literal)) {\n            // check tonals is the subset of free tonals\n            // console.log('i: %d', i)\n            // console.log(`i: ${i}, literal: ${literal}, letters[i].literal, ${letters[i].literal}`)\n            // when there are tonals\n            if (literal.length > 1 &&\n                letters[i] &&\n                letters[i - 1] &&\n                (matcher_1.smBgkpF(letters[i - 1].literal, letters[i].literal) ||\n                    matcher_1.smBbggkkppWx(letters[i - 1].literal, letters[i].literal))) {\n                // this combining form is not present in the pool.\n                matched = literal;\n                Object.assign(matchedLtrs, ltrs);\n                break;\n            }\n            else if (literal.length > 2 &&\n                letters[i] &&\n                letters[i - 1] &&\n                letters[i - 2] &&\n                matcher_1.smMHhW(letters[i - 2].literal, letters[i - 1].literal, letters[i].literal)) {\n                // for lexical roots end with ~mhhw.\n                matched = literal;\n                Object.assign(matchedLtrs, ltrs);\n                break;\n            }\n            // tone sandhi of free allomorph\n            const rulesFa = faurs.get(letters[i].literal);\n            const tnlsFa = !rulesFa ? [] : rulesFa.map(x => x.toString());\n            // tone sandhi of ay\n            const rulesAy = ursa.get(letters[i].literal);\n            const tnlsAy = !rulesAy ? [] : rulesAy.map(x => x.toString());\n            // merge the above twoo arrays\n            const tnls = tnlsFa.concat(tnlsAy.filter(item => tnlsFa.indexOf(item) < 0));\n            //console.log(ts)\n            if (tnls.length > 0) {\n                for (let t of tnls) {\n                    //console.log(lit + t.toString())\n                    if (lexicalroots2_1.isInLexcialRoots(letters\n                        .slice(beginOfSyllable, i)\n                        .map(x => x.literal)\n                        .join('') + t)) {\n                        // this combining form is not present in the pool,\n                        // but its uncombining forms are. e.g. aw.\n                        matched = literal;\n                        //begin = beginOfSyllable;\n                        Object.assign(matchedLtrs, ltrs);\n                        break;\n                    }\n                }\n                if (matched.length > 0 && matchedLtrs.length > 0)\n                    break;\n            }\n            else {\n                // no uncombining forms for this combining form. e.g. ax.\n                matched = '';\n                matchedLtrs = [];\n            }\n        }\n        else if (lexicalroots2_1.isInLexcialRoots(literal)) {\n            matched = literal;\n            Object.assign(matchedLtrs, ltrs);\n            begin = beginOfSyllable;\n            //console.log(matched)\n        }\n        else {\n            //console.log('no matched for syllabifyTonal:' + ltrs)\n            // when there are no tonals\n            if (letters[i].literal === version2_1.TonalLetterTags.gg) {\n                // for surface form gg whose underlying form could be tt or kk.\n                matched = literal;\n                Object.assign(matchedLtrs, ltrs);\n            }\n            else if (!sft.includes(letters[i].literal)) {\n                // free first tone without a free tonal\n                const rules = faurs.get(version2_1.TonalLetterTags.zero);\n                const tnls = !rules ? [] : rules;\n                for (let t of tnls) {\n                    // append second tonal letter\n                    // check the uncombining forms\n                    if (lexicalroots2_1.isInLexcialRoots(literal + t.toString())) {\n                        // if the free first tone's lemma is included\n                        matched = literal;\n                        Object.assign(matchedLtrs, ltrs);\n                        //break;\n                    }\n                }\n            }\n            // when there is no matched lexcial roots for this syllable, we still assign begin\n            begin = beginOfSyllable;\n        }\n    }\n    // console.log(`literal: ${literal}. matched: ${matched}`)\n    // console.log(matchedLtrs)\n    if (matched.length > 0 && literal.length > matched.length) {\n        // when ~ay is longer than ~a by one letter y\n        // for those first tone lexcial roots that are present\n        matched = '';\n        matchedLtrs = [];\n    }\n    //console.log('matched: ' + matched)\n    const tsg = new soundgen_1.TonalSoundGenerator();\n    //console.log('matched: ' + matched)\n    let list = new Array();\n    if (matched.length > 0) {\n        list = tsg.generate(matchedLtrs);\n    }\n    else {\n        if (ltrs.length == 3 && ltrs[1] === 'a' && ltrs[2] === 'y') {\n            const rea = new morpheme_1.RemovingEpenthesisOfAy();\n            const done = rea.applyToString(literal);\n            //console.log(done.toString())\n            if (collections_1.epentheticSounds.includes(ltrs[0]) && lexicalroots2_1.isInLexcialRoots(done)) {\n                list = tsg.generate(ltrs);\n            }\n        }\n    }\n    //console.log(list)\n    let matchedLen = 0;\n    let mp = new morpheme_1.MatchedPattern();\n    for (let m in list) {\n        const min = Math.min(letters.length - beginOfSyllable, list[m].length);\n        if (list[m].length == min) {\n            for (let n = 0; n < min; n++) {\n                if (list[m][n] != undefined) {\n                    if (letters[beginOfSyllable + n].literal === list[m][n].toString()) {\n                        //console.log(syllabary[m])\n                        if (n + 1 == min && min > matchedLen) {\n                            // to make sure it is longer than previous patterns\n                            // last letter matched for the pattern\n                            matchedLen = min;\n                            // copy the matched letters\n                            for (let q = 0; q < matchedLen; q++) {\n                                mp.letters[q] = letters[beginOfSyllable + q];\n                            }\n                            // copy the pattern of sounds\n                            mp.pattern = list[m];\n                            //console.log(syllabary.list[m])\n                            //console.log(mp.letters)\n                        }\n                    }\n                    else {\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    return mp;\n}\nexports.syllabifyTonal = syllabifyTonal;\n//------------------------------------------------------------------------------\nclass TonalSyllable extends morpheme_1.Syllable {\n    popLetter() {\n        this.letters = this.letters.slice(0, this.letters.length - 1);\n        this.concat();\n    }\n    get lastLetter() {\n        if (this.letters.length >= 1)\n            return this.letters[this.letters.length - 1];\n        return new grapheme_1.AlphabeticLetter([]);\n    }\n    get lastSecondLetter() {\n        if (this.letters.length >= 2)\n            return this.letters[this.letters.length - 2];\n        return new grapheme_1.AlphabeticLetter([]);\n    }\n}\nexports.TonalSyllable = TonalSyllable;\n//------------------------------------------------------------------------------\nclass TonalUncombiningMorpheme extends morpheme_1.Morpheme {\n    constructor(syllable, sounds, metaplasm) {\n        super();\n        this.syllable = syllable;\n        this.metaplasm = metaplasm;\n        // assign allomorph for each syllable\n        this.allomorph = this.assignAllomorph(this.syllable);\n        this.sounds = sounds;\n        this.forms = this.metaplasm.apply(this.sounds, this.allomorph);\n    }\n    getForms() {\n        return this.forms;\n    }\n    assignAllomorph(syllable) {\n        let allomorph = new version2_1.ZeroAllomorph();\n        // assign the matched allomorph for this syllable\n        let aoas = []; // array of allomorphs\n        let keys = Array.from(version2_1.checkedAllomorphs.keys());\n        for (let k = 0; k < keys.length; k++) {\n            let am = version2_1.checkedAllomorphs.get(keys[k]);\n            if (am && am instanceof version2_1.CheckedAllomorph) {\n                if (am.tonal) {\n                    if (am.tonal.toString() === syllable.lastLetter.literal &&\n                        am.final.toString() === syllable.lastSecondLetter.literal) {\n                        aoas.push(am);\n                        break;\n                    }\n                    else {\n                        if (am.final.toString() === syllable.lastLetter.literal) {\n                            aoas.push(am);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        if (aoas.length > 0) {\n            // there is only one match after processing, we just assign it\n            let ret = aoas.shift();\n            if (ret)\n                return ret;\n        }\n        // after matching with checked allomorphs, we go on matching free allomorphs\n        aoas = [];\n        if (version2_1.freeAllomorphs.has(syllable.lastLetter.literal)) {\n            const am = version2_1.freeAllomorphs.get(syllable.lastLetter.literal);\n            if (am)\n                aoas.push(am);\n            else\n                aoas.push(new version2_1.Allomorph());\n        }\n        if (aoas.length == 0) {\n            // tone 1 has no allomorph\n            allomorph = new version2_1.ZeroAllomorph();\n        }\n        else if (aoas.length == 1) {\n            // are there multiple allomorphs? there should be only one.\n            for (let i = 0; i < aoas.length; i++) {\n                if (aoas[i].tonal.toString() === new version2_1.AllomorphX().tonal.toString()) {\n                    // this syllable is already in base form\n                    // in order to display this inflectional ending, we have to assign\n                    allomorph = aoas[i];\n                }\n                else {\n                    allomorph = aoas[i];\n                }\n            }\n        }\n        return allomorph;\n    }\n}\nexports.TonalUncombiningMorpheme = TonalUncombiningMorpheme;\n//------------------------------------------------------------------------------\nclass TonalUncombiningMorphemeMaker extends morpheme_1.MorphemeMaker {\n    constructor() {\n        super();\n        this.euphonicFinals = new Array();\n        this.euphonicFinalTonals = new Array();\n    }\n    createMorphemes() {\n        return new Array();\n    }\n    createMorpheme(matched, metaplasm) {\n        const tum = new TonalUncombiningMorpheme(new TonalSyllable(matched.letters), matched.pattern, metaplasm);\n        return tum;\n    }\n    isCombiningAy(patterns) {\n        const keysAy = Array.from(version2_1.uncombiningRulesAy.keys());\n        if (patterns.length == 2 &&\n            keysAy.filter(it => it === patterns[patterns.length - 2].lastLetter.literal).length > 0 &&\n            ((patterns[patterns.length - 1].lastSecondLetter.literal === version2_1.TonalLetterTags.a &&\n                patterns[patterns.length - 1].lastLetter.literal === version2_1.TonalLetterTags.y) ||\n                patterns[patterns.length - 1].lastLetter.literal === version2_1.TonalLetterTags.a)) {\n            return true;\n        }\n        return false;\n    }\n    isReduplicated3x(matches) {\n        if (matches.length == 3) {\n            const stms = matches\n                .map(it => it.pattern.filter(s => s.name !== version2_1.TonalSoundTags.freeTonal))\n                .map(seq => seq.map(s => s.toString()).join(''));\n            // TODO: add checks for tone group\n            const tnls = matches\n                .map(it => it.pattern.filter(s => s.name === version2_1.TonalSoundTags.freeTonal))\n                .map(seq => seq.map(s => s.toString()).join(''));\n            // compare 3 strings/lexical stems\n            if (stms.every((v, i, a) => v === a[0]))\n                return true; // identical\n        }\n        return false;\n    }\n    preprocessEuphonicFinal(letters) {\n        this.euphonicFinals.push(letters[letters.length - 1]);\n        return letters.slice(0, letters.length - 1);\n    }\n    preprocessEuphonicFinalTonal(letters, literal, regex, len) {\n        const arr = literal.match(regex);\n        // console.log(arr)\n        let indx = -1;\n        if (len == 1) {\n            for (let i = 0; i < letters.length - 1; i++) {\n                if (matcher_1.smJlsF(letters[i].literal, letters[i + 1].literal) ||\n                    matcher_1.smJjllssWx(letters[i].literal, letters[i + 1].literal)) {\n                    indx = i;\n                    break;\n                }\n            }\n        }\n        else if (len == 2) {\n            for (let i = 0; i < letters.length - 2; i++) {\n                if (matcher_1.smMnngHF(letters[i].literal, letters[i + 1].literal, letters[i + 2].literal) ||\n                    matcher_1.smMnngHhWx(letters[i].literal, letters[i + 1].literal, letters[i + 2].literal)) {\n                    indx = i;\n                    break;\n                }\n            }\n        }\n        if (arr) {\n            for (let i in arr) {\n                const idxl = literal.search(arr[i]);\n                const sub1 = literal.substring(0, idxl);\n                const sub2 = literal.substring(idxl + arr[i].length);\n                // in case of hmhhw or hmhhwhmhhw\n                // check if the previous letter is a consonant\n                if (new version2_1.InitialSounds().includes(sub1))\n                    return letters;\n                let fnl;\n                if (version2_1.TonalLetterTags.f === arr[i].charAt(arr[i].length - 1)) {\n                    literal = sub1.concat(version2_1.TonalLetterTags.t + version2_1.TonalLetterTags.f, sub2);\n                    fnl = letters.splice(indx, len, version2_1.lowerLettersTonal.get(version2_1.TonalLetterTags.t));\n                }\n                else if (collections_1.tonalsWx.includes(arr[i].charAt(arr[i].length - 1))) {\n                    if (arr[i].charAt(arr[i].length - 1) === version2_1.TonalLetterTags.w)\n                        literal = sub1.concat(version2_1.TonalLetterTags.tt + version2_1.TonalLetterTags.w, sub2);\n                    else if (arr[i].charAt(arr[i].length - 1) === version2_1.TonalLetterTags.x)\n                        literal = sub1.concat(version2_1.TonalLetterTags.tt + version2_1.TonalLetterTags.x, sub2);\n                    fnl = letters.splice(indx, len, version2_1.lowerLettersTonal.get(version2_1.TonalLetterTags.tt));\n                }\n                // console.log(literal)\n                if (fnl && len == 1)\n                    this.euphonicFinalTonals.push({ index: indx, letters: [fnl[0]] });\n                else if (fnl && len == 2)\n                    this.euphonicFinalTonals.push({ index: indx, letters: [fnl[0], fnl[1]] });\n            }\n            // console.log(this.euphonicFinalTonals[0].letters)\n        }\n        return letters;\n    }\n    replaceEuphonicFinal(letters) {\n        const slicedLetters = letters.slice(0, letters.length - 1);\n        const literal = slicedLetters.map(it => it.literal).join('');\n        if (letters.length > 0 &&\n            letters[letters.length - 1].literal === version2_1.TonalLetterTags.gg &&\n            lexicalroots2_1.isInLexcialRoots(literal + version2_1.TonalLetterTags.tt) &&\n            !lexicalroots2_1.isInLexcialRoots(literal + version2_1.TonalLetterTags.kk)) {\n            // for surface form gg whose underlying form is tt but not kk\n            const ls = this.preprocessEuphonicFinal(letters);\n            ls.push(version2_1.lowerLettersTonal.get(version2_1.TonalLetterTags.tt));\n            return ls;\n        }\n        return letters;\n    }\n    replaceEuphonicFinalTonal(letters) {\n        let literal = letters.map(x => x.literal).join('');\n        if (literal.length > 1 && matcher_1.regexJlsF.test(literal)) {\n            const ls = this.preprocessEuphonicFinalTonal(letters, literal, matcher_1.regexJlsF, 1);\n            return ls;\n        }\n        else if (literal.length > 1 && matcher_1.regexJjllssWx.test(literal)) {\n            const ls = this.preprocessEuphonicFinalTonal(letters, literal, matcher_1.regexJjllssWx, 1);\n            return ls;\n        }\n        else if (literal.length > 2 && matcher_1.regexMnngHF.test(literal)) {\n            const ls = this.preprocessEuphonicFinalTonal(letters, literal, matcher_1.regexMnngHF, 2);\n            return ls;\n        }\n        else if (literal.length > 2 && matcher_1.regexMnngHhWX.test(literal)) {\n            const ls = this.preprocessEuphonicFinalTonal(letters, literal, matcher_1.regexMnngHhWX, 2);\n            return ls;\n        }\n        return letters;\n    }\n    preprocess(graphemes) {\n        let ltrs = new Array();\n        ltrs = graphemes.map(it => it.letter);\n        ltrs = this.replaceEuphonicFinal(ltrs);\n        ltrs = this.replaceEuphonicFinalTonal(ltrs);\n        return ltrs;\n    }\n    postprocessEuphonicTtT(pattern) {\n        if ((pattern.letters[pattern.letters.length - 1].literal === version2_1.TonalLetterTags.t ||\n            pattern.letters[pattern.letters.length - 1].literal === version2_1.TonalLetterTags.tt) &&\n            this.euphonicFinals.length > 0) {\n            pattern.letters.pop();\n            pattern.pattern.pop();\n            const fnl = this.euphonicFinals.pop();\n            if (fnl) {\n                pattern.letters.push(fnl);\n                const snd = version2_1.tonalPositionalSounds.get(fnl.literal);\n                if (snd)\n                    pattern.pattern.push(snd(version2_1.TonalSoundTags.stopFinal));\n            }\n        }\n        else if (this.euphonicFinalTonals.length > 0) {\n            const fnl = this.euphonicFinalTonals.pop();\n            if (fnl) {\n                if (fnl.letters.length == 1) {\n                    pattern.letters.splice(fnl.index, 1, fnl.letters[0]);\n                    const snd = version2_1.tonalPositionalSounds.get(fnl.letters[0].literal);\n                    if (snd)\n                        pattern.pattern.splice(fnl.index, 1, snd(version2_1.TonalSoundTags.stopFinal));\n                }\n                else if (fnl.letters.length == 2) {\n                    // console.log(pattern)\n                    pattern.letters.splice(fnl.index, 1, fnl.letters[0], fnl.letters[1]);\n                    const snd1 = version2_1.tonalPositionalSounds.get(fnl.letters[0].literal);\n                    const snd2 = version2_1.tonalPositionalSounds.get(fnl.letters[1].literal);\n                    if (snd1 && snd2)\n                        pattern.pattern.splice(fnl.index, 1, snd1(version2_1.TonalSoundTags.nasalFinal), snd2(version2_1.TonalSoundTags.stopFinal));\n                    // console.log(pattern)\n                }\n            }\n        }\n        return pattern;\n    }\n    postprocess(matched) {\n        const morphemes = this.createMorphemes();\n        for (let i in matched) {\n            const ptn = this.postprocessEuphonicTtT(matched[i]);\n            if (this.isCombiningAy(matched)) {\n                // ~fa, ~xa, fay, or ~xay\n                morphemes.push(this.createMorpheme(ptn, new CombiningAy()));\n            }\n            else if (this.isReduplicated3x(matched)) {\n                // reduplicate by 3\n                morphemes.push(this.createMorpheme(ptn, new TonalReduplication(matched[2].pattern)));\n            }\n            else {\n                morphemes.push(this.createMorpheme(ptn, new TonalUncombiningForms()));\n            }\n        }\n        return morphemes;\n    }\n    makeMorphemes(graphemes) {\n        const ltrs = this.preprocess(graphemes);\n        const ptns = this.make(ltrs, syllabifyTonal);\n        const ms = this.postprocess(ptns);\n        return ms;\n    }\n}\nexports.TonalUncombiningMorphemeMaker = TonalUncombiningMorphemeMaker;\n//# sourceMappingURL=morpheme.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst phraseme_1 = require(\"../phraseme\");\nclass TonalPhrase extends phraseme_1.Phrase {\n    constructor(words) {\n        super();\n        this.words = new Array();\n        if (words) {\n            let len = words.length;\n            for (let i = 0; i < len; i++) {\n                if (i > 0)\n                    this.literal += ' ';\n                this.pushWord(words[i]);\n            }\n            this.concat();\n        }\n    }\n    popWord() {\n        // get rid off the last word from array\n        this.words = this.words.slice(0, this.words.length - 1);\n        this.concat();\n    }\n    pushWord(w) {\n        this.words.push(w);\n        this.concat();\n    }\n    concat() {\n        if (this.words.length > 0) {\n            if (this.words.filter(x => x && x.literal.length > 0).length == 0) {\n                this.literal = '';\n            }\n            else\n                this.literal = this.words.map(x => (x ? x.literal : '')).join(' ');\n        }\n    }\n}\nexports.TonalPhrase = TonalPhrase;\n//# sourceMappingURL=phraseme.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst soundgen_1 = require(\"./soundgen\");\nconst grapheme_1 = require(\"../grapheme\");\nconst lexicalroots2_1 = require(\"./lexicalroots2\");\nclass Prediction {\n    predict(strs) {\n        const soundSeqs = new Array();\n        for (let j = 0; j < soundgen_1.syllableCompositions.length; j++) {\n            let sg = new grapheme_1.SoundGeneration();\n            sg.predictive = true;\n            sg.letters = strs;\n            sg = soundgen_1.syllableCompositions[j](sg);\n            if (sg.letters.length != sg.sounds.length || sg.matching != true) {\n                // the pattern is not matched, the first unmatched set of sounds\n                // is then returned as a possible prompt\n                sg.predictions.map(x => soundSeqs.push(x));\n            }\n        }\n        // console.log(soundSeqs);\n        const dupes = new Array();\n        soundSeqs.map(i => i.map(j => dupes.push([j.toString(), j.name])));\n        let dedupes = dupes.reduce(function (accumulator, curr) {\n            if (accumulator.filter(x => x[0] === curr[0]).length == 0) {\n                accumulator.push(curr);\n            }\n            return accumulator;\n        }, []);\n        // console.log(dedupes);\n        // for valid prompts\n        const prompts = dedupes.filter(x => lexicalroots2_1.isInLexcialRoots(strs.join('') + x[0]));\n        // console.log(prompts);\n        return prompts;\n    }\n}\nexports.Prediction = Prediction;\n//# sourceMappingURL=prediction.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst grapheme_1 = require(\"../grapheme\");\nconst version2_1 = require(\"./version2\");\nconst collections_1 = require(\"./collections\");\nfunction initialConsonant(sg) {\n    const sis = new version2_1.InitialSounds();\n    if (sis.includes(sg.letters[sg.sounds.length])) {\n        const ps = version2_1.tonalPositionalSounds.get(sg.letters[sg.sounds.length]);\n        if (ps) {\n            const s = ps(version2_1.TonalSoundTags.initial);\n            if (s)\n                sg.sounds.push(s);\n        }\n    }\n    else\n        sg.matching = false;\n    return sg;\n}\nfunction stopFinalConsonant(sg) {\n    if (!sg.matching)\n        return sg;\n    const ssfs = new version2_1.StopFinalSounds();\n    if (ssfs.includes(sg.letters[sg.sounds.length])) {\n        const ps = version2_1.tonalPositionalSounds.get(sg.letters[sg.sounds.length]);\n        if (ps) {\n            const s = ps(version2_1.TonalSoundTags.stopFinal);\n            if (s)\n                sg.sounds.push(s);\n        }\n    }\n    else {\n        sg.matching = false;\n        if (sg.letters.length == sg.sounds.length && sg.predictive)\n            sg.predictions.push(ssfs.sounds);\n    }\n    return sg;\n}\nfunction neutralFinalConsonant(sg) {\n    if (!sg.matching)\n        return sg;\n    const snfs = new version2_1.NeutralFinalSounds();\n    if (snfs.includes(sg.letters[sg.sounds.length])) {\n        const ps = version2_1.tonalPositionalSounds.get(sg.letters[sg.sounds.length]);\n        if (ps) {\n            const s = ps(version2_1.TonalSoundTags.stopFinal);\n            if (s)\n                sg.sounds.push(s);\n        }\n    }\n    else {\n        sg.matching = false;\n        if (sg.letters.length == sg.sounds.length && sg.predictive)\n            sg.predictions.push(snfs.sounds);\n    }\n    return sg;\n}\nfunction nasalFinalConsonant(sg) {\n    if (!sg.matching)\n        return sg;\n    const snfs = new version2_1.NasalFinalSounds();\n    if (snfs.includes(sg.letters[sg.sounds.length])) {\n        const ps = version2_1.tonalPositionalSounds.get(sg.letters[sg.sounds.length]);\n        if (ps) {\n            const s = ps(version2_1.TonalSoundTags.nasalFinal);\n            if (s)\n                sg.sounds.push(s);\n        }\n    }\n    else {\n        sg.matching = false;\n        if (sg.letters.length == sg.sounds.length && sg.predictive)\n            sg.predictions.push(snfs.sounds);\n    }\n    return sg;\n}\nfunction vowel(sg) {\n    const sms = new version2_1.MedialSounds();\n    // const len = sg.sounds.length;\n    let toBePrompted = true;\n    let matches = 0;\n    for (let i = sg.sounds.length; i < sg.letters.length; i++) {\n        // console.log(`sg.sounds.length: ${sg.sounds.length}`);\n        if (sms.includes(sg.letters[i])) {\n            toBePrompted = false;\n            const ps = version2_1.tonalPositionalSounds.get(sg.letters[i]);\n            if (ps) {\n                const s = ps(version2_1.TonalSoundTags.medial);\n                matches++;\n                if (s)\n                    sg.sounds.push(s);\n            }\n        }\n        else {\n            toBePrompted = false;\n            if (matches == 0)\n                sg.matching = false;\n            break;\n        }\n    }\n    if (toBePrompted) {\n        if (sg.predictive && sg.letters.length > 0)\n            sg.predictions.push(sms.sounds);\n        sg.matching = false;\n    }\n    return sg;\n}\nfunction materLectionis(sg) {\n    const sml = new version2_1.MaterLectionisSounds();\n    if (sml.includes(sg.letters[sg.sounds.length])) {\n        const ps = version2_1.tonalPositionalSounds.get(sg.letters[sg.sounds.length]);\n        if (ps) {\n            const s = ps(version2_1.TonalSoundTags.medial);\n            if (s)\n                sg.sounds.push(s);\n        }\n    }\n    else\n        sg.matching = false;\n    return sg;\n}\nfunction nasalization(sg) {\n    if (!sg.matching)\n        return sg;\n    const sns = new version2_1.NasalizationSound();\n    if (sns.includes(sg.letters[sg.sounds.length])) {\n        const ps = version2_1.tonalPositionalSounds.get(sg.letters[sg.sounds.length]);\n        if (ps) {\n            const s = ps(version2_1.TonalSoundTags.nasalization);\n            if (s)\n                sg.sounds.push(s);\n        }\n    }\n    else {\n        sg.matching = false;\n        if (sg.letters.length == sg.sounds.length && sg.predictive)\n            sg.predictions.push(sns.sounds);\n    }\n    return sg;\n}\nfunction freeTone(sg) {\n    if (!sg.matching)\n        return sg;\n    const sfts = new version2_1.FreeTonalSounds();\n    if (sfts.includes(sg.letters[sg.sounds.length])) {\n        const ps = version2_1.tonalPositionalSounds.get(sg.letters[sg.sounds.length]);\n        if (ps) {\n            const s = ps(version2_1.TonalSoundTags.freeTonal);\n            if (s)\n                sg.sounds.push(s);\n        }\n    }\n    else {\n        sg.matching = false;\n        if (sg.letters.length == sg.sounds.length && sg.predictive)\n            sg.predictions.push(sfts.sounds);\n    }\n    return sg;\n}\nfunction checkedTone(sg) {\n    if (!sg.matching)\n        return sg;\n    const scts = new version2_1.CheckedTonalSounds();\n    if (scts.includes(sg.letters[sg.sounds.length])) {\n        const ps = version2_1.tonalPositionalSounds.get(sg.letters[sg.sounds.length]);\n        if (ps) {\n            const s = ps(version2_1.TonalSoundTags.checkedTonal);\n            if (s)\n                sg.sounds.push(s);\n        }\n    }\n    else {\n        sg.matching = false;\n        if (sg.letters.length == sg.sounds.length && sg.predictive)\n            sg.predictions.push(scts.sounds);\n    }\n    return sg;\n}\nfunction euphonicFinalConsonant(sg) {\n    if (!sg.matching)\n        return sg;\n    const efBgjklps = new version2_1.EuphonicFinalsBGJKLPS();\n    const efBbggjjkkllppss = new version2_1.EuphonicFinalsBBGGJJKKLLPPSS();\n    if (efBgjklps.includes(sg.letters[sg.sounds.length]) || efBbggjjkkllppss.includes(sg.letters[sg.sounds.length])) {\n        const ps = version2_1.tonalPositionalSounds.get(sg.letters[sg.sounds.length]);\n        if (ps) {\n            const s = ps(version2_1.TonalSoundTags.stopFinal);\n            if (s)\n                sg.sounds.push(s);\n        }\n    }\n    else {\n        sg.matching = false;\n        if (sg.letters.length == sg.sounds.length && sg.predictive && sg.predictEuphonicFinal) {\n            sg.predictions.push(efBgjklps.sounds);\n            sg.predictions.push(efBbggjjkkllppss.sounds);\n        }\n    }\n    return sg;\n}\n// common syllables\nconst scV = grapheme_1.pipe(vowel);\nconst scM = grapheme_1.pipe(materLectionis);\nconst scVT = grapheme_1.pipe(vowel, freeTone);\nconst scMT = grapheme_1.pipe(materLectionis, freeTone);\n//const scMC = pipe(materLectionis, neutralFinalConsonant);\nconst scCV = grapheme_1.pipe(initialConsonant, vowel);\nconst scVC1 = grapheme_1.pipe(vowel, stopFinalConsonant);\nconst scVC2 = grapheme_1.pipe(vowel, nasalFinalConsonant);\nconst scVCT1 = grapheme_1.pipe(vowel, stopFinalConsonant, checkedTone);\nconst scVCT2 = grapheme_1.pipe(vowel, nasalFinalConsonant, freeTone);\nconst scCVT = grapheme_1.pipe(initialConsonant, vowel, freeTone);\nconst scCVC1 = grapheme_1.pipe(initialConsonant, vowel, stopFinalConsonant);\nconst scCVC2 = grapheme_1.pipe(initialConsonant, vowel, nasalFinalConsonant);\nconst scCVCT1 = grapheme_1.pipe(initialConsonant, vowel, stopFinalConsonant, checkedTone);\nconst scCVCT2 = grapheme_1.pipe(initialConsonant, vowel, nasalFinalConsonant, freeTone);\n//const scCVCC = pipe(initialConsonant, vowel, nasalFinalConsonant, neutralFinalConsonant);\n// consonant syllables\nconst scCC = grapheme_1.pipe(initialConsonant, nasalFinalConsonant);\nconst scCCT = grapheme_1.pipe(initialConsonant, nasalFinalConsonant, freeTone);\nconst scCCC = grapheme_1.pipe(initialConsonant, nasalFinalConsonant, neutralFinalConsonant);\nconst scCCCT = grapheme_1.pipe(initialConsonant, nasalFinalConsonant, neutralFinalConsonant, checkedTone);\n// nasalization syllables\nconst scVN = grapheme_1.pipe(vowel, nasalization);\nconst scVNT = grapheme_1.pipe(vowel, nasalization, freeTone);\nconst scCVN = grapheme_1.pipe(initialConsonant, vowel, nasalization);\nconst scCVNT = grapheme_1.pipe(initialConsonant, vowel, nasalization, freeTone);\n//const scVNC = pipe(vowel, nasalization, neutralFinalConsonant);\n//const scVNCT = pipe(vowel, nasalization, neutralFinalConsonant, checkedTone);\nconst scCVNC = grapheme_1.pipe(initialConsonant, vowel, nasalization, neutralFinalConsonant);\nconst scCVNCT = grapheme_1.pipe(initialConsonant, vowel, nasalization, neutralFinalConsonant, checkedTone);\n// euphonic syllables\nconst scVC3 = grapheme_1.pipe(vowel, euphonicFinalConsonant);\nconst scVCT3 = grapheme_1.pipe(vowel, euphonicFinalConsonant, checkedTone);\nconst scCVC3 = grapheme_1.pipe(initialConsonant, vowel, euphonicFinalConsonant);\nconst scCVCT3 = grapheme_1.pipe(initialConsonant, vowel, euphonicFinalConsonant, checkedTone);\nconst scCVCCT = grapheme_1.pipe(initialConsonant, vowel, nasalFinalConsonant, neutralFinalConsonant, checkedTone);\n// syllable compositions or patterns\nexports.syllableCompositions = [\n    scV,\n    scM,\n    scVT,\n    scMT,\n    scCV,\n    scVC1,\n    scVC2,\n    scVCT1,\n    scVCT2,\n    scCVT,\n    scCVC1,\n    scCVC2,\n    scCVCT1,\n    scCVCT2,\n    scCC,\n    scCCT,\n    scCCC,\n    scCCCT,\n    scVN,\n    scVNT,\n    scCVN,\n    scCVNT,\n    scCVNC,\n    scCVNCT,\n    scVC3,\n    scVCT3,\n    scCVC3,\n    scCVCT3,\n    scCVCCT\n];\nclass TonalSoundGenerator {\n    isStopFinal(str) {\n        if (new version2_1.StopFinalSounds().includes(str))\n            return true;\n        return false;\n    }\n    genChecked(ltrs) {\n        const tos = collections_1.combiningRules.get(ltrs[ltrs.length - 1]);\n        let strs = new Array();\n        strs.push(ltrs);\n        // console.debug(tos);\n        if (tos) {\n            for (let i in tos) {\n                let syl = new Array();\n                Object.assign(syl, ltrs);\n                syl.push(version2_1.lowerLettersTonal.get(tos[i]).literal);\n                strs.push(syl);\n            }\n        }\n        return strs;\n    }\n    generate(letters) {\n        let strs = new Array();\n        const sequences = new Array(); // to be returned\n        if (this.isStopFinal(letters[letters.length - 1])) {\n            strs = this.genChecked(letters);\n        }\n        else {\n            strs.push(letters);\n        }\n        for (let i in strs) {\n            // generates all needed sounds to be processed\n            for (let j = 0; j < exports.syllableCompositions.length; j++) {\n                let sg = new grapheme_1.SoundGeneration();\n                sg.letters = strs[i];\n                //console.log(`j: ${j}`)\n                sg = exports.syllableCompositions[j](sg);\n                if (sg.letters.length == sg.sounds.length && sg.matching == true) {\n                    sequences.push(sg.sounds);\n                    break;\n                }\n            }\n        }\n        //console.log(sequences)\n        return sequences;\n    }\n}\nexports.TonalSoundGenerator = TonalSoundGenerator;\n//# sourceMappingURL=soundgen.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst grapheme_1 = require(\"../grapheme\");\n//------------------------------------------------------------------------------\nclass Morph {\n}\nexports.Morph = Morph;\n//------------------------------------------------------------------------------\nclass Allomorph extends Morph {\n    constructor() {\n        super(...arguments);\n        this.tonal = new Tonal();\n    }\n    toString() {\n        if (this.tonal.toString().length == 0) {\n            // return string 'zero' for first tone. member variable characters of graph is still null.\n            return TonalLetterTags.zero;\n        }\n        else\n            return this.tonal.toString();\n    }\n}\nexports.Allomorph = Allomorph;\nclass FreeAllomorph extends Allomorph {\n}\nexports.FreeAllomorph = FreeAllomorph;\nclass CheckedAllomorph extends Allomorph {\n    constructor() {\n        super(...arguments);\n        this.final = new Final();\n    }\n    toString() {\n        if (this.tonal.toString()) {\n            return this.final.toString() + this.tonal.toString();\n        }\n        return this.final.toString();\n    }\n}\nexports.CheckedAllomorph = CheckedAllomorph;\nclass TonalAffix extends Morph {\n    constructor() {\n        super(...arguments);\n        this.tonal = new Tonal();\n    }\n    toString() {\n        return this.tonal.toString();\n    }\n}\nexports.TonalAffix = TonalAffix;\nclass FreeAffix extends TonalAffix {\n}\nclass CheckedAffix extends TonalAffix {\n}\n//------------------------------------------------------------------------------\nvar TonalLetterTags;\n(function (TonalLetterTags) {\n    TonalLetterTags[\"a\"] = \"a\";\n    TonalLetterTags[\"e\"] = \"e\";\n    TonalLetterTags[\"i\"] = \"i\";\n    TonalLetterTags[\"o\"] = \"o\";\n    TonalLetterTags[\"u\"] = \"u\";\n    TonalLetterTags[\"ur\"] = \"ur\";\n    TonalLetterTags[\"c\"] = \"c\";\n    TonalLetterTags[\"d\"] = \"d\";\n    TonalLetterTags[\"ch\"] = \"ch\";\n    TonalLetterTags[\"j\"] = \"j\";\n    TonalLetterTags[\"q\"] = \"q\";\n    TonalLetterTags[\"s\"] = \"s\";\n    TonalLetterTags[\"v\"] = \"v\";\n    TonalLetterTags[\"m\"] = \"m\";\n    TonalLetterTags[\"n\"] = \"n\";\n    TonalLetterTags[\"ng\"] = \"ng\";\n    TonalLetterTags[\"nn\"] = \"nn\";\n    TonalLetterTags[\"f\"] = \"f\";\n    TonalLetterTags[\"w\"] = \"w\";\n    TonalLetterTags[\"x\"] = \"x\";\n    TonalLetterTags[\"xx\"] = \"xx\";\n    TonalLetterTags[\"y\"] = \"y\";\n    TonalLetterTags[\"z\"] = \"z\";\n    TonalLetterTags[\"zx\"] = \"zx\";\n    TonalLetterTags[\"b\"] = \"b\";\n    TonalLetterTags[\"g\"] = \"g\";\n    TonalLetterTags[\"l\"] = \"l\";\n    TonalLetterTags[\"k\"] = \"k\";\n    TonalLetterTags[\"p\"] = \"p\";\n    TonalLetterTags[\"t\"] = \"t\";\n    TonalLetterTags[\"kk\"] = \"kk\";\n    TonalLetterTags[\"pp\"] = \"pp\";\n    TonalLetterTags[\"tt\"] = \"tt\";\n    TonalLetterTags[\"hh\"] = \"hh\";\n    TonalLetterTags[\"bb\"] = \"bb\";\n    TonalLetterTags[\"gg\"] = \"gg\";\n    TonalLetterTags[\"jj\"] = \"jj\";\n    TonalLetterTags[\"ll\"] = \"ll\";\n    TonalLetterTags[\"ss\"] = \"ss\";\n    TonalLetterTags[\"h\"] = \"h\";\n    TonalLetterTags[\"zero\"] = \"zero\";\n    TonalLetterTags[\"er\"] = \"er\";\n    TonalLetterTags[\"ir\"] = \"ir\";\n    TonalLetterTags[\"or\"] = \"or\";\n})(TonalLetterTags = exports.TonalLetterTags || (exports.TonalLetterTags = {}));\nclass LettersOfTonal extends grapheme_1.Letters {\n}\nexports.LettersOfTonal = LettersOfTonal;\nexports.lowerLettersTonal = new LettersOfTonal([\n    TonalLetterTags.a,\n    TonalLetterTags.e,\n    TonalLetterTags.i,\n    TonalLetterTags.o,\n    TonalLetterTags.u,\n    TonalLetterTags.ur,\n    TonalLetterTags.c,\n    TonalLetterTags.d,\n    TonalLetterTags.ch,\n    TonalLetterTags.j,\n    TonalLetterTags.q,\n    TonalLetterTags.s,\n    TonalLetterTags.v,\n    TonalLetterTags.m,\n    TonalLetterTags.n,\n    TonalLetterTags.ng,\n    TonalLetterTags.nn,\n    TonalLetterTags.w,\n    TonalLetterTags.xx,\n    TonalLetterTags.z,\n    TonalLetterTags.zx,\n    TonalLetterTags.x,\n    TonalLetterTags.y,\n    TonalLetterTags.b,\n    TonalLetterTags.g,\n    TonalLetterTags.l,\n    TonalLetterTags.k,\n    TonalLetterTags.p,\n    TonalLetterTags.t,\n    TonalLetterTags.kk,\n    TonalLetterTags.pp,\n    TonalLetterTags.tt,\n    TonalLetterTags.hh,\n    TonalLetterTags.bb,\n    TonalLetterTags.gg,\n    TonalLetterTags.jj,\n    TonalLetterTags.ll,\n    TonalLetterTags.ss,\n    TonalLetterTags.f,\n    TonalLetterTags.h,\n    TonalLetterTags.er,\n    TonalLetterTags.ir,\n    TonalLetterTags.or\n]);\n//------------------------------------------------------------------------------\nvar TonalSoundTags;\n(function (TonalSoundTags) {\n    TonalSoundTags[\"initial\"] = \"initial\";\n    TonalSoundTags[\"medial\"] = \"medial\";\n    TonalSoundTags[\"nasalization\"] = \"nasalization\";\n    TonalSoundTags[\"stopFinal\"] = \"stopFinal\";\n    TonalSoundTags[\"nasalFinal\"] = \"nasalFinal\";\n    TonalSoundTags[\"checkedTonal\"] = \"checkedTonal\";\n    TonalSoundTags[\"freeTonal\"] = \"freeTonal\";\n})(TonalSoundTags = exports.TonalSoundTags || (exports.TonalSoundTags = {}));\nclass Initial extends grapheme_1.Sound {\n    constructor() {\n        super(...arguments);\n        this.name = TonalSoundTags.initial;\n    }\n}\nexports.Initial = Initial;\nclass Medial extends grapheme_1.Sound {\n    constructor() {\n        super(...arguments);\n        this.name = TonalSoundTags.medial;\n    }\n}\nexports.Medial = Medial;\nclass Final extends grapheme_1.Sound {\n    constructor() {\n        super(...arguments);\n        this.name = '';\n    }\n}\nexports.Final = Final;\nclass Nasalization extends grapheme_1.Sound {\n    constructor() {\n        super(...arguments);\n        this.name = TonalSoundTags.nasalization;\n    }\n}\nexports.Nasalization = Nasalization;\nclass Tonal extends grapheme_1.Sound {\n    constructor() {\n        super(...arguments);\n        this.name = '';\n    }\n}\nexports.Tonal = Tonal;\nclass FreeTonal extends Tonal {\n    constructor() {\n        super(...arguments);\n        this.name = TonalSoundTags.freeTonal;\n    }\n}\nexports.FreeTonal = FreeTonal;\nclass CheckedTonal extends Tonal {\n    constructor() {\n        super(...arguments);\n        this.name = TonalSoundTags.checkedTonal;\n    }\n}\nexports.CheckedTonal = CheckedTonal;\nclass StopFinal extends Final {\n    constructor() {\n        super(...arguments);\n        this.name = TonalSoundTags.stopFinal;\n    }\n}\nexports.StopFinal = StopFinal;\nclass NasalFinal extends Final {\n    constructor() {\n        super(...arguments);\n        this.name = TonalSoundTags.nasalFinal;\n    }\n}\nexports.NasalFinal = NasalFinal;\nclass MedialA extends Medial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.a);\n    }\n}\nclass MedialE extends Medial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.e);\n    }\n}\nclass MedialI extends Medial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.i);\n    }\n}\nclass MedialO extends Medial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.o);\n    }\n}\nclass MedialU extends Medial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.u);\n    }\n}\nclass MedialUR extends Medial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.ur);\n    }\n}\nclass MedialER extends Medial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.er);\n    }\n}\nclass MedialIR extends Medial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.ir);\n    }\n}\nclass MedialOR extends Medial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.or);\n    }\n}\nclass MaterLectionisM extends Medial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.m);\n    }\n}\nclass MaterLectionisN extends Medial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.n);\n    }\n}\nclass MaterLectionisNG extends Medial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.ng);\n    }\n}\nclass InitialC extends Initial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.c);\n    }\n}\nclass InitialCH extends Initial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.ch);\n    }\n}\nclass InitialJ extends Initial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.j);\n    }\n}\nclass InitialL extends Initial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.l);\n    }\n}\nclass InitialQ extends Initial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.q);\n    }\n}\nclass InitialS extends Initial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.s);\n    }\n}\nclass InitialV extends Initial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.v);\n    }\n}\nclass InitialH extends Initial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.h);\n    }\n}\nclass InitialP extends Initial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.p);\n    }\n}\nclass InitialT extends Initial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.t);\n    }\n}\nclass InitialK extends Initial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.k);\n    }\n}\nclass InitialB extends Initial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.b);\n    }\n}\nclass InitialD extends Initial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.d);\n    }\n}\nclass InitialG extends Initial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.g);\n    }\n}\nclass InitialM extends Initial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.m);\n    }\n}\nclass InitialN extends Initial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.n);\n    }\n}\nclass InitialNG extends Initial {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.ng);\n    }\n}\nclass ZeroTonal extends Tonal {\n    constructor() {\n        super(...arguments);\n        this.characters = [];\n    }\n}\nexports.ZeroTonal = ZeroTonal;\nclass FreeTonalZ extends FreeTonal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.z);\n    }\n}\nexports.FreeTonalZ = FreeTonalZ;\nclass FreeTonalW extends FreeTonal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.w);\n    }\n}\nexports.FreeTonalW = FreeTonalW;\nclass FreeTonalF extends FreeTonal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.f);\n    }\n}\nexports.FreeTonalF = FreeTonalF;\nclass FreeTonalXX extends FreeTonal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.xx);\n    }\n}\nexports.FreeTonalXX = FreeTonalXX;\nclass FreeTonalZX extends FreeTonal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.zx);\n    }\n}\nexports.FreeTonalZX = FreeTonalZX;\nclass FreeTonalX extends FreeTonal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.x);\n    }\n}\nexports.FreeTonalX = FreeTonalX;\nclass FreeTonalY extends FreeTonal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.y);\n    }\n}\nexports.FreeTonalY = FreeTonalY;\nclass CheckedTonalW extends CheckedTonal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.w);\n    }\n}\nexports.CheckedTonalW = CheckedTonalW;\nclass CheckedTonalF extends CheckedTonal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.f);\n    }\n}\nexports.CheckedTonalF = CheckedTonalF;\nclass CheckedTonalX extends CheckedTonal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.x);\n    }\n}\nexports.CheckedTonalX = CheckedTonalX;\nclass CheckedTonalY extends CheckedTonal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.y);\n    }\n}\nexports.CheckedTonalY = CheckedTonalY;\nclass FinalP extends StopFinal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.p);\n    }\n}\nexports.FinalP = FinalP;\nclass FinalT extends StopFinal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.t);\n    }\n}\nexports.FinalT = FinalT;\nclass FinalK extends StopFinal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.k);\n    }\n}\nexports.FinalK = FinalK;\nclass FinalH extends StopFinal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.h);\n    }\n}\nexports.FinalH = FinalH;\nclass FinalPP extends StopFinal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.pp);\n    }\n}\nexports.FinalPP = FinalPP;\nclass FinalTT extends StopFinal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.tt);\n    }\n}\nexports.FinalTT = FinalTT;\nclass FinalKK extends StopFinal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.kk);\n    }\n}\nexports.FinalKK = FinalKK;\nclass FinalHH extends StopFinal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.hh);\n    }\n}\nexports.FinalHH = FinalHH;\nclass FinalB extends StopFinal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.b);\n    }\n}\nclass FinalL extends StopFinal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.l);\n    }\n}\nclass FinalG extends StopFinal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.g);\n    }\n}\nclass FinalJ extends StopFinal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.j);\n    }\n}\nclass FinalS extends StopFinal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.s);\n    }\n}\nclass FinalBB extends StopFinal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.bb);\n    }\n}\nclass FinalLL extends StopFinal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.ll);\n    }\n}\nclass FinalGG extends StopFinal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.gg);\n    }\n}\nclass FinalJJ extends StopFinal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.jj);\n    }\n}\nclass FinalSS extends StopFinal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.ss);\n    }\n}\nclass FinalM extends NasalFinal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.m);\n    }\n}\nclass FinalN extends NasalFinal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.n);\n    }\n}\nclass FinalNG extends NasalFinal {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.ng);\n    }\n}\nclass NasalizationNN extends Nasalization {\n    constructor() {\n        super(...arguments);\n        this.characters = this.makeCharacters(TonalLetterTags.nn);\n    }\n}\nclass NasalizationSound extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new NasalizationNN());\n    }\n}\nexports.NasalizationSound = NasalizationSound;\nclass NasalFinalSounds extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new FinalM());\n        this.sounds.push(new FinalN());\n        this.sounds.push(new FinalNG());\n    }\n}\nexports.NasalFinalSounds = NasalFinalSounds;\nclass NeutralFinalSounds extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new FinalH());\n        this.sounds.push(new FinalHH());\n    }\n}\nexports.NeutralFinalSounds = NeutralFinalSounds;\nclass MedialSounds extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new MedialA());\n        this.sounds.push(new MedialE());\n        this.sounds.push(new MedialI());\n        this.sounds.push(new MedialO());\n        this.sounds.push(new MedialU());\n        this.sounds.push(new MedialUR());\n    }\n}\nexports.MedialSounds = MedialSounds;\nclass MaterLectionisSounds extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new MaterLectionisM());\n        this.sounds.push(new MaterLectionisN());\n        this.sounds.push(new MaterLectionisNG());\n    }\n}\nexports.MaterLectionisSounds = MaterLectionisSounds;\nclass InitialSounds extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new InitialP());\n        this.sounds.push(new InitialT());\n        this.sounds.push(new InitialK());\n        this.sounds.push(new InitialB());\n        this.sounds.push(new InitialD());\n        this.sounds.push(new InitialG());\n        this.sounds.push(new InitialH());\n        this.sounds.push(new InitialC());\n        this.sounds.push(new InitialCH());\n        this.sounds.push(new InitialJ());\n        this.sounds.push(new InitialL());\n        this.sounds.push(new InitialQ());\n        this.sounds.push(new InitialS());\n        this.sounds.push(new InitialV());\n        this.sounds.push(new InitialM());\n        this.sounds.push(new InitialN());\n        this.sounds.push(new InitialNG());\n    }\n}\nexports.InitialSounds = InitialSounds;\nclass FreeTonalSounds extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new FreeTonalZ());\n        this.sounds.push(new FreeTonalW());\n        this.sounds.push(new FreeTonalXX());\n        this.sounds.push(new FreeTonalF());\n        this.sounds.push(new FreeTonalZX());\n        this.sounds.push(new FreeTonalX());\n        this.sounds.push(new FreeTonalY());\n    }\n}\nexports.FreeTonalSounds = FreeTonalSounds;\nclass CheckedTonalSounds extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new CheckedTonalF());\n        this.sounds.push(new CheckedTonalY());\n        this.sounds.push(new CheckedTonalW());\n        this.sounds.push(new CheckedTonalX());\n    }\n}\nexports.CheckedTonalSounds = CheckedTonalSounds;\nclass StopFinalSounds extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new FinalP());\n        this.sounds.push(new FinalT());\n        this.sounds.push(new FinalK());\n        this.sounds.push(new FinalH());\n        this.sounds.push(new FinalPP());\n        this.sounds.push(new FinalTT());\n        this.sounds.push(new FinalKK());\n        this.sounds.push(new FinalHH());\n    }\n}\nexports.StopFinalSounds = StopFinalSounds;\nclass EuphonicFinalsBGJKLPS extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new FinalB());\n        this.sounds.push(new FinalG());\n        this.sounds.push(new FinalJ());\n        this.sounds.push(new FinalK());\n        this.sounds.push(new FinalL());\n        this.sounds.push(new FinalP());\n        this.sounds.push(new FinalS());\n    }\n}\nexports.EuphonicFinalsBGJKLPS = EuphonicFinalsBGJKLPS;\nclass EuphonicFinalsBBGGJJKKLLPPSS extends grapheme_1.SetOfSounds {\n    constructor() {\n        super();\n        this.sounds.push(new FinalBB());\n        this.sounds.push(new FinalGG());\n        this.sounds.push(new FinalJJ());\n        this.sounds.push(new FinalKK());\n        this.sounds.push(new FinalLL());\n        this.sounds.push(new FinalPP());\n        this.sounds.push(new FinalSS());\n    }\n}\nexports.EuphonicFinalsBBGGJJKKLLPPSS = EuphonicFinalsBBGGJJKKLLPPSS;\n//------------------------------------------------------------------------------\nfunction positionalSound(sounds) {\n    return (t) => {\n        for (let i in sounds) {\n            if (sounds[i].name === t)\n                return sounds[i];\n        }\n        return new grapheme_1.Sound();\n    };\n}\nexports.positionalSound = positionalSound;\nconst psA = positionalSound([new MedialA()]);\nconst psB = positionalSound([new InitialB(), new FinalB()]);\nconst psBb = positionalSound([new FinalBB()]);\nconst psC = positionalSound([new InitialC()]);\nconst psCh = positionalSound([new InitialCH()]);\nconst psD = positionalSound([new InitialD()]);\nconst psE = positionalSound([new MedialE()]);\nconst psEr = positionalSound([new MedialER()]);\nconst psF = positionalSound([new FreeTonalF(), new CheckedTonalF()]);\nconst psG = positionalSound([new InitialG(), new FinalG()]);\nconst psGg = positionalSound([new FinalGG()]);\nconst psH = positionalSound([new InitialH(), new FinalH()]);\nconst psHh = positionalSound([new FinalHH()]);\nconst psI = positionalSound([new MedialI()]);\nconst psIr = positionalSound([new MedialIR()]);\nconst psJ = positionalSound([new InitialJ(), new FinalJ()]);\nconst psJj = positionalSound([new FinalJJ()]);\nconst psK = positionalSound([new InitialK(), new FinalK()]);\nconst psKk = positionalSound([new FinalKK()]);\nconst psL = positionalSound([new InitialL(), new FinalL()]);\nconst psLl = positionalSound([new FinalLL()]);\nconst psM = positionalSound([new InitialM(), new MaterLectionisM(), new FinalM()]);\nconst psN = positionalSound([new InitialN(), new MaterLectionisN(), new FinalN()]);\nconst psNn = positionalSound([new NasalizationNN()]);\nconst psNg = positionalSound([new InitialNG(), new MaterLectionisNG(), new FinalNG()]);\nconst psO = positionalSound([new MedialO()]);\nconst psOr = positionalSound([new MedialOR()]);\nconst psP = positionalSound([new InitialP(), new FinalP()]);\nconst psPp = positionalSound([new FinalPP()]);\nconst psQ = positionalSound([new InitialQ()]);\nconst psS = positionalSound([new InitialS(), new FinalS()]);\nconst psSs = positionalSound([new FinalSS()]);\nconst psT = positionalSound([new InitialT(), new FinalT()]);\nconst psTt = positionalSound([new FinalTT()]);\nconst psU = positionalSound([new MedialU()]);\nconst psUr = positionalSound([new MedialUR()]);\nconst psV = positionalSound([new InitialV()]);\nconst psW = positionalSound([new FreeTonalW(), new CheckedTonalW()]);\nconst psX = positionalSound([new FreeTonalX(), new CheckedTonalX()]);\nconst psXx = positionalSound([new FreeTonalXX()]);\nconst psY = positionalSound([new FreeTonalY(), new CheckedTonalY()]);\nconst psZ = positionalSound([new FreeTonalZ()]);\nconst psZx = positionalSound([new FreeTonalZX()]);\n//------------------------------------------------------------------------------\nexports.tonalPositionalSounds = new Map()\n    .set(TonalLetterTags.a, psA)\n    .set(TonalLetterTags.b, psB)\n    .set(TonalLetterTags.bb, psBb)\n    .set(TonalLetterTags.c, psC)\n    .set(TonalLetterTags.ch, psCh)\n    .set(TonalLetterTags.d, psD)\n    .set(TonalLetterTags.e, psE)\n    .set(TonalLetterTags.er, psEr)\n    .set(TonalLetterTags.f, psF)\n    .set(TonalLetterTags.g, psG)\n    .set(TonalLetterTags.gg, psGg)\n    .set(TonalLetterTags.h, psH)\n    .set(TonalLetterTags.hh, psHh)\n    .set(TonalLetterTags.i, psI)\n    .set(TonalLetterTags.ir, psIr)\n    .set(TonalLetterTags.j, psJ)\n    .set(TonalLetterTags.jj, psJj)\n    .set(TonalLetterTags.k, psK)\n    .set(TonalLetterTags.kk, psKk)\n    .set(TonalLetterTags.l, psL)\n    .set(TonalLetterTags.ll, psLl)\n    .set(TonalLetterTags.m, psM)\n    .set(TonalLetterTags.n, psN)\n    .set(TonalLetterTags.nn, psNn)\n    .set(TonalLetterTags.ng, psNg)\n    .set(TonalLetterTags.o, psO)\n    .set(TonalLetterTags.or, psOr)\n    .set(TonalLetterTags.p, psP)\n    .set(TonalLetterTags.pp, psPp)\n    .set(TonalLetterTags.q, psQ)\n    .set(TonalLetterTags.s, psS)\n    .set(TonalLetterTags.ss, psSs)\n    .set(TonalLetterTags.t, psT)\n    .set(TonalLetterTags.tt, psTt)\n    .set(TonalLetterTags.u, psU)\n    .set(TonalLetterTags.ur, psUr)\n    .set(TonalLetterTags.v, psV)\n    .set(TonalLetterTags.w, psW)\n    .set(TonalLetterTags.x, psX)\n    .set(TonalLetterTags.xx, psXx)\n    .set(TonalLetterTags.y, psY)\n    .set(TonalLetterTags.z, psZ)\n    .set(TonalLetterTags.zx, psZx);\n//------------------------------------------------------------------------------\nclass ZeroAllomorph extends FreeAllomorph {\n    constructor() {\n        super(...arguments);\n        this.tonal = new ZeroTonal();\n    }\n}\nexports.ZeroAllomorph = ZeroAllomorph;\nclass AllomorphF extends FreeAllomorph {\n    constructor() {\n        super(...arguments);\n        this.tonal = new FreeTonalF();\n    }\n}\nclass AllomorphZ extends FreeAllomorph {\n    constructor() {\n        super(...arguments);\n        this.tonal = new FreeTonalZ();\n    }\n}\nexports.AllomorphZ = AllomorphZ;\nclass AllomorphY extends FreeAllomorph {\n    constructor() {\n        super(...arguments);\n        this.tonal = new FreeTonalY();\n    }\n}\nexports.AllomorphY = AllomorphY;\nclass AllomorphW extends FreeAllomorph {\n    constructor() {\n        super(...arguments);\n        this.tonal = new FreeTonalW();\n    }\n}\nexports.AllomorphW = AllomorphW;\nclass AllomorphX extends FreeAllomorph {\n    constructor() {\n        super(...arguments);\n        this.tonal = new FreeTonalX();\n    }\n}\nexports.AllomorphX = AllomorphX;\nclass AllomorphXX extends FreeAllomorph {\n    constructor() {\n        super(...arguments);\n        this.tonal = new FreeTonalXX();\n    }\n}\nclass AllomorphZX extends FreeAllomorph {\n    constructor() {\n        super(...arguments);\n        this.tonal = new FreeTonalZX();\n    }\n}\nexports.freeAllomorphs = new Map()\n    .set(TonalLetterTags.f, new AllomorphF())\n    .set(TonalLetterTags.w, new AllomorphW())\n    .set(TonalLetterTags.xx, new AllomorphXX())\n    .set(TonalLetterTags.z, new AllomorphZ())\n    .set(TonalLetterTags.zx, new AllomorphZX())\n    .set(TonalLetterTags.y, new AllomorphY())\n    .set(TonalLetterTags.x, new AllomorphX());\nclass AllomorphP extends CheckedAllomorph {\n    constructor() {\n        super(...arguments);\n        this.final = new FinalP();\n    }\n}\nclass AllomorphT extends CheckedAllomorph {\n    constructor() {\n        super(...arguments);\n        this.final = new FinalT();\n    }\n}\nclass AllomorphK extends CheckedAllomorph {\n    constructor() {\n        super(...arguments);\n        this.final = new FinalK();\n    }\n}\nclass AllomorphH extends CheckedAllomorph {\n    constructor() {\n        super(...arguments);\n        this.final = new FinalH();\n    }\n}\nexports.AllomorphH = AllomorphH;\nclass AllomorphPP extends CheckedAllomorph {\n    constructor() {\n        super(...arguments);\n        this.final = new FinalPP();\n    }\n}\nclass AllomorphTT extends CheckedAllomorph {\n    constructor() {\n        super(...arguments);\n        this.final = new FinalTT();\n    }\n}\nclass AllomorphKK extends CheckedAllomorph {\n    constructor() {\n        super(...arguments);\n        this.final = new FinalKK();\n    }\n}\nclass AllomorphHH extends CheckedAllomorph {\n    constructor() {\n        super(...arguments);\n        this.final = new FinalHH();\n    }\n}\nclass AllomorphPF extends CheckedAllomorph {\n    constructor() {\n        super(...arguments);\n        this.final = new FinalP();\n        this.tonal = new CheckedTonalF();\n    }\n}\nclass AllomorphTF extends CheckedAllomorph {\n    constructor() {\n        super(...arguments);\n        this.final = new FinalT();\n        this.tonal = new CheckedTonalF();\n    }\n}\nclass AllomorphKF extends CheckedAllomorph {\n    constructor() {\n        super(...arguments);\n        this.final = new FinalK();\n        this.tonal = new CheckedTonalF();\n    }\n}\nclass AllomorphHF extends CheckedAllomorph {\n    constructor() {\n        super(...arguments);\n        this.final = new FinalH();\n        this.tonal = new CheckedTonalF();\n    }\n}\nclass AllomorphHY extends CheckedAllomorph {\n    constructor() {\n        super(...arguments);\n        this.final = new FinalH();\n        this.tonal = new CheckedTonalY();\n    }\n}\nexports.AllomorphHY = AllomorphHY;\nclass AllomorphPPW extends CheckedAllomorph {\n    constructor() {\n        super(...arguments);\n        this.final = new FinalPP();\n        this.tonal = new CheckedTonalW();\n    }\n}\nclass AllomorphTTW extends CheckedAllomorph {\n    constructor() {\n        super(...arguments);\n        this.final = new FinalTT();\n        this.tonal = new CheckedTonalW();\n    }\n}\nclass AllomorphKKW extends CheckedAllomorph {\n    constructor() {\n        super(...arguments);\n        this.final = new FinalKK();\n        this.tonal = new CheckedTonalW();\n    }\n}\nclass AllomorphHHW extends CheckedAllomorph {\n    constructor() {\n        super(...arguments);\n        this.final = new FinalHH();\n        this.tonal = new CheckedTonalW();\n    }\n}\nclass AllomorphPPX extends CheckedAllomorph {\n    constructor() {\n        super(...arguments);\n        this.final = new FinalPP();\n        this.tonal = new CheckedTonalX();\n    }\n}\nclass AllomorphTTX extends CheckedAllomorph {\n    constructor() {\n        super(...arguments);\n        this.final = new FinalTT();\n        this.tonal = new CheckedTonalX();\n    }\n}\nclass AllomorphKKX extends CheckedAllomorph {\n    constructor() {\n        super(...arguments);\n        this.final = new FinalKK();\n        this.tonal = new CheckedTonalX();\n    }\n}\nclass AllomorphHHX extends CheckedAllomorph {\n    constructor() {\n        super(...arguments);\n        this.final = new FinalHH();\n        this.tonal = new CheckedTonalX();\n    }\n}\nexports.checkedAllomorphs = new Map()\n    .set(TonalLetterTags.p, new AllomorphP())\n    .set(TonalLetterTags.t, new AllomorphT())\n    .set(TonalLetterTags.k, new AllomorphK())\n    .set(TonalLetterTags.h, new AllomorphH())\n    .set(TonalLetterTags.pp, new AllomorphPP())\n    .set(TonalLetterTags.tt, new AllomorphTT())\n    .set(TonalLetterTags.kk, new AllomorphKK())\n    .set(TonalLetterTags.hh, new AllomorphHH())\n    .set(TonalLetterTags.p + TonalLetterTags.f, new AllomorphPF())\n    .set(TonalLetterTags.t + TonalLetterTags.f, new AllomorphTF())\n    .set(TonalLetterTags.k + TonalLetterTags.f, new AllomorphKF())\n    .set(TonalLetterTags.h + TonalLetterTags.f, new AllomorphHF())\n    .set(TonalLetterTags.pp + TonalLetterTags.w, new AllomorphPPW())\n    .set(TonalLetterTags.tt + TonalLetterTags.w, new AllomorphTTW())\n    .set(TonalLetterTags.kk + TonalLetterTags.w, new AllomorphKKW())\n    .set(TonalLetterTags.hh + TonalLetterTags.w, new AllomorphHHW())\n    .set(TonalLetterTags.h + TonalLetterTags.y, new AllomorphHY())\n    .set(TonalLetterTags.pp + TonalLetterTags.x, new AllomorphPPX())\n    .set(TonalLetterTags.tt + TonalLetterTags.x, new AllomorphTTX())\n    .set(TonalLetterTags.kk + TonalLetterTags.x, new AllomorphKKX())\n    .set(TonalLetterTags.hh + TonalLetterTags.x, new AllomorphHHX());\nexports.combinedFreeAllomorphs = new Map()\n    .set(TonalLetterTags.w, new AllomorphW())\n    .set(TonalLetterTags.z, new AllomorphZ())\n    .set(TonalLetterTags.x, new AllomorphX())\n    .set(TonalLetterTags.y, new AllomorphY())\n    .set(TonalLetterTags.f, new AllomorphF());\nexports.uncombinedCheckedAllomorphs = new Map()\n    .set(TonalLetterTags.p, new AllomorphP())\n    .set(TonalLetterTags.t, new AllomorphT())\n    .set(TonalLetterTags.k, new AllomorphK())\n    .set(TonalLetterTags.h, new AllomorphH())\n    .set(TonalLetterTags.pp, new AllomorphPP())\n    .set(TonalLetterTags.tt, new AllomorphTT())\n    .set(TonalLetterTags.kk, new AllomorphKK())\n    .set(TonalLetterTags.hh, new AllomorphHH());\nexports.combinedCheckedAllomorphs = new Map()\n    .set(TonalLetterTags.p, [new AllomorphPF()])\n    .set(TonalLetterTags.t, [new AllomorphTF()])\n    .set(TonalLetterTags.k, [new AllomorphKF()])\n    .set(TonalLetterTags.h, [new AllomorphHF(), new AllomorphHY()])\n    .set(TonalLetterTags.pp, [new AllomorphPPW(), new AllomorphPPX()])\n    .set(TonalLetterTags.tt, [new AllomorphTTW(), new AllomorphTTX()])\n    .set(TonalLetterTags.kk, [new AllomorphKKW(), new AllomorphKKX()])\n    .set(TonalLetterTags.hh, [new AllomorphHHW(), new AllomorphHHX()]);\nexports.freeAllomorphUncombiningRules = new Map()\n    .set(TonalLetterTags.f, [new FreeTonalY()])\n    .set(TonalLetterTags.w, [new FreeTonalZ(), new FreeTonalX()])\n    .set(TonalLetterTags.xx, [new FreeTonalZ(), new FreeTonalF(), new FreeTonalX()])\n    .set(TonalLetterTags.z, [new FreeTonalX(), new FreeTonalF(), new ZeroTonal()])\n    .set(TonalLetterTags.zx, [])\n    .set(TonalLetterTags.x, [])\n    .set(TonalLetterTags.y, [new FreeTonalW()])\n    .set(TonalLetterTags.zero, [new FreeTonalY()]);\nexports.uncombiningRulesAy = new Map()\n    .set(TonalLetterTags.f, [new FreeTonalY(), new FreeTonalW()])\n    .set(TonalLetterTags.x, [new ZeroTonal(), new FreeTonalX(), new FreeTonalZ()]);\n//# sourceMappingURL=version2.js.map","import { useState } from 'react';\nimport { TonalPhrasalInflector } from 'taipa';\n\nfunction PhrasalVerbPage() {\n    const [input, setInput] = useState();\n\n    const handleChange = function(e: React.ChangeEvent<HTMLInputElement>) {\n        setInput(e.target.value);\n    };\n\n    const phrasalVerbs = [\n        ['koannw', 'diurh'],\n        ['longw', 'diurh']\n    ];\n\n    const matches = phrasalVerbs.filter(x => x.join(' ') === input);\n\n    const phinfl = new TonalPhrasalInflector();\n\n    let fr1 = phinfl.inflectToProceeding('', '');\n    if (matches[0]) {\n        fr1 = phinfl.inflectToProceeding(matches[0][0], matches[0][1]);\n    }\n\n    const forms = fr1.getForms();\n\n    return (\n        <div>\n            <label>\n                拍羅馬字, 輸出繼續形\n                <br />\n                <input type=\"text\" list=\"verbs\" onChange={handleChange} />\n            </label>\n            <datalist id=\"verbs\">\n                {phrasalVerbs.map(x => (\n                    <option key={x[0] + x[1]} value={x[0] + ' ' + x[1]} />\n                ))}\n            </datalist>\n            {forms.map(x => (\n                <a>{x.literal} </a>\n            ))}\n        </div>\n    );\n}\n\nexport default PhrasalVerbPage;\n","module.exports = dll_ef0ff7c60362f24a921f;"],"mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACZA;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACh2BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACxlCA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAKA;AAAA;AAAA;AAEA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAIA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAKA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC7CA;;;;A","sourceRoot":""}